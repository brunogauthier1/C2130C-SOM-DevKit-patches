Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: .clang-format
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: .cocciconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: .get_maintainer.ignore
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: .git
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: .gitattributes
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: .gitignore
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: .mailmap
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: Android.bp
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: AndroidKernel.mk
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: COPYING
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: CREDITS
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: Documentation
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: Kbuild
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: Kconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: LICENSES
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: MAINTAINERS
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: README
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: .gitignore
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: Kconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: alpha
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: arc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: arm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: Kconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: Kconfig.debug
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: Kconfig.platforms
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: boot
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64/configs: cuttlefish_defconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64/configs: defconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64/configs: ranchu64_defconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64/configs/vendor: kona-perf_defconfig
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64/configs/vendor/kona_defconfig msm-4.19/arch/arm64/configs/vendor/kona_defconfig
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64/configs/vendor/kona_defconfig	2024-04-16 19:14:56.056046721 +0000
+++ msm-4.19/arch/arm64/configs/vendor/kona_defconfig	2024-04-20 18:36:20.818499298 +0000
@@ -90,12 +90,23 @@
 CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
 CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
-CONFIG_KPROBES=y
-CONFIG_PANIC_ON_REFCOUNT_ERROR=y
+CONFIG_KyPROBES=y
+## ACHUEL
+CONFIG_PANIC_ON_REFCOUNT_ERROR=n
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
 CONFIG_MODULE_FORCE_UNLOAD=y
 CONFIG_MODVERSIONS=y
+##############################
+## ACHEUL
+##############################
+CONFIG_INPUT=y
+CONFIG_VCNL4000=m
+CONFIG_VCNL3040=m
+CONFIG_INV_ICM42600=m
+CONFIG_INV_ICM42600_I2C=m
+CONFIG_SENSORS_AKM09911=m
+##############################
 CONFIG_MODULE_SIG=y
 CONFIG_MODULE_SIG_FORCE=y
 CONFIG_MODULE_SIG_SHA512=y
@@ -742,8 +753,10 @@
 CONFIG_DEBUG_FORCE_WEAK_PER_CPU=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_DEBUG_PAGEALLOC=y
-CONFIG_SLUB_DEBUG_PANIC_ON=y
-CONFIG_DEBUG_PANIC_ON_OOM=y
+# ACHEUL
+CONFIG_SLUB_DEBUG_PANIC_ON=n
+CONFIG_DEBUG_PANIC_ON_OOM=n
+
 CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT=y
 CONFIG_PAGE_POISONING=y
 CONFIG_PAGE_POISONING_ENABLE_DEFAULT=y
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64/configs/vendor: lito-perf_defconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64/configs/vendor: lito_defconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: crypto
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: include
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: kernel
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: kvm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: lib
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: mm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: net
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch/arm64: xen
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: c6x
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: h8300
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: hexagon
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: ia64
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: m68k
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: microblaze
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: mips
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: nds32
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: nios2
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: openrisc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: parisc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: powerpc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: riscv
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: s390
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: sh
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: sparc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: um
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: unicore32
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: x86
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/arch: xtensa
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: block
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.aarch64
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.common
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.cuttlefish.aarch64
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.cuttlefish.x86_64
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.goldfish.arm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.goldfish.arm64
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.goldfish.mips
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.goldfish.mips64
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.goldfish.x86
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.goldfish.x86_64
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: build.config.x86_64
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: certs
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: crypto
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: Kconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: accessibility
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: acpi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: amba
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: android
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: ata
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: atm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: auxdisplay
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: base
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: bcma
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: block
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: bluetooth
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: bus
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: cdrom
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: char
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: clk
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: clocksource
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: connector
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: cpufreq
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: cpuidle
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: crypto
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: dax
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: dca
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: devfreq
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: dio
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: dma
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: dma-buf
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: edac
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: eisa
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: energy_model
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: esoc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: extcon
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: firewire
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: firmware
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: fmc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: fpga
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: fsi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: gnss
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: gpio
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: Kconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: amd
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: arc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: arm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: armada
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: ast
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: ati_pcigart.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: atmel-hlcdc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: bochs
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: bridge
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: cirrus
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_agpsupport.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_atomic.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_atomic_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_auth.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_blend.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_bootsplash.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_bridge.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_bufs.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_cache.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_client.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_client_modeset.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_color_mgmt.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_connector.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_context.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_crtc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_crtc_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_crtc_helper_internal.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_crtc_internal.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_debugfs.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_debugfs_crc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dma.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dp_aux_dev.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dp_cec.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dp_dual_mode_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dp_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dp_mst_topology.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_drv.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dumb_buffers.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_edid.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_edid_load.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_encoder.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_encoder_slave.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_fb_cma_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_fb_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_file.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_flip_work.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_fourcc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_framebuffer.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_gem.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_gem_cma_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_gem_framebuffer_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_global.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_hashtab.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_info.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_internal.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_ioc32.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_ioctl.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_irq.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_kms_helper_common.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_lease.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_legacy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_lock.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_memory.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_mipi_dsi.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_mm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_mode_config.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_mode_object.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_modes.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_modeset_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_modeset_lock.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_of.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_panel.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_panel_orientation_quirks.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_pci.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_plane.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_plane_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_prime.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_print.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_probe_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_property.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_rect.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_scatter.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_scdc_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_simple_kms_helper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_splash.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_syncobj.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_sysfs.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_trace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_trace_points.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_vblank.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_vm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_vma_manager.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_writeback.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: etnaviv
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: exynos
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: fsl-dcu
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: gma500
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: hisilicon
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: i2c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: i810
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: i915
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: imx
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: lib
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: mediatek
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: meson
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: mga
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: mgag200
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: msm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: mxsfb
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: nouveau
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: Kconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: TODO
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: displays
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: Kconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: base.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: core.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dispc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dispc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dispc_coefs.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: display.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dpi.c
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss/dsi.c msm-4.19/drivers/gpu/drm/omapdrm/dss/dsi.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss/dsi.c	2024-04-16 19:14:58.372045167 +0000
+++ msm-4.19/drivers/gpu/drm/omapdrm/dss/dsi.c	2024-04-20 18:36:20.822499295 +0000
@@ -3828,9 +3828,13 @@
 		return -ENODEV;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	r = dsi_display_init_dispc(dsi);
-	if (r)
+	if (r){
+        printk("%s:%d, ACHEUL, FAILED", __FUNCTION__, __LINE__);
 		goto err_init_dispc;
+    }
 
 	if (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {
 		switch (dsi->pix_fmt) {
@@ -3847,6 +3851,7 @@
 			data_type = MIPI_DSI_PACKED_PIXEL_STREAM_16;
 			break;
 		default:
+            printk("%s:%d, ACHEUL, FAILED", __FUNCTION__, __LINE__);
 			r = -EINVAL;
 			goto err_pix_fmt;
 		}
@@ -3867,9 +3872,12 @@
 	}
 
 	r = dss_mgr_enable(&dsi->output);
-	if (r)
+	if (r){
+        printk("%s:%d, ACHEUL, FAILED", __FUNCTION__, __LINE__);
 		goto err_mgr_enable;
+    }
 
+    printk("%s:%d, ACHEUL, OK", __FUNCTION__, __LINE__);
 	return 0;
 
 err_mgr_enable:
@@ -3880,6 +3888,7 @@
 err_pix_fmt:
 	dsi_display_uninit_dispc(dsi);
 err_init_dispc:
+    printk("%s:%d, ACHEUL, out: %d", __FUNCTION__, __LINE__, r);
 	return r;
 }
 
@@ -5074,6 +5083,12 @@
 	int r, i;
 	struct device_node *ep;
 	struct omap_dsi_pin_config pin_cfg;
+    const char* compatible = NULL;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+    of_property_read_string(node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
 
 	ep = of_graph_get_endpoint_by_regs(node, 0, 0);
 	if (!ep)
@@ -5081,6 +5096,7 @@
 
 	prop = of_find_property(ep, "lanes", &len);
 	if (prop == NULL) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		dev_err(dsi->dev, "failed to find lane data\n");
 		r = -EINVAL;
 		goto err;
@@ -5091,12 +5107,14 @@
 	if (num_pins < 4 || num_pins % 2 != 0 ||
 		num_pins > dsi->num_lanes_supported * 2) {
 		dev_err(dsi->dev, "bad number of lanes\n");
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		r = -EINVAL;
 		goto err;
 	}
 
 	r = of_property_read_u32_array(ep, "lanes", lane_arr, num_pins);
 	if (r) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		dev_err(dsi->dev, "failed to read lane data\n");
 		goto err;
 	}
@@ -5107,12 +5125,14 @@
 
 	r = dsi_configure_pins(&dsi->output, &pin_cfg);
 	if (r) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		dev_err(dsi->dev, "failed to configure pins");
 		goto err;
 	}
 
 	of_node_put(ep);
 
+    printk("%s:%d, ACHEUL, OK", __FUNCTION__, __LINE__);
 	return 0;
 
 err:
@@ -5310,11 +5330,17 @@
 	struct dsi_data *dsi;
 	struct resource *dsi_mem;
 	struct resource *res;
+    const char* compatible = NULL;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
 	if (!dsi)
 		return -ENOMEM;
 
+    of_property_read_string(dev->of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
 	dsi->dss = dss;
 	dsi->dev = dev;
 	dev_set_drvdata(dev, dsi);
@@ -5467,6 +5493,7 @@
 							    &dsi);
 #endif
 
+    printk("%s:%d, ACHEUL, OK", __FUNCTION__, __LINE__);
 	return 0;
 
 err_probe_of:
@@ -5475,6 +5502,7 @@
 
 err_runtime_get:
 	pm_runtime_disable(dev);
+    printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, r);
 	return r;
 }
 
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dss-of.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dss.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dss.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi4.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi4_cec.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi4_cec.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi4_core.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi4_core.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi5.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi5_core.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi5_core.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi_common.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi_phy.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi_pll.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi_wp.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: omapdss-boot-init.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: omapdss.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: output.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: pll.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: sdi.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: venc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: video-pll.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_connector.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_connector.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_crtc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_crtc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_debugfs.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_dmm_priv.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_dmm_tiler.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_dmm_tiler.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_drv.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_drv.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_encoder.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_encoder.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_fb.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_fb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_fbdev.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_fbdev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_gem.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_gem.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_gem_dmabuf.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_irq.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_irq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_plane.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_plane.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: tcm-sita.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: tcm-sita.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: tcm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: panel
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: pl111
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: qxl
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: r128
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: radeon
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: rcar-du
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: rockchip
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: savage
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: scheduler
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: selftests
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: shmobile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: sis
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: sti
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: stm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: sun4i
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: tdfx
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: tegra
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: tilcdc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: tinydrm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: ttm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: tve200
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: udl
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: v3d
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: vc4
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: vgem
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: via
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: virtio
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: vkms
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: vmwgfx
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: xen
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: zte
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu: host1x
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu: ipu-v3
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu: msm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/gpu: vga
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: hid
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: hsi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: hv
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: hwmon
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: hwspinlock
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: hwtracing
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: i2c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: i3c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: ide
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: idle
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: Kconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: accel
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: adc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: afe
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: amplifiers
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: buffer
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: chemical
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: common
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: counter
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: dac
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: dummy
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: frequency
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: gyro
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: health
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: humidity
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: iio_core.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: iio_core_trigger.h
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/Kconfig msm-4.19/drivers/iio/imu/Kconfig
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/Kconfig	2024-04-16 19:14:58.664044971 +0000
+++ msm-4.19/drivers/iio/imu/Kconfig	2024-04-20 18:36:20.822499295 +0000
@@ -41,6 +41,11 @@
 source "drivers/iio/imu/inv_mpu6050/Kconfig"
 source "drivers/iio/imu/st_lsm6dsx/Kconfig"
 
+########################################################
+## ACHEUL
+########################################################
+source "drivers/iio/imu/inv_icm42600/Kconfig"
+
 endmenu
 
 config IIO_ADIS_LIB
@@ -54,3 +59,4 @@
 	help
 	  A set of buffer helper functions for the Analog Devices ADIS* device
 	  family.
+
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/Makefile msm-4.19/drivers/iio/imu/Makefile
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/Makefile	2024-04-16 19:14:58.664044971 +0000
+++ msm-4.19/drivers/iio/imu/Makefile	2024-04-20 18:36:20.826499294 +0000
@@ -9,6 +9,11 @@
 obj-$(CONFIG_ADIS16400) += adis16400.o
 obj-$(CONFIG_ADIS16480) += adis16480.o
 
+#########################################
+## ACHEUL
+obj-y += inv_icm42600/
+#########################################
+
 adis_lib-y += adis.o
 adis_lib-$(CONFIG_IIO_ADIS_LIB_BUFFER) += adis_trigger.o
 adis_lib-$(CONFIG_IIO_ADIS_LIB_BUFFER) += adis_buffer.o
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis16400.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis16400_buffer.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis16400_core.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis16480.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis_buffer.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis_trigger.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: bmi160
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/Kconfig msm-4.19/drivers/iio/imu/inv_icm42600/Kconfig
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/Kconfig	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,29 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+config INV_ICM42600
+	tristate
+	select IIO_BUFFER
+
+config INV_ICM42600_I2C
+	tristate "InvenSense ICM-426xx I2C driver"
+	depends on I2C
+	select INV_ICM42600
+	select REGMAP_I2C
+	help
+	  This driver supports the InvenSense ICM-426xx motion tracking
+	  devices over I2C.
+
+	  This driver can be built as a module. The module will be called
+	  inv-icm42600-i2c.
+
+config INV_ICM42600_SPI
+	tristate "InvenSense ICM-426xx SPI driver"
+	depends on SPI_MASTER
+	select INV_ICM42600
+	select REGMAP_SPI
+	help
+	  This driver supports the InvenSense ICM-426xx motion tracking
+	  devices over SPI.
+
+	  This driver can be built as a module. The module will be called
+	  inv-icm42600-spi.
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/Makefile msm-4.19/drivers/iio/imu/inv_icm42600/Makefile
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/Makefile	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+obj-$(CONFIG_INV_ICM42600) += inv-icm42600.o
+inv-icm42600-y += inv_icm42600_core.o
+inv-icm42600-y += inv_icm42600_gyro.o
+inv-icm42600-y += inv_icm42600_accel.o
+inv-icm42600-y += inv_icm42600_temp.o
+inv-icm42600-y += inv_icm42600_buffer.o
+inv-icm42600-y += inv_icm42600_timestamp.o
+
+obj-$(CONFIG_INV_ICM42600_I2C) += inv-icm42600-i2c.o
+inv-icm42600-i2c-y += inv_icm42600_i2c.o
+
+obj-$(CONFIG_INV_ICM42600_SPI) += inv-icm42600-spi.o
+inv-icm42600-spi-y += inv_icm42600_spi.o
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600.h msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600.h
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600.h	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600.h	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,396 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#ifndef INV_ICM42600_H_
+#define INV_ICM42600_H_
+
+#include <linux/bits.h>
+#include <linux/bitfield.h>
+#include <linux/regmap.h>
+#include <linux/mutex.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pm.h>
+#include <linux/iio/iio.h>
+
+#include "inv_icm42600_buffer.h"
+
+enum inv_icm42600_chip {
+	INV_CHIP_INVALID,
+	INV_CHIP_ICM42600,
+	INV_CHIP_ICM42602,
+	INV_CHIP_ICM42605,
+	INV_CHIP_ICM42622,
+	INV_CHIP_NB,
+};
+
+/* serial bus slew rates */
+enum inv_icm42600_slew_rate {
+	INV_ICM42600_SLEW_RATE_20_60NS,
+	INV_ICM42600_SLEW_RATE_12_36NS,
+	INV_ICM42600_SLEW_RATE_6_18NS,
+	INV_ICM42600_SLEW_RATE_4_12NS,
+	INV_ICM42600_SLEW_RATE_2_6NS,
+	INV_ICM42600_SLEW_RATE_INF_2NS,
+};
+
+enum inv_icm42600_sensor_mode {
+	INV_ICM42600_SENSOR_MODE_OFF,
+	INV_ICM42600_SENSOR_MODE_STANDBY,
+	INV_ICM42600_SENSOR_MODE_LOW_POWER,
+	INV_ICM42600_SENSOR_MODE_LOW_NOISE,
+	INV_ICM42600_SENSOR_MODE_NB,
+};
+
+/* gyroscope fullscale values */
+enum inv_icm42600_gyro_fs {
+	INV_ICM42600_GYRO_FS_2000DPS,
+	INV_ICM42600_GYRO_FS_1000DPS,
+	INV_ICM42600_GYRO_FS_500DPS,
+	INV_ICM42600_GYRO_FS_250DPS,
+	INV_ICM42600_GYRO_FS_125DPS,
+	INV_ICM42600_GYRO_FS_62_5DPS,
+	INV_ICM42600_GYRO_FS_31_25DPS,
+	INV_ICM42600_GYRO_FS_15_625DPS,
+	INV_ICM42600_GYRO_FS_NB,
+};
+
+/* accelerometer fullscale values */
+enum inv_icm42600_accel_fs {
+	INV_ICM42600_ACCEL_FS_16G,
+	INV_ICM42600_ACCEL_FS_8G,
+	INV_ICM42600_ACCEL_FS_4G,
+	INV_ICM42600_ACCEL_FS_2G,
+	INV_ICM42600_ACCEL_FS_NB,
+};
+
+/* ODR suffixed by LN or LP are Low-Noise or Low-Power mode only */
+enum inv_icm42600_odr {
+	INV_ICM42600_ODR_8KHZ_LN = 3,
+	INV_ICM42600_ODR_4KHZ_LN,
+	INV_ICM42600_ODR_2KHZ_LN,
+	INV_ICM42600_ODR_1KHZ_LN,
+	INV_ICM42600_ODR_200HZ,
+	INV_ICM42600_ODR_100HZ,
+	INV_ICM42600_ODR_50HZ,
+	INV_ICM42600_ODR_25HZ,
+	INV_ICM42600_ODR_12_5HZ,
+	INV_ICM42600_ODR_6_25HZ_LP,
+	INV_ICM42600_ODR_3_125HZ_LP,
+	INV_ICM42600_ODR_1_5625HZ_LP,
+	INV_ICM42600_ODR_500HZ,
+	INV_ICM42600_ODR_NB,
+};
+
+enum inv_icm42600_filter {
+	/* Low-Noise mode sensor data filter (3rd order filter by default) */
+	INV_ICM42600_FILTER_BW_ODR_DIV_2,
+
+	/* Low-Power mode sensor data filter (averaging) */
+	INV_ICM42600_FILTER_AVG_1X = 1,
+	INV_ICM42600_FILTER_AVG_16X = 6,
+};
+
+struct inv_icm42600_sensor_conf {
+	int mode;
+	int fs;
+	int odr;
+	int filter;
+};
+#define INV_ICM42600_SENSOR_CONF_INIT		{-1, -1, -1, -1}
+
+struct inv_icm42600_conf {
+	struct inv_icm42600_sensor_conf gyro;
+	struct inv_icm42600_sensor_conf accel;
+	bool temp_en;
+};
+
+struct inv_icm42600_suspended {
+	enum inv_icm42600_sensor_mode gyro;
+	enum inv_icm42600_sensor_mode accel;
+	bool temp;
+};
+
+/**
+ *  struct inv_icm42600_state - driver state variables
+ *  @lock:		lock for serializing multiple registers access.
+ *  @chip:		chip identifier.
+ *  @name:		chip name.
+ *  @map:		regmap pointer.
+ *  @vdd_supply:	VDD voltage regulator for the chip.
+ *  @vddio_supply:	I/O voltage regulator for the chip.
+ *  @orientation:	sensor chip orientation relative to main hardware.
+ *  @conf:		chip sensors configurations.
+ *  @suspended:		suspended sensors configuration.
+ *  @indio_gyro:	gyroscope IIO device.
+ *  @indio_accel:	accelerometer IIO device.
+ *  @buffer:		data transfer buffer aligned for DMA.
+ *  @fifo:		FIFO management structure.
+ *  @timestamp:		interrupt timestamps.
+ */
+struct inv_icm42600_state {
+	struct mutex lock;
+	enum inv_icm42600_chip chip;
+	const char *name;
+	struct regmap *map;
+	struct regulator *vdd_supply;
+	struct regulator *vddio_supply;
+	struct iio_mount_matrix orientation;
+	struct inv_icm42600_conf conf;
+	struct inv_icm42600_suspended suspended;
+	struct iio_dev *indio_gyro;
+	struct iio_dev *indio_accel;
+	uint8_t buffer[2] ____cacheline_aligned;
+	struct inv_icm42600_fifo fifo;
+	struct {
+		int64_t gyro;
+		int64_t accel;
+	} timestamp;
+};
+
+/* Virtual register addresses: @bank on MSB (4 upper bits), @address on LSB */
+
+/* Bank selection register, available in all banks */
+#define INV_ICM42600_REG_BANK_SEL			0x76
+#define INV_ICM42600_BANK_SEL_MASK			GENMASK(2, 0)
+
+/* User bank 0 (MSB 0x00) */
+#define INV_ICM42600_REG_DEVICE_CONFIG			0x0011
+#define INV_ICM42600_DEVICE_CONFIG_SOFT_RESET		BIT(0)
+
+#define INV_ICM42600_REG_DRIVE_CONFIG			0x0013
+#define INV_ICM42600_DRIVE_CONFIG_I2C_MASK		GENMASK(5, 3)
+#define INV_ICM42600_DRIVE_CONFIG_I2C(_rate)		\
+		FIELD_PREP(INV_ICM42600_DRIVE_CONFIG_I2C_MASK, (_rate))
+#define INV_ICM42600_DRIVE_CONFIG_SPI_MASK		GENMASK(2, 0)
+#define INV_ICM42600_DRIVE_CONFIG_SPI(_rate)		\
+		FIELD_PREP(INV_ICM42600_DRIVE_CONFIG_SPI_MASK, (_rate))
+
+#define INV_ICM42600_REG_INT_CONFIG			0x0014
+#define INV_ICM42600_INT_CONFIG_INT2_LATCHED		BIT(5)
+#define INV_ICM42600_INT_CONFIG_INT2_PUSH_PULL		BIT(4)
+#define INV_ICM42600_INT_CONFIG_INT2_ACTIVE_HIGH	BIT(3)
+#define INV_ICM42600_INT_CONFIG_INT2_ACTIVE_LOW		0x00
+#define INV_ICM42600_INT_CONFIG_INT1_LATCHED		BIT(2)
+#define INV_ICM42600_INT_CONFIG_INT1_PUSH_PULL		BIT(1)
+#define INV_ICM42600_INT_CONFIG_INT1_ACTIVE_HIGH	BIT(0)
+#define INV_ICM42600_INT_CONFIG_INT1_ACTIVE_LOW		0x00
+
+#define INV_ICM42600_REG_FIFO_CONFIG			0x0016
+#define INV_ICM42600_FIFO_CONFIG_MASK			GENMASK(7, 6)
+#define INV_ICM42600_FIFO_CONFIG_BYPASS			\
+		FIELD_PREP(INV_ICM42600_FIFO_CONFIG_MASK, 0)
+#define INV_ICM42600_FIFO_CONFIG_STREAM			\
+		FIELD_PREP(INV_ICM42600_FIFO_CONFIG_MASK, 1)
+#define INV_ICM42600_FIFO_CONFIG_STOP_ON_FULL		\
+		FIELD_PREP(INV_ICM42600_FIFO_CONFIG_MASK, 2)
+
+/* all sensor data are 16 bits (2 registers wide) in big-endian */
+#define INV_ICM42600_REG_TEMP_DATA			0x001D
+#define INV_ICM42600_REG_ACCEL_DATA_X			0x001F
+#define INV_ICM42600_REG_ACCEL_DATA_Y			0x0021
+#define INV_ICM42600_REG_ACCEL_DATA_Z			0x0023
+#define INV_ICM42600_REG_GYRO_DATA_X			0x0025
+#define INV_ICM42600_REG_GYRO_DATA_Y			0x0027
+#define INV_ICM42600_REG_GYRO_DATA_Z			0x0029
+#define INV_ICM42600_DATA_INVALID			-32768
+
+#define INV_ICM42600_REG_INT_STATUS			0x002D
+#define INV_ICM42600_INT_STATUS_UI_FSYNC		BIT(6)
+#define INV_ICM42600_INT_STATUS_PLL_RDY			BIT(5)
+#define INV_ICM42600_INT_STATUS_RESET_DONE		BIT(4)
+#define INV_ICM42600_INT_STATUS_DATA_RDY		BIT(3)
+#define INV_ICM42600_INT_STATUS_FIFO_THS		BIT(2)
+#define INV_ICM42600_INT_STATUS_FIFO_FULL		BIT(1)
+#define INV_ICM42600_INT_STATUS_AGC_RDY			BIT(0)
+
+/*
+ * FIFO access registers
+ * FIFO count is 16 bits (2 registers) big-endian
+ * FIFO data is a continuous read register to read FIFO content
+ */
+#define INV_ICM42600_REG_FIFO_COUNT			0x002E
+#define INV_ICM42600_REG_FIFO_DATA			0x0030
+
+#define INV_ICM42600_REG_SIGNAL_PATH_RESET		0x004B
+#define INV_ICM42600_SIGNAL_PATH_RESET_DMP_INIT_EN	BIT(6)
+#define INV_ICM42600_SIGNAL_PATH_RESET_DMP_MEM_RESET	BIT(5)
+#define INV_ICM42600_SIGNAL_PATH_RESET_RESET		BIT(3)
+#define INV_ICM42600_SIGNAL_PATH_RESET_TMST_STROBE	BIT(2)
+#define INV_ICM42600_SIGNAL_PATH_RESET_FIFO_FLUSH	BIT(1)
+
+/* default configuration: all data big-endian and fifo count in bytes */
+#define INV_ICM42600_REG_INTF_CONFIG0			0x004C
+#define INV_ICM42600_INTF_CONFIG0_FIFO_HOLD_LAST_DATA	BIT(7)
+#define INV_ICM42600_INTF_CONFIG0_FIFO_COUNT_REC	BIT(6)
+#define INV_ICM42600_INTF_CONFIG0_FIFO_COUNT_ENDIAN	BIT(5)
+#define INV_ICM42600_INTF_CONFIG0_SENSOR_DATA_ENDIAN	BIT(4)
+#define INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_MASK	GENMASK(1, 0)
+#define INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_SPI_DIS	\
+		FIELD_PREP(INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_MASK, 2)
+#define INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_I2C_DIS	\
+		FIELD_PREP(INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_MASK, 3)
+
+#define INV_ICM42600_REG_INTF_CONFIG1			0x004D
+#define INV_ICM42600_INTF_CONFIG1_ACCEL_LP_CLK_RC	BIT(3)
+
+#define INV_ICM42600_REG_PWR_MGMT0			0x004E
+#define INV_ICM42600_PWR_MGMT0_TEMP_DIS			BIT(5)
+#define INV_ICM42600_PWR_MGMT0_IDLE			BIT(4)
+#define INV_ICM42600_PWR_MGMT0_GYRO(_mode)		\
+		FIELD_PREP(GENMASK(3, 2), (_mode))
+#define INV_ICM42600_PWR_MGMT0_ACCEL(_mode)		\
+		FIELD_PREP(GENMASK(1, 0), (_mode))
+
+#define INV_ICM42600_REG_GYRO_CONFIG0			0x004F
+#define INV_ICM42600_GYRO_CONFIG0_FS(_fs)		\
+		FIELD_PREP(GENMASK(7, 5), (_fs))
+#define INV_ICM42600_GYRO_CONFIG0_ODR(_odr)		\
+		FIELD_PREP(GENMASK(3, 0), (_odr))
+
+#define INV_ICM42600_REG_ACCEL_CONFIG0			0x0050
+#define INV_ICM42600_ACCEL_CONFIG0_FS(_fs)		\
+		FIELD_PREP(GENMASK(7, 5), (_fs))
+#define INV_ICM42600_ACCEL_CONFIG0_ODR(_odr)		\
+		FIELD_PREP(GENMASK(3, 0), (_odr))
+
+#define INV_ICM42600_REG_GYRO_ACCEL_CONFIG0		0x0052
+#define INV_ICM42600_GYRO_ACCEL_CONFIG0_ACCEL_FILT(_f)	\
+		FIELD_PREP(GENMASK(7, 4), (_f))
+#define INV_ICM42600_GYRO_ACCEL_CONFIG0_GYRO_FILT(_f)	\
+		FIELD_PREP(GENMASK(3, 0), (_f))
+
+#define INV_ICM42600_REG_TMST_CONFIG			0x0054
+#define INV_ICM42600_TMST_CONFIG_MASK			GENMASK(4, 0)
+#define INV_ICM42600_TMST_CONFIG_TMST_TO_REGS_EN	BIT(4)
+#define INV_ICM42600_TMST_CONFIG_TMST_RES_16US		BIT(3)
+#define INV_ICM42600_TMST_CONFIG_TMST_DELTA_EN		BIT(2)
+#define INV_ICM42600_TMST_CONFIG_TMST_FSYNC_EN		BIT(1)
+#define INV_ICM42600_TMST_CONFIG_TMST_EN		BIT(0)
+
+#define INV_ICM42600_REG_FIFO_CONFIG1			0x005F
+#define INV_ICM42600_FIFO_CONFIG1_RESUME_PARTIAL_RD	BIT(6)
+#define INV_ICM42600_FIFO_CONFIG1_WM_GT_TH		BIT(5)
+#define INV_ICM42600_FIFO_CONFIG1_TMST_FSYNC_EN		BIT(3)
+#define INV_ICM42600_FIFO_CONFIG1_TEMP_EN		BIT(2)
+#define INV_ICM42600_FIFO_CONFIG1_GYRO_EN		BIT(1)
+#define INV_ICM42600_FIFO_CONFIG1_ACCEL_EN		BIT(0)
+
+/* FIFO watermark is 16 bits (2 registers wide) in little-endian */
+#define INV_ICM42600_REG_FIFO_WATERMARK			0x0060
+#define INV_ICM42600_FIFO_WATERMARK_VAL(_wm)		\
+		cpu_to_le16((_wm) & GENMASK(11, 0))
+/* FIFO is 2048 bytes, let 12 samples for reading latency */
+#define INV_ICM42600_FIFO_WATERMARK_MAX			(2048 - 12 * 16)
+
+#define INV_ICM42600_REG_INT_CONFIG1			0x0064
+#define INV_ICM42600_INT_CONFIG1_TPULSE_DURATION	BIT(6)
+#define INV_ICM42600_INT_CONFIG1_TDEASSERT_DISABLE	BIT(5)
+#define INV_ICM42600_INT_CONFIG1_ASYNC_RESET		BIT(4)
+
+#define INV_ICM42600_REG_INT_SOURCE0			0x0065
+#define INV_ICM42600_INT_SOURCE0_UI_FSYNC_INT1_EN	BIT(6)
+#define INV_ICM42600_INT_SOURCE0_PLL_RDY_INT1_EN	BIT(5)
+#define INV_ICM42600_INT_SOURCE0_RESET_DONE_INT1_EN	BIT(4)
+#define INV_ICM42600_INT_SOURCE0_UI_DRDY_INT1_EN	BIT(3)
+#define INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN	BIT(2)
+#define INV_ICM42600_INT_SOURCE0_FIFO_FULL_INT1_EN	BIT(1)
+#define INV_ICM42600_INT_SOURCE0_UI_AGC_RDY_INT1_EN	BIT(0)
+
+#define INV_ICM42600_REG_WHOAMI				0x0075
+#define INV_ICM42600_WHOAMI_ICM42600			0x40
+#define INV_ICM42600_WHOAMI_ICM42602			0x41
+#define INV_ICM42600_WHOAMI_ICM42605			0x47
+#define INV_ICM42600_WHOAMI_ICM42622			0x46
+
+/* User bank 1 (MSB 0x10) */
+#define INV_ICM42600_REG_SENSOR_CONFIG0			0x1003
+#define INV_ICM42600_SENSOR_CONFIG0_ZG_DISABLE		BIT(5)
+#define INV_ICM42600_SENSOR_CONFIG0_YG_DISABLE		BIT(4)
+#define INV_ICM42600_SENSOR_CONFIG0_XG_DISABLE		BIT(3)
+#define INV_ICM42600_SENSOR_CONFIG0_ZA_DISABLE		BIT(2)
+#define INV_ICM42600_SENSOR_CONFIG0_YA_DISABLE		BIT(1)
+#define INV_ICM42600_SENSOR_CONFIG0_XA_DISABLE		BIT(0)
+
+/* Timestamp value is 20 bits (3 registers) in little-endian */
+#define INV_ICM42600_REG_TMSTVAL			0x1062
+#define INV_ICM42600_TMSTVAL_MASK			GENMASK(19, 0)
+
+#define INV_ICM42600_REG_INTF_CONFIG4			0x107A
+#define INV_ICM42600_INTF_CONFIG4_I3C_BUS_ONLY		BIT(6)
+#define INV_ICM42600_INTF_CONFIG4_SPI_AP_4WIRE		BIT(1)
+
+#define INV_ICM42600_REG_INTF_CONFIG6			0x107C
+#define INV_ICM42600_INTF_CONFIG6_MASK			GENMASK(4, 0)
+#define INV_ICM42600_INTF_CONFIG6_I3C_EN		BIT(4)
+#define INV_ICM42600_INTF_CONFIG6_I3C_IBI_BYTE_EN	BIT(3)
+#define INV_ICM42600_INTF_CONFIG6_I3C_IBI_EN		BIT(2)
+#define INV_ICM42600_INTF_CONFIG6_I3C_DDR_EN		BIT(1)
+#define INV_ICM42600_INTF_CONFIG6_I3C_SDR_EN		BIT(0)
+
+/* User bank 4 (MSB 0x40) */
+#define INV_ICM42600_REG_INT_SOURCE8			0x404F
+#define INV_ICM42600_INT_SOURCE8_FSYNC_IBI_EN		BIT(5)
+#define INV_ICM42600_INT_SOURCE8_PLL_RDY_IBI_EN		BIT(4)
+#define INV_ICM42600_INT_SOURCE8_UI_DRDY_IBI_EN		BIT(3)
+#define INV_ICM42600_INT_SOURCE8_FIFO_THS_IBI_EN	BIT(2)
+#define INV_ICM42600_INT_SOURCE8_FIFO_FULL_IBI_EN	BIT(1)
+#define INV_ICM42600_INT_SOURCE8_AGC_RDY_IBI_EN		BIT(0)
+
+#define INV_ICM42600_REG_OFFSET_USER0			0x4077
+#define INV_ICM42600_REG_OFFSET_USER1			0x4078
+#define INV_ICM42600_REG_OFFSET_USER2			0x4079
+#define INV_ICM42600_REG_OFFSET_USER3			0x407A
+#define INV_ICM42600_REG_OFFSET_USER4			0x407B
+#define INV_ICM42600_REG_OFFSET_USER5			0x407C
+#define INV_ICM42600_REG_OFFSET_USER6			0x407D
+#define INV_ICM42600_REG_OFFSET_USER7			0x407E
+#define INV_ICM42600_REG_OFFSET_USER8			0x407F
+
+/* Sleep times required by the driver */
+#define INV_ICM42600_POWER_UP_TIME_MS		100
+#define INV_ICM42600_RESET_TIME_MS		1
+#define INV_ICM42600_ACCEL_STARTUP_TIME_MS	20
+#define INV_ICM42600_GYRO_STARTUP_TIME_MS	60
+#define INV_ICM42600_GYRO_STOP_TIME_MS		150
+#define INV_ICM42600_TEMP_STARTUP_TIME_MS	14
+#define INV_ICM42600_SUSPEND_DELAY_MS		2000
+
+typedef int (*inv_icm42600_bus_setup)(struct inv_icm42600_state *);
+
+extern const struct regmap_config inv_icm42600_regmap_config;
+extern const struct dev_pm_ops inv_icm42600_pm_ops;
+
+const struct iio_mount_matrix *
+inv_icm42600_get_mount_matrix(const struct iio_dev *indio_dev,
+			      const struct iio_chan_spec *chan);
+
+uint32_t inv_icm42600_odr_to_period(enum inv_icm42600_odr odr);
+
+int inv_icm42600_set_accel_conf(struct inv_icm42600_state *st,
+				struct inv_icm42600_sensor_conf *conf,
+				unsigned int *sleep_ms);
+
+int inv_icm42600_set_gyro_conf(struct inv_icm42600_state *st,
+			       struct inv_icm42600_sensor_conf *conf,
+			       unsigned int *sleep_ms);
+
+int inv_icm42600_set_temp_conf(struct inv_icm42600_state *st, bool enable,
+			       unsigned int *sleep_ms);
+
+int inv_icm42600_debugfs_reg(struct iio_dev *indio_dev, unsigned int reg,
+			     unsigned int writeval, unsigned int *readval);
+
+int inv_icm42600_core_probe(struct regmap *regmap, int chip, int irq,
+			    inv_icm42600_bus_setup bus_setup);
+
+struct iio_dev *inv_icm42600_gyro_init(struct inv_icm42600_state *st);
+
+int inv_icm42600_gyro_parse_fifo(struct iio_dev *indio_dev);
+
+struct iio_dev *inv_icm42600_accel_init(struct inv_icm42600_state *st);
+
+int inv_icm42600_accel_parse_fifo(struct iio_dev *indio_dev);
+
+#endif
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_accel.c msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_accel.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_accel.c	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_accel.c	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,788 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/math64.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/kfifo_buf.h>
+
+#include "inv_icm42600.h"
+#include "inv_icm42600_temp.h"
+#include "inv_icm42600_buffer.h"
+#include "inv_icm42600_timestamp.h"
+
+#define INV_ICM42600_ACCEL_CHAN(_modifier, _index, _ext_info)		\
+	{								\
+		.type = IIO_ACCEL,					\
+		.modified = 1,						\
+		.channel2 = _modifier,					\
+		.info_mask_separate =					\
+			BIT(IIO_CHAN_INFO_RAW) |			\
+			BIT(IIO_CHAN_INFO_CALIBBIAS),			\
+		.info_mask_shared_by_type =				\
+			BIT(IIO_CHAN_INFO_SCALE),			\
+		.info_mask_shared_by_type_available =			\
+			BIT(IIO_CHAN_INFO_SCALE) |			\
+			BIT(IIO_CHAN_INFO_CALIBBIAS),			\
+		.info_mask_shared_by_all =				\
+			BIT(IIO_CHAN_INFO_SAMP_FREQ),			\
+		.info_mask_shared_by_all_available =			\
+			BIT(IIO_CHAN_INFO_SAMP_FREQ),			\
+		.scan_index = _index,					\
+		.scan_type = {						\
+			.sign = 's',					\
+			.realbits = 16,					\
+			.storagebits = 16,				\
+			.endianness = IIO_BE,				\
+		},							\
+		.ext_info = _ext_info,					\
+	}
+
+enum inv_icm42600_accel_scan {
+	INV_ICM42600_ACCEL_SCAN_X,
+	INV_ICM42600_ACCEL_SCAN_Y,
+	INV_ICM42600_ACCEL_SCAN_Z,
+	INV_ICM42600_ACCEL_SCAN_TEMP,
+	INV_ICM42600_ACCEL_SCAN_TIMESTAMP,
+};
+
+static const struct iio_chan_spec_ext_info inv_icm42600_accel_ext_infos[] = {
+	IIO_MOUNT_MATRIX(IIO_SHARED_BY_ALL, inv_icm42600_get_mount_matrix),
+	{},
+};
+
+static const struct iio_chan_spec inv_icm42600_accel_channels[] = {
+	INV_ICM42600_ACCEL_CHAN(IIO_MOD_X, INV_ICM42600_ACCEL_SCAN_X,
+				inv_icm42600_accel_ext_infos),
+	INV_ICM42600_ACCEL_CHAN(IIO_MOD_Y, INV_ICM42600_ACCEL_SCAN_Y,
+				inv_icm42600_accel_ext_infos),
+	INV_ICM42600_ACCEL_CHAN(IIO_MOD_Z, INV_ICM42600_ACCEL_SCAN_Z,
+				inv_icm42600_accel_ext_infos),
+	INV_ICM42600_TEMP_CHAN(INV_ICM42600_ACCEL_SCAN_TEMP),
+	IIO_CHAN_SOFT_TIMESTAMP(INV_ICM42600_ACCEL_SCAN_TIMESTAMP),
+};
+
+/*
+ * IIO buffer data: size must be a power of 2 and timestamp aligned
+ * 16 bytes: 6 bytes acceleration, 2 bytes temperature, 8 bytes timestamp
+ */
+struct inv_icm42600_accel_buffer {
+	struct inv_icm42600_fifo_sensor_data accel;
+	int16_t temp;
+	int64_t timestamp __aligned(8);
+};
+
+#define INV_ICM42600_SCAN_MASK_ACCEL_3AXIS				\
+	(BIT(INV_ICM42600_ACCEL_SCAN_X) |				\
+	BIT(INV_ICM42600_ACCEL_SCAN_Y) |				\
+	BIT(INV_ICM42600_ACCEL_SCAN_Z))
+
+#define INV_ICM42600_SCAN_MASK_TEMP	BIT(INV_ICM42600_ACCEL_SCAN_TEMP)
+
+static const unsigned long inv_icm42600_accel_scan_masks[] = {
+	/* 3-axis accel + temperature */
+	INV_ICM42600_SCAN_MASK_ACCEL_3AXIS | INV_ICM42600_SCAN_MASK_TEMP,
+	0,
+};
+
+/* enable accelerometer sensor and FIFO write */
+static int inv_icm42600_accel_update_scan_mode(struct iio_dev *indio_dev,
+					       const unsigned long *scan_mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	unsigned int fifo_en = 0;
+	unsigned int sleep_temp = 0;
+	unsigned int sleep_accel = 0;
+	unsigned int sleep;
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	if (*scan_mask & INV_ICM42600_SCAN_MASK_TEMP) {
+		/* enable temp sensor */
+		ret = inv_icm42600_set_temp_conf(st, true, &sleep_temp);
+		if (ret)
+			goto out_unlock;
+		fifo_en |= INV_ICM42600_SENSOR_TEMP;
+	}
+
+	if (*scan_mask & INV_ICM42600_SCAN_MASK_ACCEL_3AXIS) {
+		/* enable accel sensor */
+		conf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;
+		ret = inv_icm42600_set_accel_conf(st, &conf, &sleep_accel);
+		if (ret)
+			goto out_unlock;
+		fifo_en |= INV_ICM42600_SENSOR_ACCEL;
+	}
+
+	/* update data FIFO write */
+	inv_icm42600_timestamp_apply_odr(ts, 0, 0, 0);
+	ret = inv_icm42600_buffer_set_fifo_en(st, fifo_en | st->fifo.en);
+	if (ret)
+		goto out_unlock;
+
+	ret = inv_icm42600_buffer_update_watermark(st);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	/* sleep maximum required time */
+	if (sleep_accel > sleep_temp)
+		sleep = sleep_accel;
+	else
+		sleep = sleep_temp;
+	if (sleep)
+		msleep(sleep);
+	return ret;
+}
+
+static int inv_icm42600_accel_read_sensor(struct inv_icm42600_state *st,
+					  struct iio_chan_spec const *chan,
+					  int16_t *val)
+{
+	struct device *dev = regmap_get_device(st->map);
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	unsigned int reg;
+	__be16 *data;
+	int ret;
+
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_ACCEL_DATA_X;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_ACCEL_DATA_Y;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_ACCEL_DATA_Z;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	/* enable accel sensor */
+	conf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;
+	ret = inv_icm42600_set_accel_conf(st, &conf, NULL);
+	if (ret)
+		goto exit;
+
+	/* read accel register data */
+	data = (__be16 *)&st->buffer[0];
+	ret = regmap_bulk_read(st->map, reg, data, sizeof(*data));
+	if (ret)
+		goto exit;
+
+	*val = (int16_t)be16_to_cpup(data);
+	if (*val == INV_ICM42600_DATA_INVALID)
+		ret = -EINVAL;
+exit:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	return ret;
+}
+
+/* IIO format int + nano */
+static const int inv_icm42600_accel_scale[] = {
+	/* +/- 16G => 0.004788403 m/s-2 */
+	[2 * INV_ICM42600_ACCEL_FS_16G] = 0,
+	[2 * INV_ICM42600_ACCEL_FS_16G + 1] = 4788403,
+	/* +/- 8G => 0.002394202 m/s-2 */
+	[2 * INV_ICM42600_ACCEL_FS_8G] = 0,
+	[2 * INV_ICM42600_ACCEL_FS_8G + 1] = 2394202,
+	/* +/- 4G => 0.001197101 m/s-2 */
+	[2 * INV_ICM42600_ACCEL_FS_4G] = 0,
+	[2 * INV_ICM42600_ACCEL_FS_4G + 1] = 1197101,
+	/* +/- 2G => 0.000598550 m/s-2 */
+	[2 * INV_ICM42600_ACCEL_FS_2G] = 0,
+	[2 * INV_ICM42600_ACCEL_FS_2G + 1] = 598550,
+};
+
+static int inv_icm42600_accel_read_scale(struct inv_icm42600_state *st,
+					 int *val, int *val2)
+{
+	unsigned int idx;
+
+	idx = st->conf.accel.fs;
+
+	*val = inv_icm42600_accel_scale[2 * idx];
+	*val2 = inv_icm42600_accel_scale[2 * idx + 1];
+	return IIO_VAL_INT_PLUS_NANO;
+}
+
+static int inv_icm42600_accel_write_scale(struct inv_icm42600_state *st,
+					  int val, int val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int idx;
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	int ret;
+
+	for (idx = 0; idx < ARRAY_SIZE(inv_icm42600_accel_scale); idx += 2) {
+		if (val == inv_icm42600_accel_scale[idx] &&
+		    val2 == inv_icm42600_accel_scale[idx + 1])
+			break;
+	}
+	if (idx >= ARRAY_SIZE(inv_icm42600_accel_scale))
+		return -EINVAL;
+
+	conf.fs = idx / 2;
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_set_accel_conf(st, &conf, NULL);
+
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+/* IIO format int + micro */
+static const int inv_icm42600_accel_odr[] = {
+	/* 12.5Hz */
+	12, 500000,
+	/* 25Hz */
+	25, 0,
+	/* 50Hz */
+	50, 0,
+	/* 100Hz */
+	100, 0,
+	/* 200Hz */
+	200, 0,
+	/* 1kHz */
+	1000, 0,
+	/* 2kHz */
+	2000, 0,
+	/* 4kHz */
+	4000, 0,
+};
+
+static const int inv_icm42600_accel_odr_conv[] = {
+	INV_ICM42600_ODR_12_5HZ,
+	INV_ICM42600_ODR_25HZ,
+	INV_ICM42600_ODR_50HZ,
+	INV_ICM42600_ODR_100HZ,
+	INV_ICM42600_ODR_200HZ,
+	INV_ICM42600_ODR_1KHZ_LN,
+	INV_ICM42600_ODR_2KHZ_LN,
+	INV_ICM42600_ODR_4KHZ_LN,
+};
+
+static int inv_icm42600_accel_read_odr(struct inv_icm42600_state *st,
+				       int *val, int *val2)
+{
+	unsigned int odr;
+	unsigned int i;
+
+	odr = st->conf.accel.odr;
+
+	for (i = 0; i < ARRAY_SIZE(inv_icm42600_accel_odr_conv); ++i) {
+		if (inv_icm42600_accel_odr_conv[i] == odr)
+			break;
+	}
+	if (i >= ARRAY_SIZE(inv_icm42600_accel_odr_conv))
+		return -EINVAL;
+
+	*val = inv_icm42600_accel_odr[2 * i];
+	*val2 = inv_icm42600_accel_odr[2 * i + 1];
+
+	return IIO_VAL_INT_PLUS_MICRO;
+}
+
+static int inv_icm42600_accel_write_odr(struct iio_dev *indio_dev,
+					int val, int val2)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int idx;
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	int ret;
+
+	for (idx = 0; idx < ARRAY_SIZE(inv_icm42600_accel_odr); idx += 2) {
+		if (val == inv_icm42600_accel_odr[idx] &&
+		    val2 == inv_icm42600_accel_odr[idx + 1])
+			break;
+	}
+	if (idx >= ARRAY_SIZE(inv_icm42600_accel_odr))
+		return -EINVAL;
+
+	conf.odr = inv_icm42600_accel_odr_conv[idx / 2];
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_timestamp_update_odr(ts, inv_icm42600_odr_to_period(conf.odr),
+						iio_buffer_enabled(indio_dev));
+	if (ret)
+		goto out_unlock;
+
+	ret = inv_icm42600_set_accel_conf(st, &conf, NULL);
+	if (ret)
+		goto out_unlock;
+	inv_icm42600_buffer_update_fifo_period(st);
+	inv_icm42600_buffer_update_watermark(st);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+/*
+ * Calibration bias values, IIO range format int + micro.
+ * Value is limited to +/-1g coded on 12 bits signed. Step is 0.5mg.
+ */
+static int inv_icm42600_accel_calibbias[] = {
+	-10, 42010,		/* min: -10.042010 m/s² */
+	0, 4903,		/* step: 0.004903 m/s² */
+	10, 37106,		/* max: 10.037106 m/s² */
+};
+
+static int inv_icm42600_accel_read_offset(struct inv_icm42600_state *st,
+					  struct iio_chan_spec const *chan,
+					  int *val, int *val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	int64_t val64;
+	int32_t bias;
+	unsigned int reg;
+	int16_t offset;
+	uint8_t data[2];
+	int ret;
+
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_OFFSET_USER4;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_OFFSET_USER6;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_OFFSET_USER7;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = regmap_bulk_read(st->map, reg, st->buffer, sizeof(data));
+	memcpy(data, st->buffer, sizeof(data));
+
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	if (ret)
+		return ret;
+
+	/* 12 bits signed value */
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		offset = sign_extend32(((data[0] & 0xF0) << 4) | data[1], 11);
+		break;
+	case IIO_MOD_Y:
+		offset = sign_extend32(((data[1] & 0x0F) << 8) | data[0], 11);
+		break;
+	case IIO_MOD_Z:
+		offset = sign_extend32(((data[0] & 0xF0) << 4) | data[1], 11);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+	 * convert raw offset to g then to m/s²
+	 * 12 bits signed raw step 0.5mg to g: 5 / 10000
+	 * g to m/s²: 9.806650
+	 * result in micro (1000000)
+	 * (offset * 5 * 9.806650 * 1000000) / 10000
+	 */
+	val64 = (int64_t)offset * 5LL * 9806650LL;
+	/* for rounding, add + or - divisor (10000) divided by 2 */
+	if (val64 >= 0)
+		val64 += 10000LL / 2LL;
+	else
+		val64 -= 10000LL / 2LL;
+	bias = div_s64(val64, 10000L);
+	*val = bias / 1000000L;
+	*val2 = bias % 1000000L;
+
+	return IIO_VAL_INT_PLUS_MICRO;
+}
+
+static int inv_icm42600_accel_write_offset(struct inv_icm42600_state *st,
+					   struct iio_chan_spec const *chan,
+					   int val, int val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	int64_t val64;
+	int32_t min, max;
+	unsigned int reg, regval;
+	int16_t offset;
+	int ret;
+
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_OFFSET_USER4;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_OFFSET_USER6;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_OFFSET_USER7;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* inv_icm42600_accel_calibbias: min - step - max in micro */
+	min = inv_icm42600_accel_calibbias[0] * 1000000L +
+	      inv_icm42600_accel_calibbias[1];
+	max = inv_icm42600_accel_calibbias[4] * 1000000L +
+	      inv_icm42600_accel_calibbias[5];
+	val64 = (int64_t)val * 1000000LL + (int64_t)val2;
+	if (val64 < min || val64 > max)
+		return -EINVAL;
+
+	/*
+	 * convert m/s² to g then to raw value
+	 * m/s² to g: 1 / 9.806650
+	 * g to raw 12 bits signed, step 0.5mg: 10000 / 5
+	 * val in micro (1000000)
+	 * val * 10000 / (9.806650 * 1000000 * 5)
+	 */
+	val64 = val64 * 10000LL;
+	/* for rounding, add + or - divisor (9806650 * 5) divided by 2 */
+	if (val64 >= 0)
+		val64 += 9806650 * 5 / 2;
+	else
+		val64 -= 9806650 * 5 / 2;
+	offset = div_s64(val64, 9806650 * 5);
+
+	/* clamp value limited to 12 bits signed */
+	if (offset < -2048)
+		offset = -2048;
+	else if (offset > 2047)
+		offset = 2047;
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		/* OFFSET_USER4 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER4,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = ((offset & 0xF00) >> 4) | (regval & 0x0F);
+		st->buffer[1] = offset & 0xFF;
+		break;
+	case IIO_MOD_Y:
+		/* OFFSET_USER7 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER7,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = offset & 0xFF;
+		st->buffer[1] = ((offset & 0xF00) >> 8) | (regval & 0xF0);
+		break;
+	case IIO_MOD_Z:
+		/* OFFSET_USER7 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER7,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = ((offset & 0xF00) >> 4) | (regval & 0x0F);
+		st->buffer[1] = offset & 0xFF;
+		break;
+	default:
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	ret = regmap_bulk_write(st->map, reg, st->buffer, 2);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	return ret;
+}
+
+static int inv_icm42600_accel_read_raw(struct iio_dev *indio_dev,
+				       struct iio_chan_spec const *chan,
+				       int *val, int *val2, long mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int16_t data;
+	int ret;
+
+	switch (chan->type) {
+	case IIO_ACCEL:
+		break;
+	case IIO_TEMP:
+		return inv_icm42600_temp_read_raw(indio_dev, chan, val, val2, mask);
+	default:
+		return -EINVAL;
+	}
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_accel_read_sensor(st, chan, &data);
+		iio_device_release_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		*val = data;
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		return inv_icm42600_accel_read_scale(st, val, val2);
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return inv_icm42600_accel_read_odr(st, val, val2);
+	case IIO_CHAN_INFO_CALIBBIAS:
+		return inv_icm42600_accel_read_offset(st, chan, val, val2);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_accel_read_avail(struct iio_dev *indio_dev,
+					 struct iio_chan_spec const *chan,
+					 const int **vals,
+					 int *type, int *length, long mask)
+{
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		*vals = inv_icm42600_accel_scale;
+		*type = IIO_VAL_INT_PLUS_NANO;
+		*length = ARRAY_SIZE(inv_icm42600_accel_scale);
+		return IIO_AVAIL_LIST;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*vals = inv_icm42600_accel_odr;
+		*type = IIO_VAL_INT_PLUS_MICRO;
+		*length = ARRAY_SIZE(inv_icm42600_accel_odr);
+		return IIO_AVAIL_LIST;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		*vals = inv_icm42600_accel_calibbias;
+		*type = IIO_VAL_INT_PLUS_MICRO;
+		return IIO_AVAIL_RANGE;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_accel_write_raw(struct iio_dev *indio_dev,
+					struct iio_chan_spec const *chan,
+					int val, int val2, long mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_accel_write_scale(st, val, val2);
+		iio_device_release_direct_mode(indio_dev);
+		return ret;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return inv_icm42600_accel_write_odr(indio_dev, val, val2);
+	case IIO_CHAN_INFO_CALIBBIAS:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_accel_write_offset(st, chan, val, val2);
+		iio_device_release_direct_mode(indio_dev);
+		return ret;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_accel_write_raw_get_fmt(struct iio_dev *indio_dev,
+						struct iio_chan_spec const *chan,
+						long mask)
+{
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		return IIO_VAL_INT_PLUS_NANO;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		return IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_accel_hwfifo_set_watermark(struct iio_dev *indio_dev,
+						   unsigned int val)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	st->fifo.watermark.accel = val;
+	ret = inv_icm42600_buffer_update_watermark(st);
+
+	mutex_unlock(&st->lock);
+
+	return ret;
+}
+
+static int inv_icm42600_accel_hwfifo_flush(struct iio_dev *indio_dev,
+					   unsigned int count)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	if (count == 0)
+		return 0;
+
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_buffer_hwfifo_flush(st, count);
+	if (!ret)
+		ret = st->fifo.nb.accel;
+
+	mutex_unlock(&st->lock);
+
+	return ret;
+}
+
+static const struct iio_info inv_icm42600_accel_info = {
+	.read_raw = inv_icm42600_accel_read_raw,
+	.read_avail = inv_icm42600_accel_read_avail,
+	.write_raw = inv_icm42600_accel_write_raw,
+	.write_raw_get_fmt = inv_icm42600_accel_write_raw_get_fmt,
+	.debugfs_reg_access = inv_icm42600_debugfs_reg,
+	.update_scan_mode = inv_icm42600_accel_update_scan_mode,
+	.hwfifo_set_watermark = inv_icm42600_accel_hwfifo_set_watermark,
+	.hwfifo_flush_to_buffer = inv_icm42600_accel_hwfifo_flush,
+};
+
+struct iio_dev *inv_icm42600_accel_init(struct inv_icm42600_state *st)
+{
+	struct device *dev = regmap_get_device(st->map);
+	const char *name;
+	struct inv_icm42600_timestamp *ts;
+	struct iio_dev *indio_dev;
+	int ret;
+
+	name = devm_kasprintf(dev, GFP_KERNEL, "%s-accel", st->name);
+	if (!name)
+		return ERR_PTR(-ENOMEM);
+
+	indio_dev = devm_iio_device_alloc(dev, sizeof(*ts));
+	if (!indio_dev)
+		return ERR_PTR(-ENOMEM);
+
+	ts = iio_priv(indio_dev);
+	inv_icm42600_timestamp_init(ts, inv_icm42600_odr_to_period(st->conf.accel.odr));
+
+	iio_device_set_drvdata(indio_dev, st);
+	indio_dev->name = name;
+	indio_dev->info = &inv_icm42600_accel_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = inv_icm42600_accel_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_icm42600_accel_channels);
+	indio_dev->available_scan_masks = inv_icm42600_accel_scan_masks;
+
+// FIXME! ACHEUL
+#if 0	
+	ret = devm_iio_kfifo_buffer_setup(dev, indio_dev,
+					  INDIO_BUFFER_SOFTWARE,
+					  &inv_icm42600_buffer_ops);
+	if (ret)
+		return ERR_PTR(ret);
+
+#endif // 0
+	ret = devm_iio_device_register(dev, indio_dev);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return indio_dev;
+}
+
+int inv_icm42600_accel_parse_fifo(struct iio_dev *indio_dev)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	ssize_t i, size;
+	unsigned int no;
+	const void *accel, *gyro, *timestamp;
+	const int8_t *temp;
+	unsigned int odr;
+	int64_t ts_val;
+	struct inv_icm42600_accel_buffer buffer;
+
+	/* parse all fifo packets */
+	for (i = 0, no = 0; i < st->fifo.count; i += size, ++no) {
+		size = inv_icm42600_fifo_decode_packet(&st->fifo.data[i],
+				&accel, &gyro, &temp, &timestamp, &odr);
+		/* quit if error or FIFO is empty */
+		if (size <= 0)
+			return size;
+
+		/* skip packet if no accel data or data is invalid */
+		if (accel == NULL || !inv_icm42600_fifo_is_data_valid(accel))
+			continue;
+
+		/* update odr */
+		if (odr & INV_ICM42600_SENSOR_ACCEL)
+			inv_icm42600_timestamp_apply_odr(ts, st->fifo.period,
+							 st->fifo.nb.total, no);
+
+		/* buffer is copied to userspace, zeroing it to avoid any data leak */
+		memset(&buffer, 0, sizeof(buffer));
+		memcpy(&buffer.accel, accel, sizeof(buffer.accel));
+		/* convert 8 bits FIFO temperature in high resolution format */
+		buffer.temp = temp ? (*temp * 64) : 0;
+		ts_val = inv_icm42600_timestamp_pop(ts);
+		iio_push_to_buffers_with_timestamp(indio_dev, &buffer, ts_val);
+	}
+
+	return 0;
+}
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_buffer.c msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_buffer.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_buffer.c	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_buffer.c	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,601 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+
+#include "inv_icm42600.h"
+#include "inv_icm42600_timestamp.h"
+#include "inv_icm42600_buffer.h"
+
+/* FIFO header: 1 byte */
+#define INV_ICM42600_FIFO_HEADER_MSG		BIT(7)
+#define INV_ICM42600_FIFO_HEADER_ACCEL		BIT(6)
+#define INV_ICM42600_FIFO_HEADER_GYRO		BIT(5)
+#define INV_ICM42600_FIFO_HEADER_TMST_FSYNC	GENMASK(3, 2)
+#define INV_ICM42600_FIFO_HEADER_ODR_ACCEL	BIT(1)
+#define INV_ICM42600_FIFO_HEADER_ODR_GYRO	BIT(0)
+
+struct inv_icm42600_fifo_1sensor_packet {
+	uint8_t header;
+	struct inv_icm42600_fifo_sensor_data data;
+	int8_t temp;
+} __packed;
+#define INV_ICM42600_FIFO_1SENSOR_PACKET_SIZE		8
+
+struct inv_icm42600_fifo_2sensors_packet {
+	uint8_t header;
+	struct inv_icm42600_fifo_sensor_data accel;
+	struct inv_icm42600_fifo_sensor_data gyro;
+	int8_t temp;
+	__be16 timestamp;
+} __packed;
+#define INV_ICM42600_FIFO_2SENSORS_PACKET_SIZE		16
+
+ssize_t inv_icm42600_fifo_decode_packet(const void *packet, const void **accel,
+					const void **gyro, const int8_t **temp,
+					const void **timestamp, unsigned int *odr)
+{
+	const struct inv_icm42600_fifo_1sensor_packet *pack1 = packet;
+	const struct inv_icm42600_fifo_2sensors_packet *pack2 = packet;
+	uint8_t header = *((const uint8_t *)packet);
+
+	/* FIFO empty */
+	if (header & INV_ICM42600_FIFO_HEADER_MSG) {
+		*accel = NULL;
+		*gyro = NULL;
+		*temp = NULL;
+		*timestamp = NULL;
+		*odr = 0;
+		return 0;
+	}
+
+	/* handle odr flags */
+	*odr = 0;
+	if (header & INV_ICM42600_FIFO_HEADER_ODR_GYRO)
+		*odr |= INV_ICM42600_SENSOR_GYRO;
+	if (header & INV_ICM42600_FIFO_HEADER_ODR_ACCEL)
+		*odr |= INV_ICM42600_SENSOR_ACCEL;
+
+	/* accel + gyro */
+	if ((header & INV_ICM42600_FIFO_HEADER_ACCEL) &&
+	    (header & INV_ICM42600_FIFO_HEADER_GYRO)) {
+		*accel = &pack2->accel;
+		*gyro = &pack2->gyro;
+		*temp = &pack2->temp;
+		*timestamp = &pack2->timestamp;
+		return INV_ICM42600_FIFO_2SENSORS_PACKET_SIZE;
+	}
+
+	/* accel only */
+	if (header & INV_ICM42600_FIFO_HEADER_ACCEL) {
+		*accel = &pack1->data;
+		*gyro = NULL;
+		*temp = &pack1->temp;
+		*timestamp = NULL;
+		return INV_ICM42600_FIFO_1SENSOR_PACKET_SIZE;
+	}
+
+	/* gyro only */
+	if (header & INV_ICM42600_FIFO_HEADER_GYRO) {
+		*accel = NULL;
+		*gyro = &pack1->data;
+		*temp = &pack1->temp;
+		*timestamp = NULL;
+		return INV_ICM42600_FIFO_1SENSOR_PACKET_SIZE;
+	}
+
+	/* invalid packet if here */
+	return -EINVAL;
+}
+
+void inv_icm42600_buffer_update_fifo_period(struct inv_icm42600_state *st)
+{
+	uint32_t period_gyro, period_accel, period;
+
+	if (st->fifo.en & INV_ICM42600_SENSOR_GYRO)
+		period_gyro = inv_icm42600_odr_to_period(st->conf.gyro.odr);
+	else
+		period_gyro = U32_MAX;
+
+	if (st->fifo.en & INV_ICM42600_SENSOR_ACCEL)
+		period_accel = inv_icm42600_odr_to_period(st->conf.accel.odr);
+	else
+		period_accel = U32_MAX;
+
+	if (period_gyro <= period_accel)
+		period = period_gyro;
+	else
+		period = period_accel;
+
+	st->fifo.period = period;
+}
+
+int inv_icm42600_buffer_set_fifo_en(struct inv_icm42600_state *st,
+				    unsigned int fifo_en)
+{
+	unsigned int mask, val;
+	int ret;
+
+	/* update only FIFO EN bits */
+	mask = INV_ICM42600_FIFO_CONFIG1_TMST_FSYNC_EN |
+		INV_ICM42600_FIFO_CONFIG1_TEMP_EN |
+		INV_ICM42600_FIFO_CONFIG1_GYRO_EN |
+		INV_ICM42600_FIFO_CONFIG1_ACCEL_EN;
+
+	val = 0;
+	if (fifo_en & INV_ICM42600_SENSOR_GYRO)
+		val |= INV_ICM42600_FIFO_CONFIG1_GYRO_EN;
+	if (fifo_en & INV_ICM42600_SENSOR_ACCEL)
+		val |= INV_ICM42600_FIFO_CONFIG1_ACCEL_EN;
+	if (fifo_en & INV_ICM42600_SENSOR_TEMP)
+		val |= INV_ICM42600_FIFO_CONFIG1_TEMP_EN;
+
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_FIFO_CONFIG1, mask, val);
+	if (ret)
+		return ret;
+
+	st->fifo.en = fifo_en;
+	inv_icm42600_buffer_update_fifo_period(st);
+
+	return 0;
+}
+
+static size_t inv_icm42600_get_packet_size(unsigned int fifo_en)
+{
+	size_t packet_size;
+
+	if ((fifo_en & INV_ICM42600_SENSOR_GYRO) &&
+	    (fifo_en & INV_ICM42600_SENSOR_ACCEL))
+		packet_size = INV_ICM42600_FIFO_2SENSORS_PACKET_SIZE;
+	else
+		packet_size = INV_ICM42600_FIFO_1SENSOR_PACKET_SIZE;
+
+	return packet_size;
+}
+
+static unsigned int inv_icm42600_wm_truncate(unsigned int watermark,
+					     size_t packet_size)
+{
+	size_t wm_size;
+	unsigned int wm;
+
+	wm_size = watermark * packet_size;
+	if (wm_size > INV_ICM42600_FIFO_WATERMARK_MAX)
+		wm_size = INV_ICM42600_FIFO_WATERMARK_MAX;
+
+	wm = wm_size / packet_size;
+
+	return wm;
+}
+
+/**
+ * inv_icm42600_buffer_update_watermark - update watermark FIFO threshold
+ * @st:	driver internal state
+ *
+ * Returns 0 on success, a negative error code otherwise.
+ *
+ * FIFO watermark threshold is computed based on the required watermark values
+ * set for gyro and accel sensors. Since watermark is all about acceptable data
+ * latency, use the smallest setting between the 2. It means choosing the
+ * smallest latency but this is not as simple as choosing the smallest watermark
+ * value. Latency depends on watermark and ODR. It requires several steps:
+ * 1) compute gyro and accel latencies and choose the smallest value.
+ * 2) adapt the choosen latency so that it is a multiple of both gyro and accel
+ *    ones. Otherwise it is possible that you don't meet a requirement. (for
+ *    example with gyro @100Hz wm 4 and accel @100Hz with wm 6, choosing the
+ *    value of 4 will not meet accel latency requirement because 6 is not a
+ *    multiple of 4. You need to use the value 2.)
+ * 3) Since all periods are multiple of each others, watermark is computed by
+ *    dividing this computed latency by the smallest period, which corresponds
+ *    to the FIFO frequency. Beware that this is only true because we are not
+ *    using 500Hz frequency which is not a multiple of the others.
+ */
+int inv_icm42600_buffer_update_watermark(struct inv_icm42600_state *st)
+{
+	size_t packet_size, wm_size;
+	unsigned int wm_gyro, wm_accel, watermark;
+	uint32_t period_gyro, period_accel, period;
+	uint32_t latency_gyro, latency_accel, latency;
+	bool restore;
+	__le16 raw_wm;
+	int ret;
+
+	packet_size = inv_icm42600_get_packet_size(st->fifo.en);
+
+	/* compute sensors latency, depending on sensor watermark and odr */
+	wm_gyro = inv_icm42600_wm_truncate(st->fifo.watermark.gyro, packet_size);
+	wm_accel = inv_icm42600_wm_truncate(st->fifo.watermark.accel, packet_size);
+	/* use us for odr to avoid overflow using 32 bits values */
+	period_gyro = inv_icm42600_odr_to_period(st->conf.gyro.odr) / 1000UL;
+	period_accel = inv_icm42600_odr_to_period(st->conf.accel.odr) / 1000UL;
+	latency_gyro = period_gyro * wm_gyro;
+	latency_accel = period_accel * wm_accel;
+
+	/* 0 value for watermark means that the sensor is turned off */
+	if (latency_gyro == 0) {
+		watermark = wm_accel;
+	} else if (latency_accel == 0) {
+		watermark = wm_gyro;
+	} else {
+		/* compute the smallest latency that is a multiple of both */
+		if (latency_gyro <= latency_accel)
+			latency = latency_gyro - (latency_accel % latency_gyro);
+		else
+			latency = latency_accel - (latency_gyro % latency_accel);
+		/* use the shortest period */
+		if (period_gyro <= period_accel)
+			period = period_gyro;
+		else
+			period = period_accel;
+		/* all this works because periods are multiple of each others */
+		watermark = latency / period;
+		if (watermark < 1)
+			watermark = 1;
+	}
+
+	/* compute watermark value in bytes */
+	wm_size = watermark * packet_size;
+
+	/* changing FIFO watermark requires to turn off watermark interrupt */
+	ret = regmap_update_bits_check(st->map, INV_ICM42600_REG_INT_SOURCE0,
+				       INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN,
+				       0, &restore);
+	if (ret)
+		return ret;
+
+	raw_wm = INV_ICM42600_FIFO_WATERMARK_VAL(wm_size);
+	memcpy(st->buffer, &raw_wm, sizeof(raw_wm));
+	ret = regmap_bulk_write(st->map, INV_ICM42600_REG_FIFO_WATERMARK,
+				st->buffer, sizeof(raw_wm));
+	if (ret)
+		return ret;
+
+	/* restore watermark interrupt */
+	if (restore) {
+		ret = regmap_update_bits(st->map, INV_ICM42600_REG_INT_SOURCE0,
+					 INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN,
+					 INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int inv_icm42600_buffer_preenable(struct iio_dev *indio_dev)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct device *dev = regmap_get_device(st->map);
+
+	pm_runtime_get_sync(dev);
+
+	return 0;
+}
+
+/*
+ * update_scan_mode callback is turning sensors on and setting data FIFO enable
+ * bits.
+ */
+static int inv_icm42600_buffer_postenable(struct iio_dev *indio_dev)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	/* exit if FIFO is already on */
+	if (st->fifo.on) {
+		ret = 0;
+		goto out_on;
+	}
+
+	/* set FIFO threshold interrupt */
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INT_SOURCE0,
+				 INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN,
+				 INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN);
+	if (ret)
+		goto out_unlock;
+
+	/* flush FIFO data */
+	ret = regmap_write(st->map, INV_ICM42600_REG_SIGNAL_PATH_RESET,
+			   INV_ICM42600_SIGNAL_PATH_RESET_FIFO_FLUSH);
+	if (ret)
+		goto out_unlock;
+
+	/* set FIFO in streaming mode */
+	ret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,
+			   INV_ICM42600_FIFO_CONFIG_STREAM);
+	if (ret)
+		goto out_unlock;
+
+	/* workaround: first read of FIFO count after reset is always 0 */
+	ret = regmap_bulk_read(st->map, INV_ICM42600_REG_FIFO_COUNT, st->buffer, 2);
+	if (ret)
+		goto out_unlock;
+
+out_on:
+	/* increase FIFO on counter */
+	st->fifo.on++;
+out_unlock:
+	mutex_unlock(&st->lock);
+	return ret;
+}
+
+static int inv_icm42600_buffer_predisable(struct iio_dev *indio_dev)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	/* exit if there are several sensors using the FIFO */
+	if (st->fifo.on > 1) {
+		ret = 0;
+		goto out_off;
+	}
+
+	/* set FIFO in bypass mode */
+	ret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,
+			   INV_ICM42600_FIFO_CONFIG_BYPASS);
+	if (ret)
+		goto out_unlock;
+
+	/* flush FIFO data */
+	ret = regmap_write(st->map, INV_ICM42600_REG_SIGNAL_PATH_RESET,
+			   INV_ICM42600_SIGNAL_PATH_RESET_FIFO_FLUSH);
+	if (ret)
+		goto out_unlock;
+
+	/* disable FIFO threshold interrupt */
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INT_SOURCE0,
+				 INV_ICM42600_INT_SOURCE0_FIFO_THS_INT1_EN, 0);
+	if (ret)
+		goto out_unlock;
+
+out_off:
+	/* decrease FIFO on counter */
+	st->fifo.on--;
+out_unlock:
+	mutex_unlock(&st->lock);
+	return ret;
+}
+
+static int inv_icm42600_buffer_postdisable(struct iio_dev *indio_dev)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int sensor;
+	unsigned int *watermark;
+	struct inv_icm42600_timestamp *ts;
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	unsigned int sleep_temp = 0;
+	unsigned int sleep_sensor = 0;
+	unsigned int sleep;
+	int ret;
+
+	if (indio_dev == st->indio_gyro) {
+		sensor = INV_ICM42600_SENSOR_GYRO;
+		watermark = &st->fifo.watermark.gyro;
+		ts = iio_priv(st->indio_gyro);
+	} else if (indio_dev == st->indio_accel) {
+		sensor = INV_ICM42600_SENSOR_ACCEL;
+		watermark = &st->fifo.watermark.accel;
+		ts = iio_priv(st->indio_accel);
+	} else {
+		return -EINVAL;
+	}
+
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_buffer_set_fifo_en(st, st->fifo.en & ~sensor);
+	if (ret)
+		goto out_unlock;
+
+	*watermark = 0;
+	ret = inv_icm42600_buffer_update_watermark(st);
+	if (ret)
+		goto out_unlock;
+
+	conf.mode = INV_ICM42600_SENSOR_MODE_OFF;
+	if (sensor == INV_ICM42600_SENSOR_GYRO)
+		ret = inv_icm42600_set_gyro_conf(st, &conf, &sleep_sensor);
+	else
+		ret = inv_icm42600_set_accel_conf(st, &conf, &sleep_sensor);
+	if (ret)
+		goto out_unlock;
+
+	/* if FIFO is off, turn temperature off */
+	if (!st->fifo.on)
+		ret = inv_icm42600_set_temp_conf(st, false, &sleep_temp);
+
+	inv_icm42600_timestamp_reset(ts);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+
+	/* sleep maximum required time */
+	if (sleep_sensor > sleep_temp)
+		sleep = sleep_sensor;
+	else
+		sleep = sleep_temp;
+	if (sleep)
+		msleep(sleep);
+
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+const struct iio_buffer_setup_ops inv_icm42600_buffer_ops = {
+	.preenable = inv_icm42600_buffer_preenable,
+	.postenable = inv_icm42600_buffer_postenable,
+	.predisable = inv_icm42600_buffer_predisable,
+	.postdisable = inv_icm42600_buffer_postdisable,
+};
+
+int inv_icm42600_buffer_fifo_read(struct inv_icm42600_state *st,
+				  unsigned int max)
+{
+	size_t max_count;
+	__be16 *raw_fifo_count;
+	ssize_t i, size;
+	const void *accel, *gyro, *timestamp;
+	const int8_t *temp;
+	unsigned int odr;
+	int ret;
+
+	/* reset all samples counters */
+	st->fifo.count = 0;
+	st->fifo.nb.gyro = 0;
+	st->fifo.nb.accel = 0;
+	st->fifo.nb.total = 0;
+
+	/* compute maximum FIFO read size */
+	if (max == 0)
+		max_count = sizeof(st->fifo.data);
+	else
+		max_count = max * inv_icm42600_get_packet_size(st->fifo.en);
+
+	/* read FIFO count value */
+	raw_fifo_count = (__be16 *)st->buffer;
+	ret = regmap_bulk_read(st->map, INV_ICM42600_REG_FIFO_COUNT,
+			       raw_fifo_count, sizeof(*raw_fifo_count));
+	if (ret)
+		return ret;
+	st->fifo.count = be16_to_cpup(raw_fifo_count);
+
+	/* check and clamp FIFO count value */
+	if (st->fifo.count == 0)
+		return 0;
+	if (st->fifo.count > max_count)
+		st->fifo.count = max_count;
+
+	/* read all FIFO data in internal buffer */
+	ret = regmap_noinc_read(st->map, INV_ICM42600_REG_FIFO_DATA,
+				st->fifo.data, st->fifo.count);
+	if (ret)
+		return ret;
+
+	/* compute number of samples for each sensor */
+	for (i = 0; i < st->fifo.count; i += size) {
+		size = inv_icm42600_fifo_decode_packet(&st->fifo.data[i],
+				&accel, &gyro, &temp, &timestamp, &odr);
+		if (size <= 0)
+			break;
+		if (gyro != NULL && inv_icm42600_fifo_is_data_valid(gyro))
+			st->fifo.nb.gyro++;
+		if (accel != NULL && inv_icm42600_fifo_is_data_valid(accel))
+			st->fifo.nb.accel++;
+		st->fifo.nb.total++;
+	}
+
+	return 0;
+}
+
+int inv_icm42600_buffer_fifo_parse(struct inv_icm42600_state *st)
+{
+	struct inv_icm42600_timestamp *ts;
+	int ret;
+
+	if (st->fifo.nb.total == 0)
+		return 0;
+
+	/* handle gyroscope timestamp and FIFO data parsing */
+	ts = iio_priv(st->indio_gyro);
+	inv_icm42600_timestamp_interrupt(ts, st->fifo.period, st->fifo.nb.total,
+					 st->fifo.nb.gyro, st->timestamp.gyro);
+	if (st->fifo.nb.gyro > 0) {
+		ret = inv_icm42600_gyro_parse_fifo(st->indio_gyro);
+		if (ret)
+			return ret;
+	}
+
+	/* handle accelerometer timestamp and FIFO data parsing */
+	ts = iio_priv(st->indio_accel);
+	inv_icm42600_timestamp_interrupt(ts, st->fifo.period, st->fifo.nb.total,
+					 st->fifo.nb.accel, st->timestamp.accel);
+	if (st->fifo.nb.accel > 0) {
+		ret = inv_icm42600_accel_parse_fifo(st->indio_accel);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int inv_icm42600_buffer_hwfifo_flush(struct inv_icm42600_state *st,
+				     unsigned int count)
+{
+	struct inv_icm42600_timestamp *ts;
+	int64_t gyro_ts, accel_ts;
+	int ret;
+
+	gyro_ts = iio_get_time_ns(st->indio_gyro);
+	accel_ts = iio_get_time_ns(st->indio_accel);
+
+	ret = inv_icm42600_buffer_fifo_read(st, count);
+	if (ret)
+		return ret;
+
+	if (st->fifo.nb.total == 0)
+		return 0;
+
+	if (st->fifo.nb.gyro > 0) {
+		ts = iio_priv(st->indio_gyro);
+		inv_icm42600_timestamp_interrupt(ts, st->fifo.period,
+						 st->fifo.nb.total, st->fifo.nb.gyro,
+						 gyro_ts);
+		ret = inv_icm42600_gyro_parse_fifo(st->indio_gyro);
+		if (ret)
+			return ret;
+	}
+
+	if (st->fifo.nb.accel > 0) {
+		ts = iio_priv(st->indio_accel);
+		inv_icm42600_timestamp_interrupt(ts, st->fifo.period,
+						 st->fifo.nb.total, st->fifo.nb.accel,
+						 accel_ts);
+		ret = inv_icm42600_accel_parse_fifo(st->indio_accel);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int inv_icm42600_buffer_init(struct inv_icm42600_state *st)
+{
+	unsigned int val;
+	int ret;
+
+	/*
+	 * Default FIFO configuration (bits 7 to 5)
+	 * - use invalid value
+	 * - FIFO count in bytes
+	 * - FIFO count in big endian
+	 */
+	val = INV_ICM42600_INTF_CONFIG0_FIFO_COUNT_ENDIAN;
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG0,
+				 GENMASK(7, 5), val);
+	if (ret)
+		return ret;
+
+	/*
+	 * Enable FIFO partial read and continuous watermark interrupt.
+	 * Disable all FIFO EN bits.
+	 */
+	val = INV_ICM42600_FIFO_CONFIG1_RESUME_PARTIAL_RD |
+	      INV_ICM42600_FIFO_CONFIG1_WM_GT_TH;
+	return regmap_update_bits(st->map, INV_ICM42600_REG_FIFO_CONFIG1,
+				  GENMASK(6, 5) | GENMASK(3, 0), val);
+}
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_buffer.h msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_buffer.h
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_buffer.h	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_buffer.h	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#ifndef INV_ICM42600_BUFFER_H_
+#define INV_ICM42600_BUFFER_H_
+
+#include <linux/kernel.h>
+#include <linux/bits.h>
+
+struct inv_icm42600_state;
+
+#define INV_ICM42600_SENSOR_GYRO	BIT(0)
+#define INV_ICM42600_SENSOR_ACCEL	BIT(1)
+#define INV_ICM42600_SENSOR_TEMP	BIT(2)
+
+/**
+ * struct inv_icm42600_fifo - FIFO state variables
+ * @on:		reference counter for FIFO on.
+ * @en:		bits field of INV_ICM42600_SENSOR_* for FIFO EN bits.
+ * @period:	FIFO internal period.
+ * @watermark:	watermark configuration values for accel and gyro.
+ * @count:	number of bytes in the FIFO data buffer.
+ * @nb:		gyro, accel and total samples in the FIFO data buffer.
+ * @data:	FIFO data buffer aligned for DMA (2kB + 32 bytes of read cache).
+ */
+struct inv_icm42600_fifo {
+	unsigned int on;
+	unsigned int en;
+	uint32_t period;
+	struct {
+		unsigned int gyro;
+		unsigned int accel;
+	} watermark;
+	size_t count;
+	struct {
+		size_t gyro;
+		size_t accel;
+		size_t total;
+	} nb;
+	uint8_t data[2080] ____cacheline_aligned;
+};
+
+/* FIFO data packet */
+struct inv_icm42600_fifo_sensor_data {
+	__be16 x;
+	__be16 y;
+	__be16 z;
+} __packed;
+#define INV_ICM42600_FIFO_DATA_INVALID		-32768
+
+static inline int16_t inv_icm42600_fifo_get_sensor_data(__be16 d)
+{
+	return be16_to_cpu(d);
+}
+
+static inline bool
+inv_icm42600_fifo_is_data_valid(const struct inv_icm42600_fifo_sensor_data *s)
+{
+	int16_t x, y, z;
+
+	x = inv_icm42600_fifo_get_sensor_data(s->x);
+	y = inv_icm42600_fifo_get_sensor_data(s->y);
+	z = inv_icm42600_fifo_get_sensor_data(s->z);
+
+	if (x == INV_ICM42600_FIFO_DATA_INVALID &&
+	    y == INV_ICM42600_FIFO_DATA_INVALID &&
+	    z == INV_ICM42600_FIFO_DATA_INVALID)
+		return false;
+
+	return true;
+}
+
+ssize_t inv_icm42600_fifo_decode_packet(const void *packet, const void **accel,
+					const void **gyro, const int8_t **temp,
+					const void **timestamp, unsigned int *odr);
+
+extern const struct iio_buffer_setup_ops inv_icm42600_buffer_ops;
+
+int inv_icm42600_buffer_init(struct inv_icm42600_state *st);
+
+void inv_icm42600_buffer_update_fifo_period(struct inv_icm42600_state *st);
+
+int inv_icm42600_buffer_set_fifo_en(struct inv_icm42600_state *st,
+				    unsigned int fifo_en);
+
+int inv_icm42600_buffer_update_watermark(struct inv_icm42600_state *st);
+
+int inv_icm42600_buffer_fifo_read(struct inv_icm42600_state *st,
+				  unsigned int max);
+
+int inv_icm42600_buffer_fifo_parse(struct inv_icm42600_state *st);
+
+int inv_icm42600_buffer_hwfifo_flush(struct inv_icm42600_state *st,
+				     unsigned int count);
+
+#endif
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,904 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pm_runtime.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include <linux/iio/iio.h>
+
+#include "inv_icm42600.h"
+#include "inv_icm42600_buffer.h"
+#include "inv_icm42600_timestamp.h"
+
+#define USE_VDD 0
+
+static const struct regmap_range_cfg inv_icm42600_regmap_ranges[] = {
+	{
+		.name = "user banks",
+		.range_min = 0x0000,
+		.range_max = 0x4FFF,
+		.selector_reg = INV_ICM42600_REG_BANK_SEL,
+		.selector_mask = INV_ICM42600_BANK_SEL_MASK,
+		.selector_shift = 0,
+		.window_start = 0,
+		.window_len = 0x1000,
+	},
+};
+
+const struct regmap_config inv_icm42600_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0x4FFF,
+	.ranges = inv_icm42600_regmap_ranges,
+	.num_ranges = ARRAY_SIZE(inv_icm42600_regmap_ranges),
+};
+EXPORT_SYMBOL_GPL(inv_icm42600_regmap_config);
+
+struct inv_icm42600_hw {
+	uint8_t whoami;
+	const char *name;
+	const struct inv_icm42600_conf *conf;
+};
+
+/* chip initial default configuration */
+static const struct inv_icm42600_conf inv_icm42600_default_conf = {
+	.gyro = {
+		.mode = INV_ICM42600_SENSOR_MODE_OFF,
+		.fs = INV_ICM42600_GYRO_FS_2000DPS,
+		.odr = INV_ICM42600_ODR_50HZ,
+		.filter = INV_ICM42600_FILTER_BW_ODR_DIV_2,
+	},
+	.accel = {
+		.mode = INV_ICM42600_SENSOR_MODE_OFF,
+		.fs = INV_ICM42600_ACCEL_FS_16G,
+		.odr = INV_ICM42600_ODR_50HZ,
+		.filter = INV_ICM42600_FILTER_BW_ODR_DIV_2,
+	},
+	.temp_en = false,
+};
+
+static const struct inv_icm42600_hw inv_icm42600_hw[INV_CHIP_NB] = {
+	[INV_CHIP_ICM42600] = {
+		.whoami = INV_ICM42600_WHOAMI_ICM42600,
+		.name = "icm42600",
+		.conf = &inv_icm42600_default_conf,
+	},
+	[INV_CHIP_ICM42602] = {
+		.whoami = INV_ICM42600_WHOAMI_ICM42602,
+		.name = "icm42602",
+		.conf = &inv_icm42600_default_conf,
+	},
+	[INV_CHIP_ICM42605] = {
+		.whoami = INV_ICM42600_WHOAMI_ICM42605,
+		.name = "icm42605",
+		.conf = &inv_icm42600_default_conf,
+	},
+	[INV_CHIP_ICM42622] = {
+		.whoami = INV_ICM42600_WHOAMI_ICM42622,
+		.name = "icm42622",
+		.conf = &inv_icm42600_default_conf,
+	},
+};
+
+const struct iio_mount_matrix *
+inv_icm42600_get_mount_matrix(const struct iio_dev *indio_dev,
+			      const struct iio_chan_spec *chan)
+{
+	const struct inv_icm42600_state *st = iio_device_get_drvdata((struct iio_dev *) indio_dev);
+
+	return &st->orientation;
+}
+
+uint32_t inv_icm42600_odr_to_period(enum inv_icm42600_odr odr)
+{
+	static uint32_t odr_periods[INV_ICM42600_ODR_NB] = {
+		/* reserved values */
+		0, 0, 0,
+		/* 8kHz */
+		125000,
+		/* 4kHz */
+		250000,
+		/* 2kHz */
+		500000,
+		/* 1kHz */
+		1000000,
+		/* 200Hz */
+		5000000,
+		/* 100Hz */
+		10000000,
+		/* 50Hz */
+		20000000,
+		/* 25Hz */
+		40000000,
+		/* 12.5Hz */
+		80000000,
+		/* 6.25Hz */
+		160000000,
+		/* 3.125Hz */
+		320000000,
+		/* 1.5625Hz */
+		640000000,
+		/* 500Hz */
+		2000000,
+	};
+
+	return odr_periods[odr];
+}
+
+static int inv_icm42600_set_pwr_mgmt0(struct inv_icm42600_state *st,
+				      enum inv_icm42600_sensor_mode gyro,
+				      enum inv_icm42600_sensor_mode accel,
+				      bool temp, unsigned int *sleep_ms)
+{
+	enum inv_icm42600_sensor_mode oldgyro = st->conf.gyro.mode;
+	enum inv_icm42600_sensor_mode oldaccel = st->conf.accel.mode;
+	bool oldtemp = st->conf.temp_en;
+	unsigned int sleepval;
+	unsigned int val;
+	int ret;
+
+    printk("%s:%d ACHEUL, in", __FUNCTION__, __LINE__);
+
+	/* if nothing changed, exit */
+	if (gyro == oldgyro && accel == oldaccel && temp == oldtemp){
+        printk("%s:%d ACHEUL, out", __FUNCTION__, __LINE__);
+		return 0;
+    }
+
+	val = INV_ICM42600_PWR_MGMT0_GYRO(gyro) |
+	      INV_ICM42600_PWR_MGMT0_ACCEL(accel);
+	if (!temp)
+		val |= INV_ICM42600_PWR_MGMT0_TEMP_DIS;
+	ret = regmap_write(st->map, INV_ICM42600_REG_PWR_MGMT0, val);
+	if (ret)
+		return ret;
+
+	st->conf.gyro.mode = gyro;
+	st->conf.accel.mode = accel;
+	st->conf.temp_en = temp;
+
+	/* compute required wait time for sensors to stabilize */
+	sleepval = 0;
+	/* temperature stabilization time */
+	if (temp && !oldtemp) {
+		if (sleepval < INV_ICM42600_TEMP_STARTUP_TIME_MS)
+			sleepval = INV_ICM42600_TEMP_STARTUP_TIME_MS;
+	}
+	/* accel startup time */
+	if (accel != oldaccel && oldaccel == INV_ICM42600_SENSOR_MODE_OFF) {
+		/* block any register write for at least 200 µs */
+		usleep_range(200, 300);
+		if (sleepval < INV_ICM42600_ACCEL_STARTUP_TIME_MS)
+			sleepval = INV_ICM42600_ACCEL_STARTUP_TIME_MS;
+	}
+	if (gyro != oldgyro) {
+		/* gyro startup time */
+		if (oldgyro == INV_ICM42600_SENSOR_MODE_OFF) {
+			/* block any register write for at least 200 µs */
+			usleep_range(200, 300);
+			if (sleepval < INV_ICM42600_GYRO_STARTUP_TIME_MS)
+				sleepval = INV_ICM42600_GYRO_STARTUP_TIME_MS;
+		/* gyro stop time */
+		} else if (gyro == INV_ICM42600_SENSOR_MODE_OFF) {
+			if (sleepval < INV_ICM42600_GYRO_STOP_TIME_MS)
+				sleepval =  INV_ICM42600_GYRO_STOP_TIME_MS;
+		}
+	}
+
+	/* deferred sleep value if sleep pointer is provided or direct sleep */
+	if (sleep_ms)
+		*sleep_ms = sleepval;
+	else if (sleepval)
+		msleep(sleepval);
+
+    printk("%s:%d ACHEUL, out", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+int inv_icm42600_set_accel_conf(struct inv_icm42600_state *st,
+				struct inv_icm42600_sensor_conf *conf,
+				unsigned int *sleep_ms)
+{
+	struct inv_icm42600_sensor_conf *oldconf = &st->conf.accel;
+	unsigned int val;
+	int ret;
+
+	/* Sanitize missing values with current values */
+	if (conf->mode < 0)
+		conf->mode = oldconf->mode;
+	if (conf->fs < 0)
+		conf->fs = oldconf->fs;
+	if (conf->odr < 0)
+		conf->odr = oldconf->odr;
+	if (conf->filter < 0)
+		conf->filter = oldconf->filter;
+
+	/* set ACCEL_CONFIG0 register (accel fullscale & odr) */
+	if (conf->fs != oldconf->fs || conf->odr != oldconf->odr) {
+		val = INV_ICM42600_ACCEL_CONFIG0_FS(conf->fs) |
+		      INV_ICM42600_ACCEL_CONFIG0_ODR(conf->odr);
+		ret = regmap_write(st->map, INV_ICM42600_REG_ACCEL_CONFIG0, val);
+		if (ret)
+			return ret;
+		oldconf->fs = conf->fs;
+		oldconf->odr = conf->odr;
+	}
+
+	/* set GYRO_ACCEL_CONFIG0 register (accel filter) */
+	if (conf->filter != oldconf->filter) {
+		val = INV_ICM42600_GYRO_ACCEL_CONFIG0_ACCEL_FILT(conf->filter) |
+		      INV_ICM42600_GYRO_ACCEL_CONFIG0_GYRO_FILT(st->conf.gyro.filter);
+		ret = regmap_write(st->map, INV_ICM42600_REG_GYRO_ACCEL_CONFIG0, val);
+		if (ret)
+			return ret;
+		oldconf->filter = conf->filter;
+	}
+
+	/* set PWR_MGMT0 register (accel sensor mode) */
+	return inv_icm42600_set_pwr_mgmt0(st, st->conf.gyro.mode, conf->mode,
+					  st->conf.temp_en, sleep_ms);
+}
+
+int inv_icm42600_set_gyro_conf(struct inv_icm42600_state *st,
+			       struct inv_icm42600_sensor_conf *conf,
+			       unsigned int *sleep_ms)
+{
+	struct inv_icm42600_sensor_conf *oldconf = &st->conf.gyro;
+	unsigned int val;
+	int ret;
+
+	/* sanitize missing values with current values */
+	if (conf->mode < 0)
+		conf->mode = oldconf->mode;
+	if (conf->fs < 0)
+		conf->fs = oldconf->fs;
+	if (conf->odr < 0)
+		conf->odr = oldconf->odr;
+	if (conf->filter < 0)
+		conf->filter = oldconf->filter;
+
+	/* set GYRO_CONFIG0 register (gyro fullscale & odr) */
+	if (conf->fs != oldconf->fs || conf->odr != oldconf->odr) {
+		val = INV_ICM42600_GYRO_CONFIG0_FS(conf->fs) |
+		      INV_ICM42600_GYRO_CONFIG0_ODR(conf->odr);
+		ret = regmap_write(st->map, INV_ICM42600_REG_GYRO_CONFIG0, val);
+		if (ret)
+			return ret;
+		oldconf->fs = conf->fs;
+		oldconf->odr = conf->odr;
+	}
+
+	/* set GYRO_ACCEL_CONFIG0 register (gyro filter) */
+	if (conf->filter != oldconf->filter) {
+		val = INV_ICM42600_GYRO_ACCEL_CONFIG0_ACCEL_FILT(st->conf.accel.filter) |
+		      INV_ICM42600_GYRO_ACCEL_CONFIG0_GYRO_FILT(conf->filter);
+		ret = regmap_write(st->map, INV_ICM42600_REG_GYRO_ACCEL_CONFIG0, val);
+		if (ret)
+			return ret;
+		oldconf->filter = conf->filter;
+	}
+
+	/* set PWR_MGMT0 register (gyro sensor mode) */
+	return inv_icm42600_set_pwr_mgmt0(st, conf->mode, st->conf.accel.mode,
+					  st->conf.temp_en, sleep_ms);
+
+	return 0;
+}
+
+int inv_icm42600_set_temp_conf(struct inv_icm42600_state *st, bool enable,
+			       unsigned int *sleep_ms)
+{
+	return inv_icm42600_set_pwr_mgmt0(st, st->conf.gyro.mode,
+					  st->conf.accel.mode, enable,
+					  sleep_ms);
+}
+
+int inv_icm42600_debugfs_reg(struct iio_dev *indio_dev, unsigned int reg,
+			     unsigned int writeval, unsigned int *readval)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	if (readval)
+		ret = regmap_read(st->map, reg, readval);
+	else
+		ret = regmap_write(st->map, reg, writeval);
+
+	mutex_unlock(&st->lock);
+
+	return ret;
+}
+
+static int inv_icm42600_set_conf(struct inv_icm42600_state *st,
+				 const struct inv_icm42600_conf *conf)
+{
+	unsigned int val;
+	int ret;
+
+    printk("%s:%d, ACHEUL in", __FUNCTION__, __LINE__);
+
+	/* set PWR_MGMT0 register (gyro & accel sensor mode, temp enabled) */
+	val = INV_ICM42600_PWR_MGMT0_GYRO(conf->gyro.mode) |
+	      INV_ICM42600_PWR_MGMT0_ACCEL(conf->accel.mode);
+	if (!conf->temp_en)
+		val |= INV_ICM42600_PWR_MGMT0_TEMP_DIS;
+	ret = regmap_write(st->map, INV_ICM42600_REG_PWR_MGMT0, val);
+	if (ret){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	/* set GYRO_CONFIG0 register (gyro fullscale & odr) */
+	val = INV_ICM42600_GYRO_CONFIG0_FS(conf->gyro.fs) |
+	      INV_ICM42600_GYRO_CONFIG0_ODR(conf->gyro.odr);
+	ret = regmap_write(st->map, INV_ICM42600_REG_GYRO_CONFIG0, val);
+	if (ret){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	/* set ACCEL_CONFIG0 register (accel fullscale & odr) */
+	val = INV_ICM42600_ACCEL_CONFIG0_FS(conf->accel.fs) |
+	      INV_ICM42600_ACCEL_CONFIG0_ODR(conf->accel.odr);
+	ret = regmap_write(st->map, INV_ICM42600_REG_ACCEL_CONFIG0, val);
+	if (ret){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	/* set GYRO_ACCEL_CONFIG0 register (gyro & accel filters) */
+	val = INV_ICM42600_GYRO_ACCEL_CONFIG0_ACCEL_FILT(conf->accel.filter) |
+	      INV_ICM42600_GYRO_ACCEL_CONFIG0_GYRO_FILT(conf->gyro.filter);
+	ret = regmap_write(st->map, INV_ICM42600_REG_GYRO_ACCEL_CONFIG0, val);
+	if (ret){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	/* update internal conf */
+	st->conf = *conf;
+
+    printk("%s:%d, ACHEUL out", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+/**
+ *  inv_icm42600_setup() - check and setup chip
+ *  @st:	driver internal state
+ *  @bus_setup:	callback for setting up bus specific registers
+ *
+ *  Returns 0 on success, a negative error code otherwise.
+ */
+static int inv_icm42600_setup(struct inv_icm42600_state *st, inv_icm42600_bus_setup bus_setup)
+{
+	const struct inv_icm42600_hw *hw = &inv_icm42600_hw[st->chip];
+	const struct device *dev = regmap_get_device(st->map);
+	unsigned int val;
+	int ret;
+
+    printk("%s:%d, ACHEUL in", __FUNCTION__, __LINE__);
+
+	/* check chip self-identification value */
+	ret = regmap_read(st->map, INV_ICM42600_REG_WHOAMI, &val);
+	if (ret){
+        printk("%s:%d, ACHEUL, failed read regmap: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+    printk("%s:%d, ACHEUL val: %d, whoami: %d, name: %s", __FUNCTION__, __LINE__, val, hw->whoami, hw->name);
+
+	if (val != hw->whoami) {
+		dev_err(dev, "invalid whoami %#02x expected %#02x (%s)\n", val, hw->whoami, hw->name);
+        printk("%s:%d, invalid whoami %#02x expected %#02x (%s)\n", __FUNCTION__, __LINE__, val, hw->whoami, hw->name);
+		return -ENODEV;
+	}
+	st->name = hw->name;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	/* reset to make sure previous state are not there */
+	ret = regmap_write(st->map, INV_ICM42600_REG_DEVICE_CONFIG, INV_ICM42600_DEVICE_CONFIG_SOFT_RESET);
+	if (ret){
+        printk("%s:%d, ACHEUL, failed write regmap: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+	msleep(INV_ICM42600_RESET_TIME_MS);
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	ret = regmap_read(st->map, INV_ICM42600_REG_INT_STATUS, &val);
+	if (ret){
+        printk("%s:%d, ACHEUL, failed read regmap: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	if (!(val & INV_ICM42600_INT_STATUS_RESET_DONE)) {
+		dev_err(dev, "reset error, reset done bit not set\n");
+        printk("%s:%d, ACHUEL, reset problem", __FUNCTION__, __LINE__);
+		return -ENODEV;
+	}
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	/* set chip bus configuration */
+	ret = bus_setup(st);
+	if (ret) {
+        printk("%s:%d, ACHEUL, failed to bus setup: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	/* sensor data in big-endian (default) */
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG0,
+				 INV_ICM42600_INTF_CONFIG0_SENSOR_DATA_ENDIAN,
+				 INV_ICM42600_INTF_CONFIG0_SENSOR_DATA_ENDIAN);
+	if (ret) {
+        printk("%s:%d, ACHEUL, failed to regmap_update_bits ret: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	ret = inv_icm42600_set_conf(st, hw->conf);
+
+    printk("%s:%d, ACHEUL out: ret: %d", __FUNCTION__, __LINE__, ret);
+    return ret;
+}
+
+static irqreturn_t inv_icm42600_irq_timestamp(int irq, void *_data)
+{
+	struct inv_icm42600_state *st = _data;
+
+	st->timestamp.gyro = iio_get_time_ns(st->indio_gyro);
+	st->timestamp.accel = iio_get_time_ns(st->indio_accel);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t inv_icm42600_irq_handler(int irq, void *_data)
+{
+	struct inv_icm42600_state *st = _data;
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int status;
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	ret = regmap_read(st->map, INV_ICM42600_REG_INT_STATUS, &status);
+	if (ret)
+		goto out_unlock;
+
+	/* FIFO full */
+	if (status & INV_ICM42600_INT_STATUS_FIFO_FULL)
+		dev_warn(dev, "FIFO full data lost!\n");
+
+	/* FIFO threshold reached */
+	if (status & INV_ICM42600_INT_STATUS_FIFO_THS) {
+		ret = inv_icm42600_buffer_fifo_read(st, 0);
+		if (ret) {
+			dev_err(dev, "FIFO read error %d\n", ret);
+			goto out_unlock;
+		}
+		ret = inv_icm42600_buffer_fifo_parse(st);
+		if (ret)
+			dev_err(dev, "FIFO parsing error %d\n", ret);
+	}
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	return IRQ_HANDLED;
+}
+
+/**
+ * inv_icm42600_irq_init() - initialize int pin and interrupt handler
+ * @st:		driver internal state
+ * @irq:	irq number
+ * @irq_type:	irq trigger type
+ * @open_drain:	true if irq is open drain, false for push-pull
+ *
+ * Returns 0 on success, a negative error code otherwise.
+ */
+static int inv_icm42600_irq_init(struct inv_icm42600_state *st, int irq, int irq_type, bool open_drain)
+{
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int val;
+	int ret;
+
+    printk("%s:%d, ACHEUL, in", __FUNCTION__, __LINE__);
+
+	/* configure INT1 interrupt: default is active low on edge */
+	switch (irq_type) {
+	case IRQF_TRIGGER_RISING:
+	case IRQF_TRIGGER_HIGH:
+		val = INV_ICM42600_INT_CONFIG_INT1_ACTIVE_HIGH;
+		break;
+	default:
+		val = INV_ICM42600_INT_CONFIG_INT1_ACTIVE_LOW;
+		break;
+	}
+
+	switch (irq_type) {
+	case IRQF_TRIGGER_LOW:
+	case IRQF_TRIGGER_HIGH:
+		val |= INV_ICM42600_INT_CONFIG_INT1_LATCHED;
+		break;
+	default:
+		break;
+	}
+
+	if (!open_drain)
+		val |= INV_ICM42600_INT_CONFIG_INT1_PUSH_PULL;
+
+	ret = regmap_write(st->map, INV_ICM42600_REG_INT_CONFIG, val);
+	if (ret) {
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	/* Deassert async reset for proper INT pin operation (cf datasheet) */
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INT_CONFIG1,
+				 INV_ICM42600_INT_CONFIG1_ASYNC_RESET, 0);
+	if (ret){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	ret = devm_request_threaded_irq(dev, irq, inv_icm42600_irq_timestamp, inv_icm42600_irq_handler, irq_type, "inv_icm42600", st);
+
+    printk("%s:%d, ACHEUL, out: ret: %d", __FUNCTION__, __LINE__, ret);
+    return ret;
+}
+
+static int inv_icm42600_enable_regulator_vddio(struct inv_icm42600_state *st)
+{
+
+#if USE_VDD
+	int ret;
+    printk("%s:%d ACHEUL, VDD management is enabled", __FUNCTION__, __LINE__);
+
+	ret = regulator_enable(st->vddio_supply);
+	if (ret)
+		return ret;
+
+	/* wait a little for supply ramp */
+	usleep_range(3000, 4000);
+#else
+    printk("%s:%d ACHEUL, FIXME! VDD management is disabled", __FUNCTION__, __LINE__);
+#endif // USE_VDD
+
+	return 0;
+}
+
+#if USE_VDD
+static void inv_icm42600_disable_vdd_reg(void *_data)
+{
+	struct inv_icm42600_state *st = _data;
+	const struct device *dev = regmap_get_device(st->map);
+	int ret;
+
+	ret = regulator_disable(st->vdd_supply);
+	if (ret)
+		dev_err(dev, "failed to disable vdd error %d\n", ret);
+}
+#endif // USE_VDD
+
+#if USE_VDD
+static void inv_icm42600_disable_vddio_reg(void *_data)
+{
+	struct inv_icm42600_state *st = _data;
+	const struct device *dev = regmap_get_device(st->map);
+	int ret;
+
+	ret = regulator_disable(st->vddio_supply);
+	if (ret)
+		dev_err(dev, "failed to disable vddio error %d\n", ret);
+}
+#endif // USE_VDD
+
+static void inv_icm42600_disable_pm(void *_data)
+{
+	struct device *dev = _data;
+
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+}
+
+int inv_icm42600_core_probe(struct regmap *regmap, int chip, int irq, inv_icm42600_bus_setup bus_setup)
+{
+	struct device *dev = regmap_get_device(regmap);
+	struct inv_icm42600_state *st;
+	struct irq_data *irq_desc;
+	int irq_type;
+	bool open_drain;
+	int ret;
+
+    printk("%s:%d, ACHEUL, IN", __FUNCTION__, __LINE__);
+
+	if (chip <= INV_CHIP_INVALID || chip >= INV_CHIP_NB) {
+		dev_err(dev, "ACHEUL, invalid chip = %d\n", chip);
+		return -ENODEV;
+	}
+
+    printk("%s:%d, ACHEUL, chip: %d", __FUNCTION__, __LINE__, chip);
+
+	/* get irq properties, set trigger falling by default */
+	irq_desc = irq_get_irq_data(irq);
+	if (!irq_desc) {
+		dev_err(dev, "ACHEUL, could not find IRQ: %d\n", irq);
+		return -EINVAL;
+	}
+
+	irq_type = irqd_get_trigger_type(irq_desc);
+	if (!irq_type)
+		irq_type = IRQF_TRIGGER_FALLING;
+
+	open_drain = device_property_read_bool(dev, "drive-open-drain");
+
+	st = devm_kzalloc(dev, sizeof(*st), GFP_KERNEL);
+	if (!st) {
+		dev_err(dev, "ACHEUL, could allocate mem\n");
+		return -ENOMEM;
+    }
+
+	dev_set_drvdata(dev, st);
+	mutex_init(&st->lock);
+	st->chip = chip;
+	st->map = regmap;
+
+	ret = of_iio_read_mount_matrix(dev, "mount-matrix", &st->orientation);
+	if (ret) {
+		dev_err(dev, "ACHEUL, FIXME! failed to retrieve mounting matrix %d\n", ret);
+		return ret;
+	}
+
+// ===============================================
+// ACHEUL, FIXME VDD/VDDIO not supported yet
+#if USE_VDD
+    printk("%s:%d ACHEUL, VDD management is enabled", __FUNCTION__, __LINE__);
+
+	st->vdd_supply = devm_regulator_get(dev, "vdd");
+	if (IS_ERR(st->vdd_supply)) {
+		dev_err(dev, "failed, no vdd supply\n");
+		//return PTR_ERR(st->vdd_supply);
+    }
+
+	st->vddio_supply = devm_regulator_get(dev, "vddio");
+	if (IS_ERR(st->vddio_supply)) {
+		dev_err(dev, "failed, no vddio supply\n");
+		//return PTR_ERR(st->vddio_supply);
+    }
+
+	ret = regulator_enable(st->vdd_supply);
+	if (ret) {
+		dev_err(dev, "failed to enable regulator\n");
+		return ret;
+    }
+	msleep(INV_ICM42600_POWER_UP_TIME_MS);
+
+	ret = devm_add_action_or_reset(dev, inv_icm42600_disable_vdd_reg, st);
+	if (ret) {
+		dev_err(dev, "failed to add action reset\n");
+		return ret;
+    }
+
+	ret = inv_icm42600_enable_regulator_vddio(st);
+	if (ret){
+		dev_err(dev, "failed to enable vddio\n");
+		return ret;
+    }
+
+	ret = devm_add_action_or_reset(dev, inv_icm42600_disable_vddio_reg, st);
+	if (ret){
+		dev_err(dev, "failed to add action reset\n");
+		return ret;
+    }
+#endif // 0
+// ===============================================
+
+	/* setup chip registers */
+	ret = inv_icm42600_setup(st, bus_setup);
+	if (ret) {
+		dev_err(dev, "ACHEUL, failed to setup, error: %d\n", ret);
+		return ret;
+    }
+
+	ret = inv_icm42600_timestamp_setup(st);
+	if (ret) {
+		dev_err(dev, "ACHEUL, failed to timestamp setup, error: %d\n", ret);
+		return ret;
+    }
+
+	ret = inv_icm42600_buffer_init(st);
+	if (ret) {
+		dev_err(dev, "ACHEUL, failed, to buffer init, error: %d\n", ret);
+		return ret;
+    }
+
+	st->indio_gyro = inv_icm42600_gyro_init(st);
+	if (IS_ERR(st->indio_gyro)) {
+		return PTR_ERR(st->indio_gyro);
+    }
+
+	st->indio_accel = inv_icm42600_accel_init(st);
+	if (IS_ERR(st->indio_accel)) {
+		dev_err(dev, "ACHEUL, failed, accel init\n");
+		return PTR_ERR(st->indio_accel);
+    }
+
+	ret = inv_icm42600_irq_init(st, irq, irq_type, open_drain);
+	if (ret) {
+		dev_err(dev, "ACHEUL, failed, irq initi, %d\n", ret);
+		return ret;
+    }
+
+	/* setup runtime power management */
+	ret = pm_runtime_set_active(dev);
+	if (ret) {
+		dev_err(dev, "ACHEUL, failed, pm_runtime_set_active, %d\n", ret);
+		return ret;
+    }
+
+	pm_runtime_get_noresume(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_set_autosuspend_delay(dev, INV_ICM42600_SUSPEND_DELAY_MS);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_put(dev);
+
+	return devm_add_action_or_reset(dev, inv_icm42600_disable_pm, dev);
+}
+EXPORT_SYMBOL_GPL(inv_icm42600_core_probe);
+
+/*
+ * Suspend saves sensors state and turns everything off.
+ * Check first if runtime suspend has not already done the job.
+ */
+static int __maybe_unused inv_icm42600_suspend(struct device *dev)
+{
+
+#if USE_VDD
+	struct inv_icm42600_state *st = dev_get_drvdata(dev);
+	int ret;
+
+    printk("%s:%d ACHEUL, in", __FUNCTION__, __LINE__);
+
+	mutex_lock(&st->lock);
+
+	st->suspended.gyro = st->conf.gyro.mode;
+	st->suspended.accel = st->conf.accel.mode;
+	st->suspended.temp = st->conf.temp_en;
+	if (pm_runtime_suspended(dev)) {
+		ret = 0;
+		goto out_unlock;
+	}
+
+	/* disable FIFO data streaming */
+	if (st->fifo.on) {
+		ret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,
+				   INV_ICM42600_FIFO_CONFIG_BYPASS);
+		if (ret)
+			goto out_unlock;
+	}
+
+	ret = inv_icm42600_set_pwr_mgmt0(st, INV_ICM42600_SENSOR_MODE_OFF,
+					 INV_ICM42600_SENSOR_MODE_OFF, false,
+					 NULL);
+	if (ret)
+		goto out_unlock;
+
+	regulator_disable(st->vddio_supply);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	return ret;
+#else
+    printk("%s:%d ACHEUL, FIXME! VDD management is disabled", __FUNCTION__, __LINE__);
+    return 0;
+#endif // USE_VDD
+
+}
+
+/*
+ * System resume gets the system back on and restores the sensors state.
+ * Manually put runtime power management in system active state.
+ */
+static int __maybe_unused inv_icm42600_resume(struct device *dev)
+{
+	struct inv_icm42600_state *st = dev_get_drvdata(dev);
+	int ret;
+
+    printk("%s:%d ACHEUL, in", __FUNCTION__, __LINE__);
+
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_enable_regulator_vddio(st);
+	if (ret)
+		goto out_unlock;
+
+	pm_runtime_disable(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	/* restore sensors state */
+	ret = inv_icm42600_set_pwr_mgmt0(st, st->suspended.gyro,
+					 st->suspended.accel,
+					 st->suspended.temp, NULL);
+	if (ret)
+		goto out_unlock;
+
+	/* restore FIFO data streaming */
+	if (st->fifo.on)
+		ret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,
+				   INV_ICM42600_FIFO_CONFIG_STREAM);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+    printk("%s:%d ACHEUL, out: %d", __FUNCTION__, __LINE__, ret);
+	return ret;
+}
+
+/* Runtime suspend will turn off sensors that are enabled by iio devices. */
+static int __maybe_unused inv_icm42600_runtime_suspend(struct device *dev)
+{
+	struct inv_icm42600_state *st = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	/* disable all sensors */
+	ret = inv_icm42600_set_pwr_mgmt0(st, INV_ICM42600_SENSOR_MODE_OFF,
+					 INV_ICM42600_SENSOR_MODE_OFF, false,
+					 NULL);
+	if (ret)
+		goto error_unlock;
+
+#if USE_VDD
+    printk("%s:%d ACHEUL, VDD management is enabled", __FUNCTION__, __LINE__);
+	regulator_disable(st->vddio_supply);
+#else
+    printk("%s:%d ACHEUL, VDD management is disabled", __FUNCTION__, __LINE__);
+#endif // USE_VDD
+
+error_unlock:
+	mutex_unlock(&st->lock);
+	return ret;
+}
+
+/* Sensors are enabled by iio devices, no need to turn them back on here. */
+static int __maybe_unused inv_icm42600_runtime_resume(struct device *dev)
+{
+	struct inv_icm42600_state *st = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+#if USE_VDD
+    printk("%s:%d ACHEUL, VDD management is enabled", __FUNCTION__, __LINE__);
+	ret = inv_icm42600_enable_regulator_vddio(st);
+#else
+    printk("%s:%d ACHEUL, VDD management is disabled", __FUNCTION__, __LINE__);
+#endif // USE_VDD
+
+	mutex_unlock(&st->lock);
+	return ret;
+}
+
+const struct dev_pm_ops inv_icm42600_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(inv_icm42600_suspend, inv_icm42600_resume)
+	SET_RUNTIME_PM_OPS(inv_icm42600_runtime_suspend,
+			   inv_icm42600_runtime_resume, NULL)
+};
+EXPORT_SYMBOL_GPL(inv_icm42600_pm_ops);
+
+MODULE_AUTHOR("ACHEUL & InvenSense, Inc.");
+MODULE_DESCRIPTION("InvenSense ICM-426xx device driver");
+MODULE_LICENSE("GPL");
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_gyro.c msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_gyro.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_gyro.c	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_gyro.c	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,801 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/math64.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/kfifo_buf.h>
+
+#include "inv_icm42600.h"
+#include "inv_icm42600_temp.h"
+#include "inv_icm42600_buffer.h"
+#include "inv_icm42600_timestamp.h"
+
+#define INV_ICM42600_GYRO_CHAN(_modifier, _index, _ext_info)		\
+	{								\
+		.type = IIO_ANGL_VEL,					\
+		.modified = 1,						\
+		.channel2 = _modifier,					\
+		.info_mask_separate =					\
+			BIT(IIO_CHAN_INFO_RAW) |			\
+			BIT(IIO_CHAN_INFO_CALIBBIAS),			\
+		.info_mask_shared_by_type =				\
+			BIT(IIO_CHAN_INFO_SCALE),			\
+		.info_mask_shared_by_type_available =			\
+			BIT(IIO_CHAN_INFO_SCALE) |			\
+			BIT(IIO_CHAN_INFO_CALIBBIAS),			\
+		.info_mask_shared_by_all =				\
+			BIT(IIO_CHAN_INFO_SAMP_FREQ),			\
+		.info_mask_shared_by_all_available =			\
+			BIT(IIO_CHAN_INFO_SAMP_FREQ),			\
+		.scan_index = _index,					\
+		.scan_type = {						\
+			.sign = 's',					\
+			.realbits = 16,					\
+			.storagebits = 16,				\
+			.endianness = IIO_BE,				\
+		},							\
+		.ext_info = _ext_info,					\
+	}
+
+enum inv_icm42600_gyro_scan {
+	INV_ICM42600_GYRO_SCAN_X,
+	INV_ICM42600_GYRO_SCAN_Y,
+	INV_ICM42600_GYRO_SCAN_Z,
+	INV_ICM42600_GYRO_SCAN_TEMP,
+	INV_ICM42600_GYRO_SCAN_TIMESTAMP,
+};
+
+static const struct iio_chan_spec_ext_info inv_icm42600_gyro_ext_infos[] = {
+	IIO_MOUNT_MATRIX(IIO_SHARED_BY_ALL, inv_icm42600_get_mount_matrix),
+	{},
+};
+
+static const struct iio_chan_spec inv_icm42600_gyro_channels[] = {
+	INV_ICM42600_GYRO_CHAN(IIO_MOD_X, INV_ICM42600_GYRO_SCAN_X,
+			       inv_icm42600_gyro_ext_infos),
+	INV_ICM42600_GYRO_CHAN(IIO_MOD_Y, INV_ICM42600_GYRO_SCAN_Y,
+			       inv_icm42600_gyro_ext_infos),
+	INV_ICM42600_GYRO_CHAN(IIO_MOD_Z, INV_ICM42600_GYRO_SCAN_Z,
+			       inv_icm42600_gyro_ext_infos),
+	INV_ICM42600_TEMP_CHAN(INV_ICM42600_GYRO_SCAN_TEMP),
+	IIO_CHAN_SOFT_TIMESTAMP(INV_ICM42600_GYRO_SCAN_TIMESTAMP),
+};
+
+/*
+ * IIO buffer data: size must be a power of 2 and timestamp aligned
+ * 16 bytes: 6 bytes angular velocity, 2 bytes temperature, 8 bytes timestamp
+ */
+struct inv_icm42600_gyro_buffer {
+	struct inv_icm42600_fifo_sensor_data gyro;
+	int16_t temp;
+	int64_t timestamp __aligned(8);
+};
+
+#define INV_ICM42600_SCAN_MASK_GYRO_3AXIS				\
+	(BIT(INV_ICM42600_GYRO_SCAN_X) |				\
+	BIT(INV_ICM42600_GYRO_SCAN_Y) |					\
+	BIT(INV_ICM42600_GYRO_SCAN_Z))
+
+#define INV_ICM42600_SCAN_MASK_TEMP	BIT(INV_ICM42600_GYRO_SCAN_TEMP)
+
+static const unsigned long inv_icm42600_gyro_scan_masks[] = {
+	/* 3-axis gyro + temperature */
+	INV_ICM42600_SCAN_MASK_GYRO_3AXIS | INV_ICM42600_SCAN_MASK_TEMP,
+	0,
+};
+
+/* enable gyroscope sensor and FIFO write */
+static int inv_icm42600_gyro_update_scan_mode(struct iio_dev *indio_dev,
+					      const unsigned long *scan_mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	unsigned int fifo_en = 0;
+	unsigned int sleep_gyro = 0;
+	unsigned int sleep_temp = 0;
+	unsigned int sleep;
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	if (*scan_mask & INV_ICM42600_SCAN_MASK_TEMP) {
+		/* enable temp sensor */
+		ret = inv_icm42600_set_temp_conf(st, true, &sleep_temp);
+		if (ret)
+			goto out_unlock;
+		fifo_en |= INV_ICM42600_SENSOR_TEMP;
+	}
+
+	if (*scan_mask & INV_ICM42600_SCAN_MASK_GYRO_3AXIS) {
+		/* enable gyro sensor */
+		conf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;
+		ret = inv_icm42600_set_gyro_conf(st, &conf, &sleep_gyro);
+		if (ret)
+			goto out_unlock;
+		fifo_en |= INV_ICM42600_SENSOR_GYRO;
+	}
+
+	/* update data FIFO write */
+	inv_icm42600_timestamp_apply_odr(ts, 0, 0, 0);
+	ret = inv_icm42600_buffer_set_fifo_en(st, fifo_en | st->fifo.en);
+	if (ret)
+		goto out_unlock;
+
+	ret = inv_icm42600_buffer_update_watermark(st);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	/* sleep maximum required time */
+	if (sleep_gyro > sleep_temp)
+		sleep = sleep_gyro;
+	else
+		sleep = sleep_temp;
+	if (sleep)
+		msleep(sleep);
+	return ret;
+}
+
+static int inv_icm42600_gyro_read_sensor(struct inv_icm42600_state *st,
+					 struct iio_chan_spec const *chan,
+					 int16_t *val)
+{
+	struct device *dev = regmap_get_device(st->map);
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	unsigned int reg;
+	__be16 *data;
+	int ret;
+
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_GYRO_DATA_X;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_GYRO_DATA_Y;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_GYRO_DATA_Z;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	/* enable gyro sensor */
+	conf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;
+	ret = inv_icm42600_set_gyro_conf(st, &conf, NULL);
+	if (ret)
+		goto exit;
+
+	/* read gyro register data */
+	data = (__be16 *)&st->buffer[0];
+	ret = regmap_bulk_read(st->map, reg, data, sizeof(*data));
+	if (ret)
+		goto exit;
+
+	*val = (int16_t)be16_to_cpup(data);
+	if (*val == INV_ICM42600_DATA_INVALID)
+		ret = -EINVAL;
+exit:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	return ret;
+}
+
+/* IIO format int + nano */
+static const int inv_icm42600_gyro_scale[] = {
+	/* +/- 2000dps => 0.001065264 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_2000DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_2000DPS + 1] = 1065264,
+	/* +/- 1000dps => 0.000532632 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_1000DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_1000DPS + 1] = 532632,
+	/* +/- 500dps => 0.000266316 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_500DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_500DPS + 1] = 266316,
+	/* +/- 250dps => 0.000133158 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_250DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_250DPS + 1] = 133158,
+	/* +/- 125dps => 0.000066579 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_125DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_125DPS + 1] = 66579,
+	/* +/- 62.5dps => 0.000033290 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_62_5DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_62_5DPS + 1] = 33290,
+	/* +/- 31.25dps => 0.000016645 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_31_25DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_31_25DPS + 1] = 16645,
+	/* +/- 15.625dps => 0.000008322 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_15_625DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_15_625DPS + 1] = 8322,
+};
+
+static int inv_icm42600_gyro_read_scale(struct inv_icm42600_state *st,
+					int *val, int *val2)
+{
+	unsigned int idx;
+
+	idx = st->conf.gyro.fs;
+
+	*val = inv_icm42600_gyro_scale[2 * idx];
+	*val2 = inv_icm42600_gyro_scale[2 * idx + 1];
+	return IIO_VAL_INT_PLUS_NANO;
+}
+
+static int inv_icm42600_gyro_write_scale(struct inv_icm42600_state *st,
+					 int val, int val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int idx;
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	int ret;
+
+	for (idx = 0; idx < ARRAY_SIZE(inv_icm42600_gyro_scale); idx += 2) {
+		if (val == inv_icm42600_gyro_scale[idx] &&
+		    val2 == inv_icm42600_gyro_scale[idx + 1])
+			break;
+	}
+	if (idx >= ARRAY_SIZE(inv_icm42600_gyro_scale))
+		return -EINVAL;
+
+	conf.fs = idx / 2;
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_set_gyro_conf(st, &conf, NULL);
+
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+/* IIO format int + micro */
+static const int inv_icm42600_gyro_odr[] = {
+	/* 12.5Hz */
+	12, 500000,
+	/* 25Hz */
+	25, 0,
+	/* 50Hz */
+	50, 0,
+	/* 100Hz */
+	100, 0,
+	/* 200Hz */
+	200, 0,
+	/* 1kHz */
+	1000, 0,
+	/* 2kHz */
+	2000, 0,
+	/* 4kHz */
+	4000, 0,
+};
+
+static const int inv_icm42600_gyro_odr_conv[] = {
+	INV_ICM42600_ODR_12_5HZ,
+	INV_ICM42600_ODR_25HZ,
+	INV_ICM42600_ODR_50HZ,
+	INV_ICM42600_ODR_100HZ,
+	INV_ICM42600_ODR_200HZ,
+	INV_ICM42600_ODR_1KHZ_LN,
+	INV_ICM42600_ODR_2KHZ_LN,
+	INV_ICM42600_ODR_4KHZ_LN,
+};
+
+static int inv_icm42600_gyro_read_odr(struct inv_icm42600_state *st,
+				      int *val, int *val2)
+{
+	unsigned int odr;
+	unsigned int i;
+
+	odr = st->conf.gyro.odr;
+
+	for (i = 0; i < ARRAY_SIZE(inv_icm42600_gyro_odr_conv); ++i) {
+		if (inv_icm42600_gyro_odr_conv[i] == odr)
+			break;
+	}
+	if (i >= ARRAY_SIZE(inv_icm42600_gyro_odr_conv))
+		return -EINVAL;
+
+	*val = inv_icm42600_gyro_odr[2 * i];
+	*val2 = inv_icm42600_gyro_odr[2 * i + 1];
+
+	return IIO_VAL_INT_PLUS_MICRO;
+}
+
+static int inv_icm42600_gyro_write_odr(struct iio_dev *indio_dev,
+				       int val, int val2)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int idx;
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	int ret;
+
+	for (idx = 0; idx < ARRAY_SIZE(inv_icm42600_gyro_odr); idx += 2) {
+		if (val == inv_icm42600_gyro_odr[idx] &&
+		    val2 == inv_icm42600_gyro_odr[idx + 1])
+			break;
+	}
+	if (idx >= ARRAY_SIZE(inv_icm42600_gyro_odr))
+		return -EINVAL;
+
+	conf.odr = inv_icm42600_gyro_odr_conv[idx / 2];
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_timestamp_update_odr(ts, inv_icm42600_odr_to_period(conf.odr),
+						iio_buffer_enabled(indio_dev));
+	if (ret)
+		goto out_unlock;
+
+	ret = inv_icm42600_set_gyro_conf(st, &conf, NULL);
+	if (ret)
+		goto out_unlock;
+	inv_icm42600_buffer_update_fifo_period(st);
+	inv_icm42600_buffer_update_watermark(st);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+/*
+ * Calibration bias values, IIO range format int + nano.
+ * Value is limited to +/-64dps coded on 12 bits signed. Step is 1/32 dps.
+ */
+static int inv_icm42600_gyro_calibbias[] = {
+	-1, 117010721,		/* min: -1.117010721 rad/s */
+	0, 545415,		/* step: 0.000545415 rad/s */
+	1, 116465306,		/* max: 1.116465306 rad/s */
+};
+
+static int inv_icm42600_gyro_read_offset(struct inv_icm42600_state *st,
+					 struct iio_chan_spec const *chan,
+					 int *val, int *val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	int64_t val64;
+	int32_t bias;
+	unsigned int reg;
+	int16_t offset;
+	uint8_t data[2];
+	int ret;
+
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_OFFSET_USER0;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_OFFSET_USER1;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_OFFSET_USER3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = regmap_bulk_read(st->map, reg, st->buffer, sizeof(data));
+	memcpy(data, st->buffer, sizeof(data));
+
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	if (ret)
+		return ret;
+
+	/* 12 bits signed value */
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		offset = sign_extend32(((data[1] & 0x0F) << 8) | data[0], 11);
+		break;
+	case IIO_MOD_Y:
+		offset = sign_extend32(((data[0] & 0xF0) << 4) | data[1], 11);
+		break;
+	case IIO_MOD_Z:
+		offset = sign_extend32(((data[1] & 0x0F) << 8) | data[0], 11);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+	 * convert raw offset to dps then to rad/s
+	 * 12 bits signed raw max 64 to dps: 64 / 2048
+	 * dps to rad: Pi / 180
+	 * result in nano (1000000000)
+	 * (offset * 64 * Pi * 1000000000) / (2048 * 180)
+	 */
+	val64 = (int64_t)offset * 64LL * 3141592653LL;
+	/* for rounding, add + or - divisor (2048 * 180) divided by 2 */
+	if (val64 >= 0)
+		val64 += 2048 * 180 / 2;
+	else
+		val64 -= 2048 * 180 / 2;
+	bias = div_s64(val64, 2048 * 180);
+	*val = bias / 1000000000L;
+	*val2 = bias % 1000000000L;
+
+	return IIO_VAL_INT_PLUS_NANO;
+}
+
+static int inv_icm42600_gyro_write_offset(struct inv_icm42600_state *st,
+					  struct iio_chan_spec const *chan,
+					  int val, int val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	int64_t val64, min, max;
+	unsigned int reg, regval;
+	int16_t offset;
+	int ret;
+
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_OFFSET_USER0;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_OFFSET_USER1;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_OFFSET_USER3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* inv_icm42600_gyro_calibbias: min - step - max in nano */
+	min = (int64_t)inv_icm42600_gyro_calibbias[0] * 1000000000LL +
+	      (int64_t)inv_icm42600_gyro_calibbias[1];
+	max = (int64_t)inv_icm42600_gyro_calibbias[4] * 1000000000LL +
+	      (int64_t)inv_icm42600_gyro_calibbias[5];
+	val64 = (int64_t)val * 1000000000LL + (int64_t)val2;
+	if (val64 < min || val64 > max)
+		return -EINVAL;
+
+	/*
+	 * convert rad/s to dps then to raw value
+	 * rad to dps: 180 / Pi
+	 * dps to raw 12 bits signed, max 64: 2048 / 64
+	 * val in nano (1000000000)
+	 * val * 180 * 2048 / (Pi * 1000000000 * 64)
+	 */
+	val64 = val64 * 180LL * 2048LL;
+	/* for rounding, add + or - divisor (3141592653 * 64) divided by 2 */
+	if (val64 >= 0)
+		val64 += 3141592653LL * 64LL / 2LL;
+	else
+		val64 -= 3141592653LL * 64LL / 2LL;
+	offset = div64_s64(val64, 3141592653LL * 64LL);
+
+	/* clamp value limited to 12 bits signed */
+	if (offset < -2048)
+		offset = -2048;
+	else if (offset > 2047)
+		offset = 2047;
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		/* OFFSET_USER1 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER1,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = offset & 0xFF;
+		st->buffer[1] = (regval & 0xF0) | ((offset & 0xF00) >> 8);
+		break;
+	case IIO_MOD_Y:
+		/* OFFSET_USER1 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER1,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = ((offset & 0xF00) >> 4) | (regval & 0x0F);
+		st->buffer[1] = offset & 0xFF;
+		break;
+	case IIO_MOD_Z:
+		/* OFFSET_USER4 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER4,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = offset & 0xFF;
+		st->buffer[1] = (regval & 0xF0) | ((offset & 0xF00) >> 8);
+		break;
+	default:
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	ret = regmap_bulk_write(st->map, reg, st->buffer, 2);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	return ret;
+}
+
+static int inv_icm42600_gyro_read_raw(struct iio_dev *indio_dev,
+				      struct iio_chan_spec const *chan,
+				      int *val, int *val2, long mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int16_t data;
+	int ret;
+
+	switch (chan->type) {
+	case IIO_ANGL_VEL:
+		break;
+	case IIO_TEMP:
+		return inv_icm42600_temp_read_raw(indio_dev, chan, val, val2, mask);
+	default:
+		return -EINVAL;
+	}
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_gyro_read_sensor(st, chan, &data);
+		iio_device_release_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		*val = data;
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		return inv_icm42600_gyro_read_scale(st, val, val2);
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return inv_icm42600_gyro_read_odr(st, val, val2);
+	case IIO_CHAN_INFO_CALIBBIAS:
+		return inv_icm42600_gyro_read_offset(st, chan, val, val2);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_gyro_read_avail(struct iio_dev *indio_dev,
+					struct iio_chan_spec const *chan,
+					const int **vals,
+					int *type, int *length, long mask)
+{
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		*vals = inv_icm42600_gyro_scale;
+		*type = IIO_VAL_INT_PLUS_NANO;
+		*length = ARRAY_SIZE(inv_icm42600_gyro_scale);
+		return IIO_AVAIL_LIST;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*vals = inv_icm42600_gyro_odr;
+		*type = IIO_VAL_INT_PLUS_MICRO;
+		*length = ARRAY_SIZE(inv_icm42600_gyro_odr);
+		return IIO_AVAIL_LIST;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		*vals = inv_icm42600_gyro_calibbias;
+		*type = IIO_VAL_INT_PLUS_NANO;
+		return IIO_AVAIL_RANGE;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_gyro_write_raw(struct iio_dev *indio_dev,
+				       struct iio_chan_spec const *chan,
+				       int val, int val2, long mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_gyro_write_scale(st, val, val2);
+		iio_device_release_direct_mode(indio_dev);
+		return ret;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return inv_icm42600_gyro_write_odr(indio_dev, val, val2);
+	case IIO_CHAN_INFO_CALIBBIAS:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_gyro_write_offset(st, chan, val, val2);
+		iio_device_release_direct_mode(indio_dev);
+		return ret;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_gyro_write_raw_get_fmt(struct iio_dev *indio_dev,
+					       struct iio_chan_spec const *chan,
+					       long mask)
+{
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		return IIO_VAL_INT_PLUS_NANO;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		return IIO_VAL_INT_PLUS_NANO;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_gyro_hwfifo_set_watermark(struct iio_dev *indio_dev,
+						  unsigned int val)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	st->fifo.watermark.gyro = val;
+	ret = inv_icm42600_buffer_update_watermark(st);
+
+	mutex_unlock(&st->lock);
+
+	return ret;
+}
+
+static int inv_icm42600_gyro_hwfifo_flush(struct iio_dev *indio_dev,
+					  unsigned int count)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	if (count == 0)
+		return 0;
+
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_buffer_hwfifo_flush(st, count);
+	if (!ret)
+		ret = st->fifo.nb.gyro;
+
+	mutex_unlock(&st->lock);
+
+	return ret;
+}
+
+static const struct iio_info inv_icm42600_gyro_info = {
+	.read_raw = inv_icm42600_gyro_read_raw,
+	.read_avail = inv_icm42600_gyro_read_avail,
+	.write_raw = inv_icm42600_gyro_write_raw,
+	.write_raw_get_fmt = inv_icm42600_gyro_write_raw_get_fmt,
+	.debugfs_reg_access = inv_icm42600_debugfs_reg,
+	.update_scan_mode = inv_icm42600_gyro_update_scan_mode,
+	.hwfifo_set_watermark = inv_icm42600_gyro_hwfifo_set_watermark,
+	.hwfifo_flush_to_buffer = inv_icm42600_gyro_hwfifo_flush,
+};
+
+struct iio_dev *inv_icm42600_gyro_init(struct inv_icm42600_state *st)
+{
+	struct device *dev = regmap_get_device(st->map);
+	const char *name;
+	struct inv_icm42600_timestamp *ts;
+	struct iio_dev *indio_dev;
+	int ret;
+
+
+	name = devm_kasprintf(dev, GFP_KERNEL, "%s-gyro", st->name);
+	if (!name)
+		return ERR_PTR(-ENOMEM);
+
+	indio_dev = devm_iio_device_alloc(dev, sizeof(*ts));
+	if (!indio_dev)
+		return ERR_PTR(-ENOMEM);
+
+	ts = iio_priv(indio_dev);
+	inv_icm42600_timestamp_init(ts, inv_icm42600_odr_to_period(st->conf.gyro.odr));
+
+	iio_device_set_drvdata(indio_dev, st);
+	indio_dev->name = name;
+	indio_dev->info = &inv_icm42600_gyro_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = inv_icm42600_gyro_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_icm42600_gyro_channels);
+	indio_dev->available_scan_masks = inv_icm42600_gyro_scan_masks;
+	indio_dev->setup_ops = &inv_icm42600_buffer_ops;
+
+// FIXME! ACHEUL
+#if 0
+	ret = devm_iio_kfifo_buffer_setup(dev, indio_dev,
+					  INDIO_BUFFER_SOFTWARE,
+					  &inv_icm42600_buffer_ops);
+	if (ret)
+		return ERR_PTR(ret);
+#endif 
+
+	ret = devm_iio_device_register(dev, indio_dev);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return indio_dev;
+}
+
+int inv_icm42600_gyro_parse_fifo(struct iio_dev *indio_dev)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	ssize_t i, size;
+	unsigned int no;
+	const void *accel, *gyro, *timestamp;
+	const int8_t *temp;
+	unsigned int odr;
+	int64_t ts_val;
+	struct inv_icm42600_gyro_buffer buffer;
+
+	/* parse all fifo packets */
+	for (i = 0, no = 0; i < st->fifo.count; i += size, ++no) {
+		size = inv_icm42600_fifo_decode_packet(&st->fifo.data[i],
+				&accel, &gyro, &temp, &timestamp, &odr);
+		/* quit if error or FIFO is empty */
+		if (size <= 0)
+			return size;
+
+		/* skip packet if no gyro data or data is invalid */
+		if (gyro == NULL || !inv_icm42600_fifo_is_data_valid(gyro))
+			continue;
+
+		/* update odr */
+		if (odr & INV_ICM42600_SENSOR_GYRO)
+			inv_icm42600_timestamp_apply_odr(ts, st->fifo.period,
+							 st->fifo.nb.total, no);
+
+		/* buffer is copied to userspace, zeroing it to avoid any data leak */
+		memset(&buffer, 0, sizeof(buffer));
+		memcpy(&buffer.gyro, gyro, sizeof(buffer.gyro));
+		/* convert 8 bits FIFO temperature in high resolution format */
+		buffer.temp = temp ? (*temp * 64) : 0;
+		ts_val = inv_icm42600_timestamp_pop(ts);
+		iio_push_to_buffers_with_timestamp(indio_dev, &buffer, ts_val);
+	}
+
+	return 0;
+}
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_i2c.c msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_i2c.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_i2c.c	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_i2c.c	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 InvenSense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/property.h>
+
+#include "inv_icm42600.h"
+
+static int inv_icm42600_i2c_bus_setup(struct inv_icm42600_state *st)
+{
+	unsigned int mask, val;
+	int ret;
+
+	/*
+	 * setup interface registers
+	 * This register write to REG_INTF_CONFIG6 enables a spike filter that
+	 * is impacting the line and can prevent the I2C ACK to be seen by the
+	 * controller. So we don't test the return value.
+	 */
+	regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG6,
+			   INV_ICM42600_INTF_CONFIG6_MASK,
+			   INV_ICM42600_INTF_CONFIG6_I3C_EN);
+
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG4,
+				 INV_ICM42600_INTF_CONFIG4_I3C_BUS_ONLY, 0);
+	if (ret)
+		return ret;
+
+	/* set slew rates for I2C and SPI */
+	mask = INV_ICM42600_DRIVE_CONFIG_I2C_MASK |
+	       INV_ICM42600_DRIVE_CONFIG_SPI_MASK;
+	val = INV_ICM42600_DRIVE_CONFIG_I2C(INV_ICM42600_SLEW_RATE_12_36NS) |
+	      INV_ICM42600_DRIVE_CONFIG_SPI(INV_ICM42600_SLEW_RATE_12_36NS);
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_DRIVE_CONFIG,
+				 mask, val);
+	if (ret)
+		return ret;
+
+	/* disable SPI bus */
+	return regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG0,
+				  INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_MASK,
+				  INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_SPI_DIS);
+}
+
+static int inv_icm42600_probe(struct i2c_client *client)
+{
+	const void *match;
+	enum inv_icm42600_chip chip;
+	struct regmap *regmap;
+    char message[256];
+    int ret = 0;
+
+    sprintf(message, "%s:%d ACHEUL\n", __FUNCTION__, __LINE__);
+
+    printk     ("printk                   : %s", message);
+    dev_err    (&client->dev, "dev_err    : %s", message);
+    dev_warn   (&client->dev, "dev_warning: %s", message);
+    dev_notice (&client->dev, "dev_notice : %s", message);
+    dev_info   (&client->dev, "dev_info   : %s", message);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK)) {
+        printk("%s:%d, ACHEUL, error, i2c functionality", __FUNCTION__, __LINE__);
+		return -ENOTSUPP;
+    }
+
+	match = device_get_match_data(&client->dev);
+	if (!match){
+        printk("%s:%d, ACHEUL, error, no match", __FUNCTION__, __LINE__);
+		return -EINVAL;
+    }
+	chip = (enum inv_icm42600_chip)match;
+
+	regmap = devm_regmap_init_i2c(client, &inv_icm42600_regmap_config);
+	if (IS_ERR(regmap)) {
+        printk("%s:%d, ACHEUL, error config regmap", __FUNCTION__, __LINE__);
+		return PTR_ERR(regmap);
+    }
+
+	ret = inv_icm42600_core_probe(regmap, chip, client->irq, inv_icm42600_i2c_bus_setup);
+
+    printk("%s:%d, ACHEUL, ret: %d", __FUNCTION__, __LINE__, ret);
+    return ret;
+
+}// inv_icm42600_probe
+
+static const struct of_device_id inv_icm42600_of_matches[] = {
+	{
+		.compatible = "invensense,icm42600",
+		.data = (void *)INV_CHIP_ICM42600,
+	}, {
+		.compatible = "invensense,icm42602",
+		.data = (void *)INV_CHIP_ICM42602,
+	}, {
+		.compatible = "invensense,icm42605",
+		.data = (void *)INV_CHIP_ICM42605,
+	}, {
+		.compatible = "invensense,icm42622",
+		.data = (void *)INV_CHIP_ICM42622,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, inv_icm42600_of_matches);
+
+static struct i2c_driver inv_icm42600_driver = {
+	.driver = {
+		.name = "inv-icm42600-i2c",
+		.of_match_table = inv_icm42600_of_matches,
+		.pm = &inv_icm42600_pm_ops,
+	},
+	.probe_new = inv_icm42600_probe,
+};
+module_i2c_driver(inv_icm42600_driver);
+
+MODULE_AUTHOR("InvenSense, Inc.");
+MODULE_DESCRIPTION("InvenSense ICM-426xx I2C driver");
+MODULE_LICENSE("GPL");
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_spi.c msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_spi.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_spi.c	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_spi.c	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 InvenSense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/spi/spi.h>
+#include <linux/regmap.h>
+#include <linux/property.h>
+
+#include "inv_icm42600.h"
+
+static int inv_icm42600_spi_bus_setup(struct inv_icm42600_state *st)
+{
+	unsigned int mask, val;
+	int ret;
+
+	/* setup interface registers */
+	val = INV_ICM42600_INTF_CONFIG6_I3C_EN |
+	      INV_ICM42600_INTF_CONFIG6_I3C_SDR_EN |
+	      INV_ICM42600_INTF_CONFIG6_I3C_DDR_EN;
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG6,
+				 INV_ICM42600_INTF_CONFIG6_MASK, val);
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG4,
+				 INV_ICM42600_INTF_CONFIG4_I3C_BUS_ONLY, 0);
+	if (ret)
+		return ret;
+
+	/* set slew rates for I2C and SPI */
+	mask = INV_ICM42600_DRIVE_CONFIG_I2C_MASK |
+	       INV_ICM42600_DRIVE_CONFIG_SPI_MASK;
+	val = INV_ICM42600_DRIVE_CONFIG_I2C(INV_ICM42600_SLEW_RATE_20_60NS) |
+	      INV_ICM42600_DRIVE_CONFIG_SPI(INV_ICM42600_SLEW_RATE_INF_2NS);
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_DRIVE_CONFIG,
+				 mask, val);
+	if (ret)
+		return ret;
+
+	/* disable i2c bus */
+	return regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG0,
+				  INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_MASK,
+				  INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_I2C_DIS);
+}
+
+static int inv_icm42600_probe(struct spi_device *spi)
+{
+	const void *match;
+	enum inv_icm42600_chip chip;
+	struct regmap *regmap;
+
+	match = device_get_match_data(&spi->dev);
+	if (!match)
+		return -EINVAL;
+	chip = (enum inv_icm42600_chip)match;
+
+	regmap = devm_regmap_init_spi(spi, &inv_icm42600_regmap_config);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return inv_icm42600_core_probe(regmap, chip, spi->irq,
+				       inv_icm42600_spi_bus_setup);
+}
+
+static const struct of_device_id inv_icm42600_of_matches[] = {
+	{
+		.compatible = "invensense,icm42600",
+		.data = (void *)INV_CHIP_ICM42600,
+	}, {
+		.compatible = "invensense,icm42602",
+		.data = (void *)INV_CHIP_ICM42602,
+	}, {
+		.compatible = "invensense,icm42605",
+		.data = (void *)INV_CHIP_ICM42605,
+	}, {
+		.compatible = "invensense,icm42622",
+		.data = (void *)INV_CHIP_ICM42622,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, inv_icm42600_of_matches);
+
+static struct spi_driver inv_icm42600_driver = {
+	.driver = {
+		.name = "inv-icm42600-spi",
+		.of_match_table = inv_icm42600_of_matches,
+		.pm = &inv_icm42600_pm_ops,
+	},
+	.probe = inv_icm42600_probe,
+};
+module_spi_driver(inv_icm42600_driver);
+
+MODULE_AUTHOR("InvenSense, Inc.");
+MODULE_DESCRIPTION("InvenSense ICM-426xx SPI driver");
+MODULE_LICENSE("GPL");
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_temp.c msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_temp.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_temp.c	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_temp.c	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,84 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/iio/iio.h>
+
+#include "inv_icm42600.h"
+#include "inv_icm42600_temp.h"
+
+static int inv_icm42600_temp_read(struct inv_icm42600_state *st, int16_t *temp)
+{
+	struct device *dev = regmap_get_device(st->map);
+	__be16 *raw;
+	int ret;
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_set_temp_conf(st, true, NULL);
+	if (ret)
+		goto exit;
+
+	raw = (__be16 *)&st->buffer[0];
+	ret = regmap_bulk_read(st->map, INV_ICM42600_REG_TEMP_DATA, raw, sizeof(*raw));
+	if (ret)
+		goto exit;
+
+	*temp = (int16_t)be16_to_cpup(raw);
+	if (*temp == INV_ICM42600_DATA_INVALID)
+		ret = -EINVAL;
+
+exit:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+int inv_icm42600_temp_read_raw(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan,
+			       int *val, int *val2, long mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int16_t temp;
+	int ret;
+
+	if (chan->type != IIO_TEMP)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_temp_read(st, &temp);
+		iio_device_release_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		*val = temp;
+		return IIO_VAL_INT;
+	/*
+	 * T°C = (temp / 132.48) + 25
+	 * Tm°C = 1000 * ((temp * 100 / 13248) + 25)
+	 * scale: 100000 / 13248 ~= 7.548309
+	 * offset: 25000
+	 */
+	case IIO_CHAN_INFO_SCALE:
+		*val = 7;
+		*val2 = 548309;
+		return IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_OFFSET:
+		*val = 25000;
+		return IIO_VAL_INT;
+	default:
+		return -EINVAL;
+	}
+}
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_temp.h msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_temp.h
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_temp.h	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_temp.h	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#ifndef INV_ICM42600_TEMP_H_
+#define INV_ICM42600_TEMP_H_
+
+#include <linux/iio/iio.h>
+
+#define INV_ICM42600_TEMP_CHAN(_index)					\
+	{								\
+		.type = IIO_TEMP,					\
+		.info_mask_separate =					\
+			BIT(IIO_CHAN_INFO_RAW) |			\
+			BIT(IIO_CHAN_INFO_OFFSET) |			\
+			BIT(IIO_CHAN_INFO_SCALE),			\
+		.scan_index = _index,					\
+		.scan_type = {						\
+			.sign = 's',					\
+			.realbits = 16,					\
+			.storagebits = 16,				\
+		},							\
+	}
+
+int inv_icm42600_temp_read_raw(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan,
+			       int *val, int *val2, long mask);
+
+#endif
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_timestamp.c msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_timestamp.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_timestamp.c	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_timestamp.c	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,195 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/regmap.h>
+#include <linux/math64.h>
+
+#include "inv_icm42600.h"
+#include "inv_icm42600_timestamp.h"
+
+/* internal chip period is 32kHz, 31250ns */
+#define INV_ICM42600_TIMESTAMP_PERIOD		31250
+/* allow a jitter of +/- 2% */
+#define INV_ICM42600_TIMESTAMP_JITTER		2
+/* compute min and max periods accepted */
+#define INV_ICM42600_TIMESTAMP_MIN_PERIOD(_p)		\
+	(((_p) * (100 - INV_ICM42600_TIMESTAMP_JITTER)) / 100)
+#define INV_ICM42600_TIMESTAMP_MAX_PERIOD(_p)		\
+	(((_p) * (100 + INV_ICM42600_TIMESTAMP_JITTER)) / 100)
+
+/* Add a new value inside an accumulator and update the estimate value */
+static void inv_update_acc(struct inv_icm42600_timestamp_acc *acc, uint32_t val)
+{
+	uint64_t sum = 0;
+	size_t i;
+
+	acc->values[acc->idx++] = val;
+	if (acc->idx >= ARRAY_SIZE(acc->values))
+		acc->idx = 0;
+
+	/* compute the mean of all stored values, use 0 as empty slot */
+	for (i = 0; i < ARRAY_SIZE(acc->values); ++i) {
+		if (acc->values[i] == 0)
+			break;
+		sum += acc->values[i];
+	}
+
+	acc->val = div_u64(sum, i);
+}
+
+void inv_icm42600_timestamp_init(struct inv_icm42600_timestamp *ts,
+				 uint32_t period)
+{
+	/* initial odr for sensor after reset is 1kHz */
+	const uint32_t default_period = 1000000;
+
+	/* current multiplier and period values after reset */
+	ts->mult = default_period / INV_ICM42600_TIMESTAMP_PERIOD;
+	ts->period = default_period;
+	/* new set multiplier is the one from chip initialization */
+	ts->new_mult = period / INV_ICM42600_TIMESTAMP_PERIOD;
+
+	/* use theoretical value for chip period */
+	inv_update_acc(&ts->chip_period, INV_ICM42600_TIMESTAMP_PERIOD);
+}
+
+int inv_icm42600_timestamp_setup(struct inv_icm42600_state *st)
+{
+	unsigned int val;
+
+	/* enable timestamp register */
+	val = INV_ICM42600_TMST_CONFIG_TMST_TO_REGS_EN |
+	      INV_ICM42600_TMST_CONFIG_TMST_EN;
+	return regmap_update_bits(st->map, INV_ICM42600_REG_TMST_CONFIG,
+				  INV_ICM42600_TMST_CONFIG_MASK, val);
+}
+
+int inv_icm42600_timestamp_update_odr(struct inv_icm42600_timestamp *ts,
+				      uint32_t period, bool fifo)
+{
+	/* when FIFO is on, prevent odr change if one is already pending */
+	if (fifo && ts->new_mult != 0)
+		return -EAGAIN;
+
+	ts->new_mult = period / INV_ICM42600_TIMESTAMP_PERIOD;
+
+	return 0;
+}
+
+static bool inv_validate_period(uint32_t period, uint32_t mult)
+{
+	const uint32_t chip_period = INV_ICM42600_TIMESTAMP_PERIOD;
+	uint32_t period_min, period_max;
+
+	/* check that period is acceptable */
+	period_min = INV_ICM42600_TIMESTAMP_MIN_PERIOD(chip_period) * mult;
+	period_max = INV_ICM42600_TIMESTAMP_MAX_PERIOD(chip_period) * mult;
+	if (period > period_min && period < period_max)
+		return true;
+	else
+		return false;
+}
+
+static bool inv_compute_chip_period(struct inv_icm42600_timestamp *ts,
+				    uint32_t mult, uint32_t period)
+{
+	uint32_t new_chip_period;
+
+	if (!inv_validate_period(period, mult))
+		return false;
+
+	/* update chip internal period estimation */
+	new_chip_period = period / mult;
+	inv_update_acc(&ts->chip_period, new_chip_period);
+
+	return true;
+}
+
+void inv_icm42600_timestamp_interrupt(struct inv_icm42600_timestamp *ts,
+				      uint32_t fifo_period, size_t fifo_nb,
+				      size_t sensor_nb, int64_t timestamp)
+{
+	struct inv_icm42600_timestamp_interval *it;
+	int64_t delta, interval;
+	const uint32_t fifo_mult = fifo_period / INV_ICM42600_TIMESTAMP_PERIOD;
+	uint32_t period = ts->period;
+	int32_t m;
+	bool valid = false;
+
+	if (fifo_nb == 0)
+		return;
+
+	/* update interrupt timestamp and compute chip and sensor periods */
+	it = &ts->it;
+	it->lo = it->up;
+	it->up = timestamp;
+	delta = it->up - it->lo;
+	if (it->lo != 0) {
+		/* compute period: delta time divided by number of samples */
+		period = div_s64(delta, fifo_nb);
+		valid = inv_compute_chip_period(ts, fifo_mult, period);
+		/* update sensor period if chip internal period is updated */
+		if (valid)
+			ts->period = ts->mult * ts->chip_period.val;
+	}
+
+	/* no previous data, compute theoritical value from interrupt */
+	if (ts->timestamp == 0) {
+		/* elapsed time: sensor period * sensor samples number */
+		interval = (int64_t)ts->period * (int64_t)sensor_nb;
+		ts->timestamp = it->up - interval;
+		return;
+	}
+
+	/* if interrupt interval is valid, sync with interrupt timestamp */
+	if (valid) {
+		/* compute measured fifo_period */
+		fifo_period = fifo_mult * ts->chip_period.val;
+		/* delta time between last sample and last interrupt */
+		delta = it->lo - ts->timestamp;
+		/* if there are multiple samples, go back to first one */
+		while (delta >= (fifo_period * 3 / 2))
+			delta -= fifo_period;
+		/* compute maximal adjustment value */
+		m = INV_ICM42600_TIMESTAMP_MAX_PERIOD(ts->period) - ts->period;
+		if (delta > m)
+			delta = m;
+		else if (delta < -m)
+			delta = -m;
+		ts->timestamp += delta;
+	}
+}
+
+void inv_icm42600_timestamp_apply_odr(struct inv_icm42600_timestamp *ts,
+				      uint32_t fifo_period, size_t fifo_nb,
+				      unsigned int fifo_no)
+{
+	int64_t interval;
+	uint32_t fifo_mult;
+
+	if (ts->new_mult == 0)
+		return;
+
+	/* update to new multiplier and update period */
+	ts->mult = ts->new_mult;
+	ts->new_mult = 0;
+	ts->period = ts->mult * ts->chip_period.val;
+
+	/*
+	 * After ODR change the time interval with the previous sample is
+	 * undertermined (depends when the change occures). So we compute the
+	 * timestamp from the current interrupt using the new FIFO period, the
+	 * total number of samples and the current sample numero.
+	 */
+	if (ts->timestamp != 0) {
+		/* compute measured fifo period */
+		fifo_mult = fifo_period / INV_ICM42600_TIMESTAMP_PERIOD;
+		fifo_period = fifo_mult * ts->chip_period.val;
+		/* computes time interval between interrupt and this sample */
+		interval = (int64_t)(fifo_nb - fifo_no) * (int64_t)fifo_period;
+		ts->timestamp = ts->it.up - interval;
+	}
+}
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_timestamp.h msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_timestamp.h
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_timestamp.h	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_timestamp.h	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,85 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#ifndef INV_ICM42600_TIMESTAMP_H_
+#define INV_ICM42600_TIMESTAMP_H_
+
+#include <linux/kernel.h>
+
+struct inv_icm42600_state;
+
+/**
+ * struct inv_icm42600_timestamp_interval - timestamps interval
+ * @lo:	interval lower bound
+ * @up:	interval upper bound
+ */
+struct inv_icm42600_timestamp_interval {
+	int64_t lo;
+	int64_t up;
+};
+
+/**
+ * struct inv_icm42600_timestamp_acc - accumulator for computing an estimation
+ * @val:	current estimation of the value, the mean of all values
+ * @idx:	current index of the next free place in values table
+ * @values:	table of all measured values, use for computing the mean
+ */
+struct inv_icm42600_timestamp_acc {
+	uint32_t val;
+	size_t idx;
+	uint32_t values[32];
+};
+
+/**
+ * struct inv_icm42600_timestamp - timestamp management states
+ * @it:			interrupts interval timestamps
+ * @timestamp:		store last timestamp for computing next data timestamp
+ * @mult:		current internal period multiplier
+ * @new_mult:		new set internal period multiplier (not yet effective)
+ * @period:		measured current period of the sensor
+ * @chip_period:	accumulator for computing internal chip period
+ */
+struct inv_icm42600_timestamp {
+	struct inv_icm42600_timestamp_interval it;
+	int64_t timestamp;
+	uint32_t mult;
+	uint32_t new_mult;
+	uint32_t period;
+	struct inv_icm42600_timestamp_acc chip_period;
+};
+
+void inv_icm42600_timestamp_init(struct inv_icm42600_timestamp *ts,
+				 uint32_t period);
+
+int inv_icm42600_timestamp_setup(struct inv_icm42600_state *st);
+
+int inv_icm42600_timestamp_update_odr(struct inv_icm42600_timestamp *ts,
+				      uint32_t period, bool fifo);
+
+void inv_icm42600_timestamp_interrupt(struct inv_icm42600_timestamp *ts,
+				      uint32_t fifo_period, size_t fifo_nb,
+				      size_t sensor_nb, int64_t timestamp);
+
+static inline int64_t
+inv_icm42600_timestamp_pop(struct inv_icm42600_timestamp *ts)
+{
+	ts->timestamp += ts->period;
+	return ts->timestamp;
+}
+
+void inv_icm42600_timestamp_apply_odr(struct inv_icm42600_timestamp *ts,
+				      uint32_t fifo_period, size_t fifo_nb,
+				      unsigned int fifo_no);
+
+static inline void
+inv_icm42600_timestamp_reset(struct inv_icm42600_timestamp *ts)
+{
+	const struct inv_icm42600_timestamp_interval interval_init = {0LL, 0LL};
+
+	ts->it = interval_init;
+	ts->timestamp = 0;
+}
+
+#endif
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: inv_mpu6050
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: kmx61.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/imu: st_lsm6dsx
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-buffer.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-configfs.c
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/industrialio-core.c msm-4.19/drivers/iio/industrialio-core.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/industrialio-core.c	2024-04-16 19:14:58.668044968 +0000
+++ msm-4.19/drivers/iio/industrialio-core.c	2024-04-20 18:36:20.826499294 +0000
@@ -1446,6 +1446,8 @@
 	struct iio_dev *dev;
 	size_t alloc_size;
 
+    printk("%s:%d, ACHEUL, size: %d", __FUNCTION__, __LINE__, sizeof_priv);
+
 	alloc_size = sizeof(struct iio_dev);
 	if (sizeof_priv) {
 		alloc_size = ALIGN(alloc_size, IIO_ALIGN);
@@ -1454,9 +1456,14 @@
 	/* ensure 32-byte alignment of whole construct ? */
 	alloc_size += IIO_ALIGN - 1;
 
+    printk("%s:%d, ACHEUL, real size: %d", __FUNCTION__, __LINE__, alloc_size);
+
 	dev = kzalloc(alloc_size, GFP_KERNEL);
 
 	if (dev) {
+
+
+        printk("%s:%d, ACHEUL pointer OK", __FUNCTION__, __LINE__);
 		dev->dev.groups = dev->groups;
 		dev->dev.type = &iio_device_type;
 		dev->dev.bus = &iio_bus_type;
@@ -1466,6 +1473,7 @@
 		mutex_init(&dev->info_exist_lock);
 		INIT_LIST_HEAD(&dev->channel_attr_list);
 
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 		dev->id = ida_simple_get(&iio_ida, 0, 0, GFP_KERNEL);
 		if (dev->id < 0) {
 			/* cannot use a dev_err as the name isn't available */
@@ -1473,10 +1481,13 @@
 			kfree(dev);
 			return NULL;
 		}
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 		dev_set_name(&dev->dev, "iio:device%d", dev->id);
 		INIT_LIST_HEAD(&dev->buffer_list);
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	}
 
+    printk("%s:%d, ACHEUL out", __FUNCTION__, __LINE__);
 	return dev;
 }
 EXPORT_SYMBOL(iio_device_alloc);
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-event.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-sw-device.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-sw-trigger.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-trigger.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-triggered-event.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: inkern.c
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light/Kconfig msm-4.19/drivers/iio/light/Kconfig
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light/Kconfig	2024-04-16 19:14:58.668044968 +0000
+++ msm-4.19/drivers/iio/light/Kconfig	2024-04-20 18:36:20.826499294 +0000
@@ -3,6 +3,7 @@
 # Light sensors
 #
 # When adding new entries keep the list in alphabetical order
+# ACHEUL
 
 menu "Light sensors"
 
@@ -460,6 +461,16 @@
 	 To compile this driver as a module, choose M here: the
 	 module will be called vcnl4000.
 
+config VCNL3040
+	tristate "VCNL3040 combined ALS and proximity sensor"
+	depends on I2C
+	help
+	 Say Y here if you want to build a driver for the Vishay VCNL3040,
+	 proximity sensor.
+
+	 To compile this driver as a module, choose M here: the
+	 module will be called VCNL3040.
+
 config VEML6070
 	tristate "VEML6070 UV A light sensor"
 	depends on I2C
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: acpi-als.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: adjd_s311.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: al3320a.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: apds9300.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: apds9960.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: bh1750.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: bh1780.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: cm32181.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: cm3232.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: cm3323.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: cm3605.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: cm36651.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: cros_ec_light_prox.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: gp2ap020a00f.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: hid-sensor-als.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: hid-sensor-prox.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: isl29018.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: isl29028.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: isl29125.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: jsa1212.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: lm3533-als.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: ltr501.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: lv0104cs.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: max44000.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: opt3001.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: pa12203001.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: rpr0521.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: si1133.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: si1145.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: st_uvis25.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: st_uvis25_core.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: st_uvis25_i2c.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: st_uvis25_spi.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: stk3310.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: tcs3414.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: tcs3472.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: tsl2563.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: tsl2583.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: tsl2772.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: tsl4531.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: us5182d.c
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light/vcnl4000.c msm-4.19/drivers/iio/light/vcnl4000.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light/vcnl4000.c	2024-04-16 19:14:58.676044963 +0000
+++ msm-4.19/drivers/iio/light/vcnl4000.c	2024-04-20 18:36:20.826499294 +0000
@@ -99,6 +99,17 @@
 {
 	int ret, prod_id;
 
+    char message[256];
+
+    sprintf(message, "%s:%d ACHEUL\n", __FUNCTION__, __LINE__);
+
+    printk     ("printk                         : %s", message);
+    dev_crit   (&data->client->dev, "dev_crit   : %s", message);
+    dev_err    (&data->client->dev, "dev_err    : %s", message);
+    dev_warn   (&data->client->dev, "dev_warning: %s", message);
+    dev_notice (&data->client->dev, "dev_notice : %s", message);
+    dev_info   (&data->client->dev, "dev_info   : %s", message);
+
 	ret = i2c_smbus_read_byte_data(data->client, VCNL4000_PROD_REV);
 	if (ret < 0)
 		return ret;
@@ -130,22 +141,33 @@
 {
 	int ret;
 
+    printk("%s:%d ACHEUL\n", __FUNCTION__, __LINE__);
+
 	ret = i2c_smbus_read_word_data(data->client, VCNL4200_DEV_ID);
-	if (ret < 0)
+	if (ret < 0) {
+        printk("%s:%d ACHEUL, error, failed to read i2c: %d, error: %d", __FUNCTION__, __LINE__, VCNL4200_DEV_ID, ret);
 		return ret;
+    }
 
-	if ((ret & 0xff) != VCNL4200_PROD_ID)
+	if ((ret & 0xff) != VCNL4200_PROD_ID){
+        printk("%s:%d ACHEUL, error, invalid prod id, got: 0x%02X, looking for: 0x%02X", __FUNCTION__, __LINE__, ret & 0xFF,  VCNL4200_PROD_ID);
 		return -ENODEV;
+    }
 
 	data->rev = (ret >> 8) & 0xf;
 
 	/* Set defaults and enable both channels */
 	ret = i2c_smbus_write_byte_data(data->client, VCNL4200_AL_CONF, 0x00);
-	if (ret < 0)
+	if (ret < 0) {
+        printk("%s:%d ACHEUL, error, invalid VCNL4200_AL_CONF: 0x%02X", __FUNCTION__, __LINE__, VCNL4200_AL_CONF);
 		return ret;
+    };
+
 	ret = i2c_smbus_write_byte_data(data->client, VCNL4200_PS_CONF1, 0x00);
-	if (ret < 0)
+	if (ret < 0) {
+        printk("%s:%d ACHEUL, error, invalid VCNL4200_PS_CONF1: 0x%02X", __FUNCTION__, __LINE__, VCNL4200_PS_CONF1);
 		return ret;
+    }
 
 	data->al_scale = 24000;
 	data->vcnl4200_al.reg = VCNL4200_AL_DATA;
@@ -158,6 +180,7 @@
 	mutex_init(&data->vcnl4200_al.lock);
 	mutex_init(&data->vcnl4200_ps.lock);
 
+    printk("%s:%d ACHEUL success\n", __FUNCTION__, __LINE__);
 	return 0;
 };
 
@@ -167,6 +190,7 @@
 	int tries = 20;
 	__be16 buf;
 	int ret;
+    printk("%s:%d ACHEUL\n", __FUNCTION__, __LINE__);
 
 	mutex_lock(&data->vcnl4000_lock);
 
@@ -213,6 +237,7 @@
 	int ret;
 	s64 delta;
 	ktime_t next_measurement;
+    printk("%s:%d ACHEUL\n", __FUNCTION__, __LINE__);
 
 	mutex_lock(&chan->lock);
 
@@ -336,22 +361,28 @@
 	struct iio_dev *indio_dev;
 	int ret;
 
+    printk ("%s: %d: ACHEUL", __FUNCTION__, __LINE__);
+
 	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
 	if (!indio_dev)
 		return -ENOMEM;
 
+    printk ("%s: %d: ACHEUL", __FUNCTION__, __LINE__);
+
 	data = iio_priv(indio_dev);
 	i2c_set_clientdata(client, indio_dev);
 	data->client = client;
 	data->id = id->driver_data;
 	data->chip_spec = &vcnl4000_chip_spec_cfg[data->id];
 
+    printk ("%s: %d: ACHEUL", __FUNCTION__, __LINE__);
 	ret = data->chip_spec->init(data);
-	if (ret < 0)
+	if (ret < 0){
+        printk("%s: %d, ACHEUL error init: %d", __FUNCTION__, __LINE__, ret);
 		return ret;
+    }
 
-	dev_dbg(&client->dev, "%s Ambient light/proximity sensor, Rev: %02x\n",
-		data->chip_spec->prod, data->rev);
+	printk("%s: %d, ACHEUL, %s Ambient light/proximity sensor, Rev: %02x", __FUNCTION__, __LINE__, data->chip_spec->prod, data->rev);
 
 	indio_dev->dev.parent = &client->dev;
 	indio_dev->info = &vcnl4000_info;
@@ -360,7 +391,11 @@
 	indio_dev->name = VCNL4000_DRV_NAME;
 	indio_dev->modes = INDIO_DIRECT_MODE;
 
-	return devm_iio_device_register(&client->dev, indio_dev);
+    printk ("%s:%d, before geristering device", __FUNCTION__, __LINE__);
+    ret = devm_iio_device_register(&client->dev, indio_dev);
+
+    printk ("%s:%d, device registered: %d", __FUNCTION__, __LINE__, ret);
+	return ret;
 }
 
 static struct i2c_driver vcnl4000_driver = {
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: veml6070.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: vl6180.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/light: zopt2201.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: magnetometer
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: multiplexer
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: orientation
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: potentiometer
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: potentiostat
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: pressure
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/Kconfig msm-4.19/drivers/iio/proximity/Kconfig
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/Kconfig	2024-04-16 19:14:58.680044960 +0000
+++ msm-4.19/drivers/iio/proximity/Kconfig	2024-04-20 18:36:20.826499294 +0000
@@ -1,9 +1,21 @@
 #
 # Proximity sensors
 #
+# ACHEUL
 
 menu "Lightning sensors"
 
+config VCNL3040
+	tristate "VCNL3040 combined ALS and proximity sensor"
+    select REGMAP_I2C
+	depends on I2C
+	help
+	 Say Y here if you want to build a driver for the Vishay VCNL3040,
+	 proximity sensor.
+
+	 To compile this driver as a module, choose M here: the
+	 module will be called VCNL3040.
+
 config AS3935
 	tristate "AS3935 Franklin lightning sensor"
 	select IIO_BUFFER
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/Makefile msm-4.19/drivers/iio/proximity/Makefile
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/Makefile	2024-04-16 19:14:58.680044960 +0000
+++ msm-4.19/drivers/iio/proximity/Makefile	2024-04-20 18:36:20.826499294 +0000
@@ -2,12 +2,13 @@
 #
 # Makefile for IIO proximity sensors
 #
-
+# ACHEUL
 # When adding new entries keep the list in alphabetical order
 obj-$(CONFIG_AS3935)		+= as3935.o
 obj-$(CONFIG_ISL29501)		+= isl29501.o
 obj-$(CONFIG_LIDAR_LITE_V2)	+= pulsedlight-lidar-lite-v2.o
 obj-$(CONFIG_RFD77402)		+= rfd77402.o
-obj-$(CONFIG_SRF04)		+= srf04.o
-obj-$(CONFIG_SRF08)		+= srf08.o
+obj-$(CONFIG_SRF04)		    += srf04.o
+obj-$(CONFIG_SRF08)		    += srf08.o
 obj-$(CONFIG_SX9500)		+= sx9500.o
+obj-$(CONFIG_VCNL3040)      += vcnl3040.o
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: as3935.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: isl29501.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: pulsedlight-lidar-lite-v2.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: rfd77402.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: srf04.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: srf08.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: sx9500.c
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/vcnl3040.c msm-4.19/drivers/iio/proximity/vcnl3040.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/vcnl3040.c	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/iio/proximity/vcnl3040.c	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,694 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Support for Vishay VCNL3040 proximity sensor on i2c bus.
+ * Based on Vishay VCNL4000 driver code.
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/regmap.h>
+#include <linux/interrupt.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/events.h>
+
+#define VCNL3040_PROD_ID	0x0186
+#define LED_MASK_VALUE      0xF8FF
+
+enum VCNL3040_REGS {
+    PS_CONF1_2   = 0x03,
+    PS_CONF3_MS  = 0x04,
+    PS_CANCEL    = 0x05,
+    PS_LOW_THDL  = 0x06,
+    PS_HIGH_THDL = 0x07,
+    PS_DATA      = 0x08,
+    INT_FLAGS    = 0x0B,
+    DEVICE_ID    = 0x0C
+};
+
+enum VCNL3040_PARAM
+{
+    ///LED current settings
+    LED_CURRENT_50mA = 0x00,
+    LED_CURRENT_75mA = 0x01,
+    LED_CURRENT_120mA = 0x02,
+    LED_CURRENT_140mA = 0x03,
+    LED_CURRENT_160mA = 0x04,
+    LED_CURRENT_180mA = 0x05,
+    LED_CURRENT_200mA = 0x07,
+
+    ///Duty cycle for sensors LED
+    PS_DUTY_40 = 0x00,
+    PS_DUTY_80 = 0x01,
+    PS_DUTY_160 = 0x02,
+    PS_DUTY_320 = 0x03,
+
+    ///Measurement integration time 1T0 - IT = 1 -  125us (application note page 5 )
+    PS_IT_1T0 = 0x00,
+    PS_IT_1T5 = 0x01,
+    PS_IT_2T0 = 0x02,
+    PS_IT_2T5 = 0x03,
+    PS_IT_3T0 = 0x04,
+    PS_IT_3T5 = 0x05,
+    PS_IT_4T0 = 0x06,
+    PS_IT_8T0 = 0x07,
+
+    ///Interupt persistance setting - how many consecutive measruements
+    ///have to be made in interupt range to trigger interupt (datasheet page 11)
+    PS_PERS_1 = 0x00,
+    PS_PERS_2 = 0x01,
+    PS_PERS_3 = 0x02,
+    PS_PERS_4 = 0x03,
+
+    ///Iterupt modes
+    PS_INT_DISABLED = 0x00,
+    PS_INT_CLOSING = 0x01,
+    PS_INT_AWAY = 0x02,
+    PS_INT_CLOSING_AWAY = 0x03,
+};
+
+
+#define VCNL_COMMAND		0x80 /* Command register */
+#define VCNL_PROD_REV		0x81 /* Product ID and Revision ID */
+#define VCNL_PROXIMITY_RATE	0x82 /* Rate of Proximity Measurement */
+#define VCNL_LED_CURRENT	0x83 /* IR LED current for proximity mode */
+#define VCNL_PS_RESULT_HI	0x87 /* Proximity result register, MSB */
+#define VCNL_PS_RESULT_LO	0x88 /* Proximity result register, LSB */
+#define VCNL_PS_ICR		    0x89 /* Interrupt Control Register */
+#define VCNL_PS_LO_THR_HI	0x8a /* High byte of low threshold value */
+#define VCNL_PS_LO_THR_LO	0x8b /* Low byte of low threshold value */
+#define VCNL_PS_HI_THR_HI	0x8c /* High byte of high threshold value */
+#define VCNL_PS_HI_THR_LO	0x8d /* Low byte of high threshold value */
+#define VCNL_ISR		    0x8e /* Interrupt Status Register */
+#define VCNL_PS_MOD_ADJ		0x8f /* Proximity Modulator Timing Adjustment */
+
+/* Bit masks for COMMAND register */
+#define VCNL_PS_RDY		BIT(5) /* proximity data ready? */
+#define VCNL_PS_OD		BIT(3) /* start on-demand proximity
+					* measurement
+					*/
+
+/* Enables periodic proximity measurement */
+#define VCNL_PS_EN		BIT(1)
+
+/* Enables state machine and LP oscillator for self timed  measurements */
+#define VCNL_PS_SELFTIMED_EN	BIT(0)
+
+/* Bit masks for ICR */
+
+/* Enable interrupts on low or high thresholds */
+#define  VCNL_ICR_THRES_EN	BIT(1)
+
+/* Bit masks for ISR */
+#define VCNL_INT_TH_HI		BIT(0)	/* High threshold hit */
+#define VCNL_INT_TH_LOW		BIT(1)	/* Low threshold hit */
+
+#define VCNL_ON_DEMAND_TIMEOUT_US	100000
+#define VCNL_POLL_US			20000
+
+static const int vcnl3040_prox_sampling_frequency[][2] = {
+	{1, 950000},
+	{3, 906250},
+	{7, 812500},
+	{16, 625000},
+	{31, 250000},
+	{62, 500000},
+	{125, 0},
+	{250, 0},
+};
+
+/**
+ * struct vcnl3040_data - vcnl3040 specific data.
+ * @regmap:	device register map.
+ * @dev:	vcnl3040 device.
+ * @rev:	revision id.
+ * @lock:	lock for protecting access to device hardware registers.
+ * @buf:	DMA safe __be16 buffer.
+ */
+struct vcnl3040_data {
+	struct regmap *regmap;
+	struct device *dev;
+    struct i2c_client *client;
+	u8 rev;
+	struct mutex lock;
+	__be16 buf ____cacheline_aligned;
+};
+
+/**
+ * struct vcnl3040_property - vcnl3040 property.
+ * @name:	property name.
+ * @reg:	i2c register offset.
+ * @conversion_func:	conversion function.
+ */
+struct vcnl3040_property {
+	const char *name;
+	u32 reg;
+	u32 (*conversion_func)(u32 *val);
+};
+
+uint16_t vcnl3040_read_register(struct vcnl3040_data *data, uint8_t reg){
+
+    uint16_t ret;
+
+	ret = i2c_smbus_read_word_data(data->client, reg);
+
+    //printk("%s:%d, ACHEUL reading vcnl3040 reg[0x%02X]: 0x%04X", __FUNCTION__, __LINE__, reg, ret);
+
+    return ret;
+}// vcnl3040_read_register
+
+uint16_t vcnl3040_write_register(struct vcnl3040_data *data, uint8_t reg, uint16_t value){
+
+    uint16_t ret;
+
+	ret = i2c_smbus_write_word_data(data->client, reg, value);
+
+    //printk("%s:%d, ACHEUL writing vcnl3040 reg[0x%02X]: 0x%04X, ret: %d", __FUNCTION__, __LINE__, reg, value, ret);
+
+    return ret;
+}// vcnl3040_write_register
+
+uint16_t vcnl3040_read_sensor(struct vcnl3040_data *data) {
+
+    uint16_t sensor_value = vcnl3040_read_register(data, PS_DATA);
+
+    printk("%s:%d, ACHEUL, sensor value 0x%04X", __FUNCTION__, __LINE__, sensor_value);
+
+    return sensor_value;
+}// vcnl3040_read_sensor
+
+static int vcnl3040_start(struct vcnl3040_data *data) {
+    uint16_t current_settings = vcnl3040_read_register(data, PS_CONF1_2);
+    uint16_t new_settings     = current_settings & 0xFFFE;
+
+    printk("%s:%d, ACHEUL, starting proximity sensor from: 0x%04X to 0x%04X", __FUNCTION__, __LINE__, current_settings, new_settings);
+
+    vcnl3040_write_register(data, PS_CONF1_2, new_settings);
+
+    return 0;
+}// vcnl3040_start
+
+#if 0
+static int vcnl3040_stop(struct vcnl3040_data *data) {
+    uint16_t current_settings = vcnl3040_read_register(data, PS_CONF3_MS);
+    uint16_t new_settings     = current_settings | 0x0001;
+
+    printk("%s:%d, ACHEUL, stopping proximity sensor from: 0x%04X to 0x%04X", __FUNCTION__, __LINE__, current_settings, new_settings);
+
+    vcnl3040_write_register(data, PS_CONF3_MS, new_settings);
+
+    return 0;
+}// vcnl3040_stop
+#endif // 0
+
+static int vcnl3040_show_config(struct vcnl3040_data *data) {
+    uint16_t config;
+    uint8_t  i;
+
+    printk("%s:%d, ACHEUL, =============================================", __FUNCTION__, __LINE__);
+    for (i = PS_CONF1_2; i <= PS_HIGH_THDL; i++) {
+
+        config = vcnl3040_read_register(data, i);
+        printk("%s:%d, ACHEUL, config: 0x%02X: 0x%04X", __FUNCTION__, __LINE__, i, config);
+    }
+    printk("%s:%d, ACHEUL, =============================================", __FUNCTION__, __LINE__);
+
+    return 0;
+
+}// vcnl3040_show_config
+
+static int vcnl3040_set_led(struct vcnl3040_data *data, uint8_t led_setting) {
+    uint16_t current_led_setting = vcnl3040_read_register(data, PS_CONF3_MS) | LED_MASK_VALUE;
+    uint16_t new_led_setting     = current_led_setting | (led_setting << 8);
+
+    printk("%s:%d, ACHEUL, setting led from: 0x%04X to 0x%04X", __FUNCTION__, __LINE__, current_led_setting, new_led_setting);
+
+    vcnl3040_write_register(data, PS_CONF3_MS, new_led_setting);
+
+    return 0;
+}// vcnl3040_set_led
+
+static int vcnl3040_init(struct vcnl3040_data *data) {
+	uint16_t reg;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+    reg = vcnl3040_read_register(data, DEVICE_ID);
+
+    if (reg != VCNL3040_PROD_ID) {
+        printk("%s:%d, ACHEUL invalid product id: 0x%04X, looking for: 0x%04X", __FUNCTION__, __LINE__, reg, VCNL3040_PROD_ID);
+		return -ENODEV;
+    }
+
+    vcnl3040_write_register(data, PS_CONF1_2  , 0x0003); // PS shut down 0x0001, PS_IT = (0 : 0 : 1) = 1.5T 0x0002
+    vcnl3040_write_register(data, PS_CONF3_MS , 0x0000);
+    vcnl3040_write_register(data, PS_CANCEL   , 0x0000);
+    vcnl3040_write_register(data, PS_LOW_THDL , 0x0000);
+    vcnl3040_write_register(data, PS_HIGH_THDL, 0x0000);
+
+    vcnl3040_set_led(data, LED_CURRENT_200mA);
+    vcnl3040_start  (data);
+
+    vcnl3040_show_config(data);
+    return 0;
+} // vcnl3040_init
+
+static int vcnl3040_read_proxy_samp_freq(struct vcnl3040_data *data, int *val, int *val2)
+{
+	int rc;
+	unsigned int prox_rate;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	rc = regmap_read(data->regmap, VCNL_PROXIMITY_RATE, &prox_rate);
+	if (rc)
+		return rc;
+
+	if (prox_rate >= ARRAY_SIZE(vcnl3040_prox_sampling_frequency))
+		return -EINVAL;
+
+	*val = vcnl3040_prox_sampling_frequency[prox_rate][0];
+	*val2 = vcnl3040_prox_sampling_frequency[prox_rate][1];
+
+	return 0;
+}
+
+static bool vcnl3040_is_thr_enabled(struct vcnl3040_data *data)
+{
+	int rc;
+	unsigned int icr;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	rc = regmap_read(data->regmap, VCNL_PS_ICR, &icr);
+	if (rc) {
+		dev_err(data->dev,
+			"Error (%d) reading ICR register\n", rc);
+		return false;
+	}
+
+	return !!(icr & VCNL_ICR_THRES_EN);
+}
+
+static int vcnl3040_read_event(struct iio_dev *indio_dev,
+			       const struct iio_chan_spec *chan,
+			       enum iio_event_type type,
+			       enum iio_event_direction dir,
+			       enum iio_event_info info,
+			       int *val, int *val2)
+{
+	int rc;
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	switch (info) {
+	case IIO_EV_INFO_VALUE:
+		switch (dir) {
+		case IIO_EV_DIR_RISING:
+			rc = regmap_bulk_read(data->regmap, VCNL_PS_HI_THR_HI,
+					      &data->buf, sizeof(data->buf));
+			if (rc < 0)
+				return rc;
+			*val = be16_to_cpu(data->buf);
+			return IIO_VAL_INT;
+		case IIO_EV_DIR_FALLING:
+			rc = regmap_bulk_read(data->regmap, VCNL_PS_LO_THR_HI,
+					      &data->buf, sizeof(data->buf));
+			if (rc < 0)
+				return rc;
+			*val = be16_to_cpu(data->buf);
+			return IIO_VAL_INT;
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+}
+
+static int vcnl3040_write_event(struct iio_dev *indio_dev,
+				const struct iio_chan_spec *chan,
+				enum iio_event_type type,
+				enum iio_event_direction dir,
+				enum iio_event_info info,
+				int val, int val2)
+{
+	int rc;
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	mutex_lock(&data->lock);
+
+	switch (info) {
+	case IIO_EV_INFO_VALUE:
+		switch (dir) {
+		case IIO_EV_DIR_RISING:
+			/* 16 bit word/ low * high */
+			data->buf = cpu_to_be16(val);
+			rc = regmap_bulk_write(data->regmap, VCNL_PS_HI_THR_HI,
+					       &data->buf, sizeof(data->buf));
+			if (rc < 0)
+				goto err_unlock;
+			rc = IIO_VAL_INT;
+			goto err_unlock;
+		case IIO_EV_DIR_FALLING:
+			data->buf = cpu_to_be16(val);
+			rc = regmap_bulk_write(data->regmap, VCNL_PS_LO_THR_HI,
+					       &data->buf, sizeof(data->buf));
+			if (rc < 0)
+				goto err_unlock;
+			rc = IIO_VAL_INT;
+			goto err_unlock;
+		default:
+			rc = -EINVAL;
+			goto err_unlock;
+		}
+	default:
+		rc = -EINVAL;
+		goto err_unlock;
+	}
+err_unlock:
+	mutex_unlock(&data->lock);
+
+	return rc;
+}
+
+static int vcnl3040_enable_periodic(struct iio_dev *indio_dev,
+				    struct vcnl3040_data *data)
+{
+	int rc;
+	int cmd;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	mutex_lock(&data->lock);
+
+	/* Enable periodic measurement of proximity data. */
+	cmd = VCNL_PS_EN | VCNL_PS_SELFTIMED_EN;
+
+	rc = regmap_write(data->regmap, VCNL_COMMAND, cmd);
+	if (rc) {
+		dev_err(data->dev,
+			"Error (%d) writing command register\n", rc);
+		goto err_unlock;
+	}
+
+	/*
+	 * Enable interrupts on threshold, for proximity data by
+	 * default.
+	 */
+	rc = regmap_write(data->regmap, VCNL_PS_ICR, VCNL_ICR_THRES_EN);
+	if (rc)
+		dev_err(data->dev,
+			"Error (%d) reading ICR register\n", rc);
+
+err_unlock:
+	mutex_unlock(&data->lock);
+
+	return rc;
+}
+
+static int vcnl3040_disable_periodic(struct iio_dev *indio_dev,
+				     struct vcnl3040_data *data)
+{
+	int rc;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	mutex_lock(&data->lock);
+
+	rc = regmap_write(data->regmap, VCNL_COMMAND, 0);
+	if (rc) {
+		dev_err(data->dev,
+			"Error (%d) writing command register\n", rc);
+		goto err_unlock;
+	}
+
+	rc = regmap_write(data->regmap, VCNL_PS_ICR, 0);
+	if (rc) {
+		dev_err(data->dev,
+			"Error (%d) writing ICR register\n", rc);
+		goto err_unlock;
+	}
+
+	/* Clear interrupt flag bit */
+	rc = regmap_write(data->regmap, VCNL_ISR, 0);
+	if (rc)
+		dev_err(data->dev,
+			"Error (%d) writing ISR register\n", rc);
+
+err_unlock:
+	mutex_unlock(&data->lock);
+
+	return rc;
+}
+
+static int vcnl3040_config_threshold(struct iio_dev *indio_dev, bool state)
+{
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	if (state) {
+		return vcnl3040_enable_periodic(indio_dev, data);
+	} else {
+		if (!vcnl3040_is_thr_enabled(data))
+			return 0;
+		return vcnl3040_disable_periodic(indio_dev, data);
+	}
+}
+
+static int vcnl3040_write_event_config(struct iio_dev *indio_dev,
+				       const struct iio_chan_spec *chan,
+				       enum iio_event_type type,
+				       enum iio_event_direction dir,
+				       int state)
+{
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	switch (chan->type) {
+	case IIO_PROXIMITY:
+		return vcnl3040_config_threshold(indio_dev, state);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int vcnl3040_read_event_config(struct iio_dev *indio_dev,
+				      const struct iio_chan_spec *chan,
+				      enum iio_event_type type,
+				      enum iio_event_direction dir)
+{
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+
+	switch (chan->type) {
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	case IIO_PROXIMITY:
+		return vcnl3040_is_thr_enabled(data);
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct iio_event_spec vcnl3040_event_spec[] = {
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_RISING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	}, {
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_FALLING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	}, {
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_EITHER,
+		.mask_separate = BIT(IIO_EV_INFO_ENABLE),
+	},
+};
+
+static const struct iio_chan_spec vcnl3040_channels[] = {
+	{
+		.type                         = IIO_PROXIMITY,
+		.info_mask_separate           = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SAMP_FREQ),
+		.info_mask_separate_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),
+		.event_spec                   = vcnl3040_event_spec,
+		.num_event_specs              = ARRAY_SIZE(vcnl3040_event_spec),
+	},
+};
+
+static int vcnl3040_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int *val, int *val2, long mask)
+{
+	int rc;
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	switch (mask) {
+	    case IIO_CHAN_INFO_RAW:
+            *val = (int) vcnl3040_read_sensor(data);
+		    return IIO_VAL_INT;
+	    case IIO_CHAN_INFO_SAMP_FREQ:
+		    rc = vcnl3040_read_proxy_samp_freq(data, val, val2);
+		    if (rc < 0)
+			    return rc;
+		    return IIO_VAL_INT_PLUS_MICRO;
+	    default:
+		    return -EINVAL;
+	}
+}// vcnl3040_read_raw
+
+static int vcnl3040_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int val1, int val2, long mask)
+{
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+    int                   ret  = 0;
+
+    printk("%s:%d, ACHEUL, val1: 0x%02X, val2: 0x%02X", __FUNCTION__, __LINE__, val1, val2);
+
+    if ((val1 < PS_CONF1_2) || (val1 > PS_HIGH_THDL)){
+        printk("%s:%d, ACHEUL, error, invalid register: 0x%02X, supported values: [0x%02X..0x%02X]", __FUNCTION__, __LINE__, val1, PS_CONF1_2, PS_HIGH_THDL);
+		return -EINVAL;
+    }
+
+    ret = vcnl3040_write_register(data, (uint8_t) val1, (uint16_t) val2);
+
+    vcnl3040_show_config(data);
+    return ret;
+}// vcnl3040_write_raw
+
+static int vcnl3040_read_avail(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan,
+			       const int **vals, int *type, int *length,
+			       long mask)
+{
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*vals = (int *)vcnl3040_prox_sampling_frequency;
+		*type = IIO_VAL_INT_PLUS_MICRO;
+		*length = 2 * ARRAY_SIZE(vcnl3040_prox_sampling_frequency);
+		return IIO_AVAIL_LIST;
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct iio_info vcnl3040_info = {
+	.read_raw           = vcnl3040_read_raw,
+	.write_raw          = vcnl3040_write_raw,
+	.read_avail         = vcnl3040_read_avail,
+	.read_event_value   = vcnl3040_read_event,
+	.write_event_value  = vcnl3040_write_event,
+	.read_event_config  = vcnl3040_read_event_config,
+	.write_event_config = vcnl3040_write_event_config,
+};
+
+static const struct regmap_config vcnl3040_regmap_config = {
+	.reg_bits     = 8,
+	.val_bits     = 16,
+	.max_register = DEVICE_ID
+};
+
+static irqreturn_t vcnl3040_handle_irq_thread(int irq, void *p)
+{
+    struct iio_dev*       indio_dev       = p;
+    struct vcnl3040_data* data            = iio_priv(indio_dev);
+    uint16_t              int_flags       = vcnl3040_read_register(data, INT_FLAGS);
+    bool                  close_proximity = int_flags & 0x0200 ? true : false;
+    bool                  away_proximity  = int_flags & 0x0100 ? true : false;
+
+    // FIXME! remove this
+    printk("%s:%d, ACHEUL, close_proximity: %d, away_proximity: %d", __FUNCTION__, __LINE__, close_proximity, away_proximity);
+
+    if (close_proximity) {
+        iio_push_event(indio_dev, IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1, IIO_EV_TYPE_THRESH, IIO_EV_DIR_RISING), iio_get_time_ns(indio_dev));
+    }
+
+    if (away_proximity) {
+        iio_push_event(indio_dev, IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1, IIO_EV_TYPE_THRESH, IIO_EV_DIR_FALLING), iio_get_time_ns(indio_dev));
+    }
+
+    return IRQ_HANDLED;
+}// vcnl3040_handle_irq_thread
+
+static int vcnl3040_probe(struct i2c_client *client)
+{
+	struct vcnl3040_data *data;
+	struct iio_dev *indio_dev;
+	struct regmap *regmap;
+	int rc;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	regmap = devm_regmap_init_i2c(client, &vcnl3040_regmap_config);
+	if (IS_ERR(regmap)) {
+        printk("%s:%d, ACHEUL, error: reg map init failed", __FUNCTION__, __LINE__);
+		return PTR_ERR(regmap);
+	}
+
+	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
+	if (!indio_dev) {
+        printk("%s:%d, ACHEUL, error: failed to allocate", __FUNCTION__, __LINE__);
+		return -ENOMEM;
+    }
+
+	data = iio_priv(indio_dev);
+	i2c_set_clientdata(client, indio_dev);
+	data->regmap = regmap;
+	data->dev    = &client->dev;
+    data->client = client;
+
+	rc = vcnl3040_init(data);
+	if (rc){
+        printk("%s:%d, ACHEUL, error: failed to initialize", __FUNCTION__, __LINE__);
+		return rc;
+    }
+
+	indio_dev->info         = &vcnl3040_info;
+	indio_dev->channels     = vcnl3040_channels;
+	indio_dev->num_channels = ARRAY_SIZE(vcnl3040_channels);
+	indio_dev->name         = "vcnl3040";
+	indio_dev->modes        = INDIO_DIRECT_MODE;
+
+    if (client->irq) {
+        rc = devm_request_threaded_irq(&client->dev, client->irq, NULL, vcnl3040_handle_irq_thread, IRQF_ONESHOT, indio_dev->name, indio_dev);
+        if (rc) {
+            printk("%s:%d, ACHEUL, error: failed to initialize IRQ", __FUNCTION__, __LINE__);
+            return rc;
+        }
+    }
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+    rc = devm_iio_device_register(&client->dev, indio_dev);
+    if (rc) {
+        printk("%s:%d, ACHEUL, error: failed to register iio device, error: %d", __FUNCTION__, __LINE__, rc);
+        return rc;
+    }
+
+    return rc;
+}// vcnl3040_probe
+
+static const struct of_device_id vcnl3040_of_match[] = {
+	{
+		.compatible = "vishay,vcnl3040",
+	},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, vcnl3040_of_match);
+
+static struct i2c_driver vcnl3040_driver = {
+	.driver = {
+		.name           = "vishay,vcnl3040",
+		.of_match_table = vcnl3040_of_match,
+	},
+	.probe_new  = vcnl3040_probe,
+};
+module_i2c_driver(vcnl3040_driver);
+
+MODULE_AUTHOR("Bruno Bauthier <bruno.gauth@gmail.com>");
+MODULE_DESCRIPTION("Vishay VCNL3040 proximity sensor driver");
+MODULE_LICENSE("GPL");
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: resolver
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: temperature
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/iio: trigger
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: infiniband
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: Kconfig
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/Makefile msm-4.19/drivers/input/Makefile
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/Makefile	2024-04-16 19:14:58.788044888 +0000
+++ msm-4.19/drivers/input/Makefile	2024-04-20 18:36:20.826499294 +0000
@@ -31,3 +31,9 @@
 obj-$(CONFIG_INPUT_KEYCOMBO)	+= keycombo.o
 
 obj-$(CONFIG_RMI4_CORE)		+= rmi4/
+
+###############################################
+## ACHEUL
+###############################################
+obj-y += misc/
+###############################################
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: apm-power.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: evbug.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: evdev.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: event_notify.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: ff-core.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: ff-memless.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: gameport
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: input-compat.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: input-compat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: input-leds.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: input-mt.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: input-polldev.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: input.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: joydev.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: joystick
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: keyboard
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: keycombo.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: keyreset.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: matrix-keymap.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: 88pm80x_onkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: 88pm860x_onkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: Kconfig
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc/Makefile msm-4.19/drivers/input/misc/Makefile
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc/Makefile	2024-04-16 19:14:58.808044874 +0000
+++ msm-4.19/drivers/input/misc/Makefile	2024-04-20 18:36:20.826499294 +0000
@@ -84,3 +84,9 @@
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
 obj-$(CONFIG_INPUT_IDEAPAD_SLIDEBAR)	+= ideapad_slidebar.o
+###############################################
+## ACHEUL
+###############################################
+obj-$(CONFIG_SENSORS_AKM09911)  += akm09911.o
+obj-y += sensors_class.o
+###############################################
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: ab8500-ponkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: ad714x-i2c.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: ad714x-spi.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: ad714x.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: ad714x.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: adxl34x-i2c.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: adxl34x-spi.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: adxl34x.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: adxl34x.h
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc/akm09911.c msm-4.19/drivers/input/misc/akm09911.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc/akm09911.c	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/drivers/input/misc/akm09911.c	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,2490 @@
+/* drivers/misc/akm09911.c - akm09911 compass driver
+ *
+        p * Copyright (c) 2014-2015, Linux Foundation. All rights reserved.
+ * Copyright (C) 2007-2008 HTC Corporation.
+ * Author: Hou-Kun Chen <houkun.chen@gmail.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*#define DEBUG*/
+/*#define VERBOSE_DEBUG*/
+
+#include <linux/akm09911.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/freezer.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/sensors.h>
+
+#define AKM_DEBUG_IF		 	1
+#define AKM_HAS_RESET			0
+#define AKM_INPUT_DEVICE_NAME	"akm09911-mag"
+#define AKM_DRDY_TIMEOUT_MS		100
+#define AKM_BASE_NUM			10
+
+#define AKM_IS_MAG_DATA_ENABLED() (akm->enable_flag & (1 << MAG_DATA_FLAG))
+
+/* POWER SUPPLY VOLTAGE RANGE */
+#define AKM09911_VDD_MIN_UV	2000000
+#define AKM09911_VDD_MAX_UV	3300000
+#define AKM09911_VIO_MIN_UV	1750000
+#define AKM09911_VIO_MAX_UV	1950000
+
+#define STATUS_ERROR(st)		(((st)&0x08) != 0x0)
+
+#define AKM09911_RETRY_COUNT	10
+
+// ACHEUL
+#define SYN_TIME_SEC        4
+#define SYN_TIME_NSEC       5
+// ACHEUL
+
+enum {
+	AKM09911_AXIS_X = 0,
+	AKM09911_AXIS_Y,
+	AKM09911_AXIS_Z,
+	AKM09911_AXIS_COUNT,
+};
+
+/* Save last device state for power down */
+struct akm_sensor_state {
+	bool power_on;
+	uint8_t mode;
+};
+
+struct akm_compass_data {
+	struct i2c_client	*i2c;
+	struct input_dev	*input;
+	struct device		*class_dev;
+	struct class		*compass;
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pin_default;
+	struct pinctrl_state	*pin_sleep;
+	struct sensors_classdev	cdev;
+	struct delayed_work	dwork;
+	struct workqueue_struct	*work_queue;
+	struct mutex		op_mutex;
+	struct timespec 	ts;
+
+	wait_queue_head_t	drdy_wq;
+	wait_queue_head_t	open_wq;
+
+	/* These two buffers are initialized at start up.
+	   After that, the value is not changed */
+	uint8_t sense_info[AKM_SENSOR_INFO_SIZE];
+	uint8_t sense_conf[AKM_SENSOR_CONF_SIZE];
+
+	struct	mutex sensor_mutex;
+	uint8_t	sense_data[AKM_SENSOR_DATA_SIZE];
+	struct mutex accel_mutex;
+	int16_t accel_data[3];
+
+	struct mutex	val_mutex;
+	uint32_t		enable_flag;
+	int64_t			delay[AKM_NUM_SENSORS];
+
+	atomic_t	active;
+	atomic_t	drdy;
+
+	char	layout;
+	int	irq;
+	int	gpio_rstn;
+	int	power_enabled;
+	int	auto_report;
+	int	use_hrtimer;
+
+	/* The input event last time */
+	int	last_x;
+	int	last_y;
+	int	last_z;
+
+	int	flush_count;
+
+	/* dummy value to avoid sensor event get eaten */
+	int	rep_cnt;
+
+	struct regulator	*vdd;
+	struct regulator	*vio;
+	struct akm_sensor_state state;
+	struct hrtimer	poll_timer;
+};
+
+static struct sensors_classdev sensors_cdev = {
+	.name = "akm09911-mag",
+	.vendor = "Asahi Kasei Microdevices Corporation",
+	.version = 1,
+	.handle = SENSORS_MAGNETIC_FIELD_HANDLE,
+	.type = SENSOR_TYPE_MAGNETIC_FIELD,
+	.max_range = "1228.8",
+	.resolution = "0.15", //0.6:akm09911, 0.15:AKM09916
+	.sensor_power = "0.35",
+	.min_delay = 10000,
+	.max_delay = 10000,
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 10,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+
+static struct akm_compass_data *s_akm;
+
+static int akm_compass_power_set(struct akm_compass_data *data, bool on);
+/***** I2C I/O function ***********************************************/
+static int akm_i2c_rxdata(
+	struct i2c_client *i2c,
+	uint8_t *rxData,
+	int length)
+{
+	int ret;
+
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr = i2c->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = rxData,
+		},
+		{
+			.addr = i2c->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = rxData,
+		},
+	};
+	uint8_t addr = rxData[0];
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	ret = i2c_transfer(i2c->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret < 0) {
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		dev_err(&i2c->dev, "%s: transfer failed.", __func__);
+		return ret;
+	} else if (ret != ARRAY_SIZE(msgs)) {
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		dev_err(&i2c->dev, "%s: transfer failed(size error).\n",
+				__func__);
+		return -ENXIO;
+	}
+
+	dev_vdbg(&i2c->dev, "RxData: len=%02x, addr=%02x, data=%02x",
+		length, addr, rxData[0]);
+
+    printk("%s:%d, ACHEUL, RxData: len=%02x, addr=%02x, data=%02x", __FUNCTION__, __LINE__, length, addr, rxData[0]);
+
+	return 0;
+}
+
+static int akm_i2c_txdata(
+	struct i2c_client *i2c,
+	uint8_t *txData,
+	int length)
+{
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr = i2c->addr,
+			.flags = 0,
+			.len = length,
+			.buf = txData,
+		},
+	};
+
+	ret = i2c_transfer(i2c->adapter, msg, ARRAY_SIZE(msg));
+	if (ret < 0) {
+		dev_err(&i2c->dev, "%s: transfer failed.", __func__);
+		return ret;
+	} else if (ret != ARRAY_SIZE(msg)) {
+		dev_err(&i2c->dev, "%s: transfer failed(size error).",
+				__func__);
+		return -ENXIO;
+	}
+
+	dev_vdbg(&i2c->dev, "TxData: len=%02x, addr=%02x data=%02x",
+		length, txData[0], txData[1]);
+
+    printk("%s:%d, ACHEUL, TxData: len=%02x, addr=%02x, data=%02x", __FUNCTION__, __LINE__, length, txData[0], txData[1]);
+	return 0;
+}
+
+/***** akm miscdevice functions *************************************/
+static int AKECS_Set_CNTL(
+	struct akm_compass_data *akm,
+	uint8_t mode)
+{
+	uint8_t buffer[2];
+	int err;
+
+	/***** lock *****/
+	mutex_lock(&akm->sensor_mutex);
+	/* Set measure mode */
+	buffer[0] = AKM_REG_MODE;
+	buffer[1] = mode;
+	err = akm_i2c_txdata(akm->i2c, buffer, 2);
+	if (err < 0) {
+		dev_err(&akm->i2c->dev,
+				"%s: Can not set CNTL.", __func__);
+	} else {
+		dev_vdbg(&akm->i2c->dev,
+				"Mode is set to (%d).", mode);
+		atomic_set(&akm->drdy, 0);
+		/* wait at least 100us after changing mode */
+		udelay(100);
+	}
+
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+	return err;
+}
+
+static int AKECS_Set_PowerDown(
+	struct akm_compass_data *akm)
+{
+	uint8_t buffer[2];
+	int err;
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	/***** lock *****/
+	mutex_lock(&akm->sensor_mutex);
+
+	/* Set powerdown mode */
+	buffer[0] = AKM_REG_MODE;
+	buffer[1] = AKM_MODE_POWERDOWN;
+	err = akm_i2c_txdata(akm->i2c, buffer, 2);
+	if (err < 0) {
+		dev_err(&akm->i2c->dev,
+			"%s: Can not set to powerdown mode.", __func__);
+	} else {
+		dev_dbg(&akm->i2c->dev, "Powerdown mode is set.");
+		/* wait at least 100us after changing mode */
+		udelay(100);
+	}
+	atomic_set(&akm->drdy, 0);
+
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+	return err;
+}
+
+static int AKECS_Reset(
+	struct akm_compass_data *akm,
+	int hard)
+{
+	int err;
+
+#if AKM_HAS_RESET
+	uint8_t buffer[2];
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	/***** lock *****/
+	mutex_lock(&akm->sensor_mutex);
+
+	if (hard != 0) {
+		gpio_set_value(akm->gpio_rstn, 0);
+		udelay(5);
+		gpio_set_value(akm->gpio_rstn, 1);
+		/* No error is returned */
+		err = 0;
+	} else {
+		buffer[0] = AKM_REG_RESET;
+		buffer[1] = AKM_RESET_DATA;
+		err = akm_i2c_txdata(akm->i2c, buffer, 2);
+		if (err < 0) {
+			dev_err(&akm->i2c->dev,
+				"%s: Can not set SRST bit.", __func__);
+		} else {
+			dev_dbg(&akm->i2c->dev, "Soft reset is done.");
+		}
+	}
+	/* Device will be accessible 100 us after */
+	udelay(100);
+	atomic_set(&akm->drdy, 0);
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+#else
+	err = AKECS_Set_PowerDown(akm);
+#endif
+
+	return err;
+}
+
+static int AKECS_SetMode(
+	struct akm_compass_data *akm,
+	uint8_t mode)
+{
+	int err;
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	switch (mode & 0x1F) {
+	case AKM_MODE_SNG_MEASURE:
+	case AKM_MODE_SELF_TEST:
+	case AKM_MODE_FUSE_ACCESS:
+	case AKM_MODE_CONTINUOUS_10HZ:
+	case AKM_MODE_CONTINUOUS_20HZ:
+	case AKM_MODE_CONTINUOUS_50HZ:
+	case AKM_MODE_CONTINUOUS_100HZ:
+		err = AKECS_Set_CNTL(akm, mode);
+		break;
+	case AKM_MODE_POWERDOWN:
+		err = AKECS_Set_PowerDown(akm);
+		break;
+	default:
+		dev_err(&akm->i2c->dev,
+			"%s: Unknown mode(%d).", __func__, mode);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static void AKECS_SetYPR(
+	struct akm_compass_data *akm,
+	int *rbuf)
+{
+	uint32_t ready;
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+
+	dev_vdbg(&akm->i2c->dev, "%s: flag =0x%X", __func__, rbuf[0]);
+	dev_vdbg(&akm->input->dev, "  Acc [LSB]   : %6d,%6d,%6d stat=%d",
+		rbuf[1], rbuf[2], rbuf[3], rbuf[4]);
+	dev_vdbg(&akm->input->dev, "  Geo [LSB]   : %6d,%6d,%6d stat=%d",
+		rbuf[5], rbuf[6], rbuf[7], rbuf[8]);
+	dev_vdbg(&akm->input->dev, "  Orientation : %6d,%6d,%6d",
+		rbuf[9], rbuf[10], rbuf[11]);
+	dev_vdbg(&akm->input->dev, "  Rotation V  : %6d,%6d,%6d,%6d",
+		rbuf[12], rbuf[13], rbuf[14], rbuf[15]);
+
+	/* No events are reported */
+	if (!rbuf[0]) {
+		dev_dbg(&akm->i2c->dev, "Don't waste a time.");
+		return;
+	}
+
+	mutex_lock(&akm->val_mutex);
+	ready = (akm->enable_flag & (uint32_t)rbuf[0]);
+	mutex_unlock(&akm->val_mutex);
+
+	/* Report acceleration sensor information */
+	if (ready & ACC_DATA_READY) {
+		input_report_abs(akm->input, ABS_X, rbuf[1]);
+		input_report_abs(akm->input, ABS_Y, rbuf[2]);
+		input_report_abs(akm->input, ABS_Z, rbuf[3]);
+		input_report_abs(akm->input, ABS_RX, rbuf[4]);
+	}
+	/* Report magnetic vector information */
+	if (ready & MAG_DATA_READY) {
+		input_report_abs(akm->input, ABS_X, rbuf[5]);
+		input_report_abs(akm->input, ABS_Y, rbuf[6]);
+		input_report_abs(akm->input, ABS_Z, rbuf[7]);
+		input_report_abs(akm->input, ABS_MISC, rbuf[8]);
+	}
+	/* Report fusion sensor information */
+	if (ready & FUSION_DATA_READY) {
+		/* Orientation */
+		input_report_abs(akm->input, ABS_HAT0Y, rbuf[9]);
+		input_report_abs(akm->input, ABS_HAT1X, rbuf[10]);
+		input_report_abs(akm->input, ABS_HAT1Y, rbuf[11]);
+		/* Rotation Vector */
+		input_report_abs(akm->input, ABS_TILT_X, rbuf[12]);
+		input_report_abs(akm->input, ABS_TILT_Y, rbuf[13]);
+		input_report_abs(akm->input, ABS_TOOL_WIDTH, rbuf[14]);
+		input_report_abs(akm->input, ABS_VOLUME, rbuf[15]);
+	}
+
+	input_sync(akm->input);
+}
+
+/* This function will block a process until the latest measurement
+ * data is available.
+ */
+static int AKECS_GetData(
+	struct akm_compass_data *akm,
+	uint8_t *rbuf,
+	int size)
+{
+	int err;
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	/* Block! */
+	err = wait_event_interruptible_timeout(
+			akm->drdy_wq,
+			atomic_read(&akm->drdy),
+			msecs_to_jiffies(AKM_DRDY_TIMEOUT_MS));
+
+	if (err < 0) {
+		dev_err(&akm->i2c->dev,
+			"%s: wait_event failed (%d).", __func__, err);
+		return err;
+	}
+	if (!atomic_read(&akm->drdy)) {
+		dev_err(&akm->i2c->dev,
+			"%s: DRDY is not set.", __func__);
+		return -ENODATA;
+	}
+
+	/***** lock *****/
+	mutex_lock(&akm->sensor_mutex);
+
+	memcpy(rbuf, akm->sense_data, size);
+	atomic_set(&akm->drdy, 0);
+
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+	return 0;
+}
+
+static int AKECS_GetData_Poll(
+	struct akm_compass_data *akm,
+	uint8_t *rbuf,
+	int size)
+{
+	uint8_t buffer[AKM_SENSOR_DATA_SIZE];
+	int err;
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	/* Read data */
+	buffer[0] = AKM_REG_STATUS;
+	err = akm_i2c_rxdata(akm->i2c, buffer, AKM_SENSOR_DATA_SIZE);
+	if (err < 0) {
+		dev_err(&akm->i2c->dev, "%s failed.", __func__);
+		return err;
+	}
+
+	/* Check ST bit */
+	if (!(AKM_DRDY_IS_HIGH(buffer[0])))
+		dev_dbg(&akm->i2c->dev, "DRDY is low. Use last value.\n");
+
+	/* Data is over run is */
+	if (AKM_DOR_IS_HIGH(buffer[0]))
+		dev_dbg(&akm->i2c->dev, "Data over run!\n");
+
+	memcpy(rbuf, buffer, size);
+	atomic_set(&akm->drdy, 0);
+
+	return 0;
+}
+
+static int AKECS_GetOpenStatus(
+	struct akm_compass_data *akm)
+{
+	return wait_event_interruptible(
+			akm->open_wq, (atomic_read(&akm->active) > 0));
+}
+
+static int AKECS_GetCloseStatus(
+	struct akm_compass_data *akm)
+{
+	return wait_event_interruptible(
+			akm->open_wq, (atomic_read(&akm->active) <= 0));
+}
+
+static int AKECS_Open(struct inode *inode, struct file *file)
+{
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	file->private_data = s_akm;
+	return nonseekable_open(inode, file);
+}
+
+static int AKECS_Release(struct inode *inode, struct file *file)
+{
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static long
+AKECS_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct akm_compass_data *akm = file->private_data;
+
+	/* NOTE: In this function the size of "char" should be 1-byte. */
+	uint8_t i2c_buf[AKM_RWBUF_SIZE];		/* for READ/WRITE */
+	uint8_t dat_buf[AKM_SENSOR_DATA_SIZE];/* for GET_DATA */
+	int32_t ypr_buf[AKM_YPR_DATA_SIZE];		/* for SET_YPR */
+	int64_t delay[AKM_NUM_SENSORS];	/* for GET_DELAY */
+	int16_t acc_buf[3];	/* for GET_ACCEL */
+	uint8_t mode;			/* for SET_MODE*/
+	int status;			/* for OPEN/CLOSE_STATUS */
+	int ret = 0;		/* Return value. */
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+	case ECS_IOCTL_WRITE:
+		if (argp == NULL) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		if (copy_from_user(&i2c_buf, argp, sizeof(i2c_buf))) {
+			dev_err(&akm->i2c->dev, "copy_from_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_SET_MODE:
+		if (argp == NULL) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		if (copy_from_user(&mode, argp, sizeof(mode))) {
+			dev_err(&akm->i2c->dev, "copy_from_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_SET_YPR:
+		if (argp == NULL) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		if (copy_from_user(&ypr_buf, argp, sizeof(ypr_buf))) {
+			dev_err(&akm->i2c->dev, "copy_from_user failed.");
+			return -EFAULT;
+		}
+	case ECS_IOCTL_GET_INFO:
+	case ECS_IOCTL_GET_CONF:
+	case ECS_IOCTL_GET_DATA:
+	case ECS_IOCTL_GET_OPEN_STATUS:
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+	case ECS_IOCTL_GET_DELAY:
+	case ECS_IOCTL_GET_LAYOUT:
+	case ECS_IOCTL_GET_ACCEL:
+		/* Check buffer pointer for writing a data later. */
+		if (argp == NULL) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_READ called.");
+		if ((i2c_buf[0] < 1) || (i2c_buf[0] > (AKM_RWBUF_SIZE-1))) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		ret = akm_i2c_rxdata(akm->i2c, &i2c_buf[1], i2c_buf[0]);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_WRITE:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_WRITE called.");
+		if ((i2c_buf[0] < 2) || (i2c_buf[0] > (AKM_RWBUF_SIZE-1))) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		ret = akm_i2c_txdata(akm->i2c, &i2c_buf[1], i2c_buf[0]);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_RESET:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_RESET called.");
+		ret = AKECS_Reset(akm, akm->gpio_rstn);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_SET_MODE:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_SET_MODE called.");
+		ret = AKECS_SetMode(akm, mode);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_SET_YPR:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_SET_YPR called.");
+		AKECS_SetYPR(akm, ypr_buf);
+		break;
+	case ECS_IOCTL_GET_DATA:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_DATA called.");
+		if (akm->irq)
+			ret = AKECS_GetData(akm, dat_buf, AKM_SENSOR_DATA_SIZE);
+		else
+			ret = AKECS_GetData_Poll(
+					akm, dat_buf, AKM_SENSOR_DATA_SIZE);
+
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_GET_OPEN_STATUS:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_OPEN_STATUS called.");
+		ret = AKECS_GetOpenStatus(akm);
+		if (ret < 0) {
+			dev_err(&akm->i2c->dev,
+				"Get Open returns error (%d).", ret);
+			return ret;
+		}
+		break;
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_CLOSE_STATUS called.");
+		ret = AKECS_GetCloseStatus(akm);
+		if (ret < 0) {
+			dev_err(&akm->i2c->dev,
+				"Get Close returns error (%d).", ret);
+			return ret;
+		}
+		break;
+	case ECS_IOCTL_GET_DELAY:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_DELAY called.");
+		mutex_lock(&akm->val_mutex);
+		delay[0] = ((akm->enable_flag & ACC_DATA_READY) ?
+				akm->delay[0] : -1);
+		delay[1] = ((akm->enable_flag & MAG_DATA_READY) ?
+				akm->delay[1] : -1);
+		delay[2] = ((akm->enable_flag & FUSION_DATA_READY) ?
+				akm->delay[2] : -1);
+		mutex_unlock(&akm->val_mutex);
+		break;
+	case ECS_IOCTL_GET_INFO:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_INFO called.");
+		break;
+	case ECS_IOCTL_GET_CONF:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_CONF called.");
+		break;
+	case ECS_IOCTL_GET_LAYOUT:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_LAYOUT called.");
+		break;
+	case ECS_IOCTL_GET_ACCEL:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_ACCEL called.");
+		mutex_lock(&akm->accel_mutex);
+		acc_buf[0] = akm->accel_data[0];
+		acc_buf[1] = akm->accel_data[1];
+		acc_buf[2] = akm->accel_data[2];
+		mutex_unlock(&akm->accel_mutex);
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+		/* +1  is for the first byte */
+		if (copy_to_user(argp, &i2c_buf, i2c_buf[0]+1)) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_INFO:
+		if (copy_to_user(argp, &akm->sense_info,
+					sizeof(akm->sense_info))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_CONF:
+		if (copy_to_user(argp, &akm->sense_conf,
+					sizeof(akm->sense_conf))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_DATA:
+		if (copy_to_user(argp, &dat_buf, sizeof(dat_buf))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_OPEN_STATUS:
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+		status = atomic_read(&akm->active);
+		if (copy_to_user(argp, &status, sizeof(status))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_DELAY:
+		if (copy_to_user(argp, &delay, sizeof(delay))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_LAYOUT:
+		if (copy_to_user(argp, &akm->layout, sizeof(akm->layout))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_ACCEL:
+		if (copy_to_user(argp, &acc_buf, sizeof(acc_buf))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const struct file_operations AKECS_fops = {
+	.owner = THIS_MODULE,
+	.open = AKECS_Open,
+	.release = AKECS_Release,
+	.unlocked_ioctl = AKECS_ioctl,
+};
+
+static struct miscdevice akm_compass_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = AKM_MISCDEV_NAME,
+	.fops = &AKECS_fops,
+};
+
+/***** akm sysfs functions ******************************************/
+static int create_device_attributes(
+	struct device *dev,
+	struct device_attribute *attrs)
+{
+	int i;
+	int err = 0;
+
+	for (i = 0 ; NULL != attrs[i].attr.name ; ++i) {
+		err = device_create_file(dev, &attrs[i]);
+		if (err)
+			break;
+	}
+
+	if (err) {
+		for (--i; i >= 0 ; --i)
+			device_remove_file(dev, &attrs[i]);
+	}
+
+	return err;
+}
+
+static void remove_device_attributes(
+	struct device *dev,
+	struct device_attribute *attrs)
+{
+	int i;
+
+	for (i = 0 ; NULL != attrs[i].attr.name ; ++i)
+		device_remove_file(dev, &attrs[i]);
+}
+
+static int create_device_binary_attributes(
+	struct kobject *kobj,
+	struct bin_attribute *attrs)
+{
+	int i;
+	int err = 0;
+
+	err = 0;
+
+	for (i = 0 ; NULL != attrs[i].attr.name ; ++i) {
+		err = sysfs_create_bin_file(kobj, &attrs[i]);
+		if (0 != err)
+			break;
+	}
+
+	if (0 != err) {
+		for (--i; i >= 0 ; --i)
+			sysfs_remove_bin_file(kobj, &attrs[i]);
+	}
+
+	return err;
+}
+
+static void remove_device_binary_attributes(
+	struct kobject *kobj,
+	struct bin_attribute *attrs)
+{
+	int i;
+
+	for (i = 0 ; NULL != attrs[i].attr.name ; ++i)
+		sysfs_remove_bin_file(kobj, &attrs[i]);
+}
+
+/*********************************************************************
+ *
+ * SysFS attribute functions
+ *
+ * directory : /sys/class/compass/akmXXXX/
+ * files :
+ *  - enable_acc    [rw] [t] : enable flag for accelerometer
+ *  - enable_mag    [rw] [t] : enable flag for magnetometer
+ *  - enable_fusion [rw] [t] : enable flag for fusion sensor
+ *  - delay_acc     [rw] [t] : delay in nanosecond for accelerometer
+ *  - delay_mag     [rw] [t] : delay in nanosecond for magnetometer
+ *  - delay_fusion  [rw] [t] : delay in nanosecond for fusion sensor
+ *
+ * debug :
+ *  - mode       [w]  [t] : E-Compass mode
+ *  - bdata      [r]  [t] : buffered raw data
+ *  - asa        [r]  [t] : FUSEROM data
+ *  - regs       [r]  [t] : read all registers
+ *
+ * [b] = binary format
+ * [t] = text format
+ */
+
+/***** sysfs enable *************************************************/
+static void akm_compass_sysfs_update_status(
+	struct akm_compass_data *akm)
+{
+	uint32_t en;
+	mutex_lock(&akm->val_mutex);
+	en = akm->enable_flag;
+	mutex_unlock(&akm->val_mutex);
+
+	if (en == 0) {
+		if (atomic_cmpxchg(&akm->active, 1, 0) == 1) {
+			wake_up(&akm->open_wq);
+			dev_dbg(akm->class_dev, "Deactivated");
+		}
+	} else {
+		if (atomic_cmpxchg(&akm->active, 0, 1) == 0) {
+			wake_up(&akm->open_wq);
+			dev_dbg(akm->class_dev, "Activated");
+		}
+	}
+	dev_dbg(&akm->i2c->dev,
+		"Status updated: enable=0x%X, active=%d",
+		en, atomic_read(&akm->active));
+}
+
+static inline uint8_t akm_select_frequency(int64_t delay_ns)
+{
+	if (delay_ns >= 100000000LL)
+		return AKM_MODE_CONTINUOUS_10HZ;
+	else if (delay_ns >= 50000000LL)
+		return AKM_MODE_CONTINUOUS_20HZ;
+	else if (delay_ns >= 20000000LL)
+		return AKM_MODE_CONTINUOUS_50HZ;
+	else
+		return AKM_MODE_CONTINUOUS_100HZ;
+}
+
+static int akm_enable_set(struct sensors_classdev *sensors_cdev,
+		unsigned int enable)
+{
+	int ret = 0;
+	struct akm_compass_data *akm = container_of(sensors_cdev,
+			struct akm_compass_data, cdev);
+	uint8_t mode;
+
+	mutex_lock(&akm->val_mutex);
+	akm->enable_flag &= ~(1<<MAG_DATA_FLAG);
+	akm->enable_flag |= ((uint32_t)(enable))<<MAG_DATA_FLAG;
+	mutex_unlock(&akm->val_mutex);
+
+	akm_compass_sysfs_update_status(akm);
+	mutex_lock(&akm->op_mutex);
+	if (enable) {
+		ret = akm_compass_power_set(akm, true);
+		if (ret) {
+			dev_err(&akm->i2c->dev,
+				"Fail to power on the device!\n");
+			goto exit;
+		}
+
+		if (akm->auto_report) {
+			mode = akm_select_frequency(akm->delay[MAG_DATA_FLAG]);
+			AKECS_SetMode(akm, mode);
+			if (akm->use_hrtimer)
+				hrtimer_start(&akm->poll_timer,
+					ns_to_ktime(akm->delay[MAG_DATA_FLAG]),
+					HRTIMER_MODE_REL);
+			else
+				queue_delayed_work(akm->work_queue, &akm->dwork,
+					(unsigned long)nsecs_to_jiffies64(
+						akm->delay[MAG_DATA_FLAG]));
+		}
+	} else {
+		if (akm->auto_report) {
+			if (akm->use_hrtimer) {
+				hrtimer_cancel(&akm->poll_timer);
+				cancel_work_sync(&akm->dwork.work);
+			} else {
+				cancel_delayed_work_sync(&akm->dwork);
+			}
+			AKECS_SetMode(akm, AKM_MODE_POWERDOWN);
+		}
+		ret = akm_compass_power_set(akm, false);
+		if (ret) {
+			dev_err(&akm->i2c->dev,
+				"Fail to power off the device!\n");
+			goto exit;
+		}
+	}
+
+exit:
+	mutex_unlock(&akm->op_mutex);
+	return ret;
+}
+
+static ssize_t akm_compass_sysfs_enable_show(
+	struct akm_compass_data *akm, char *buf, int pos)
+{
+	int flag;
+
+	mutex_lock(&akm->val_mutex);
+	flag = ((akm->enable_flag >> pos) & 1);
+	mutex_unlock(&akm->val_mutex);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", flag);
+}
+
+static ssize_t akm_compass_sysfs_enable_store(
+	struct akm_compass_data *akm, char const *buf, size_t count, int pos)
+{
+	long en = 0;
+	int ret = 0;
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	if (NULL == buf)
+		return -EINVAL;
+
+	if (0 == count)
+		return 0;
+
+	if (kstrtol(buf, AKM_BASE_NUM, &en))
+		return -EINVAL;
+
+	en = en ? 1 : 0;
+
+	mutex_lock(&akm->op_mutex);
+	ret = akm_compass_power_set(akm, en);
+	if (ret) {
+		dev_err(&akm->i2c->dev,
+			"Fail to configure device power!\n");
+		goto exit;
+	}
+	mutex_lock(&akm->val_mutex);
+	akm->enable_flag &= ~(1<<pos);
+	akm->enable_flag |= ((uint32_t)(en))<<pos;
+	mutex_unlock(&akm->val_mutex);
+
+	akm_compass_sysfs_update_status(akm);
+
+exit:
+	mutex_unlock(&akm->op_mutex);
+
+	return ret ? ret : count;
+}
+
+/***** Acceleration ***/
+static ssize_t akm_enable_acc_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_enable_show(
+		dev_get_drvdata(dev), buf, ACC_DATA_FLAG);
+}
+static ssize_t akm_enable_acc_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_enable_store(
+		dev_get_drvdata(dev), buf, count, ACC_DATA_FLAG);
+}
+
+/***** Magnetic field ***/
+static ssize_t akm_enable_mag_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_enable_show(dev_get_drvdata(dev), buf, MAG_DATA_FLAG);
+}
+static ssize_t akm_enable_mag_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_enable_store(
+		dev_get_drvdata(dev), buf, count, MAG_DATA_FLAG);
+}
+
+/***** Fusion ***/
+static ssize_t akm_enable_fusion_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_enable_show(
+		dev_get_drvdata(dev), buf, FUSION_DATA_FLAG);
+}
+static ssize_t akm_enable_fusion_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_enable_store(
+		dev_get_drvdata(dev), buf, count, FUSION_DATA_FLAG);
+}
+
+static int akm_flush_set(struct sensors_classdev *sensors_cdev)
+{
+	struct akm_compass_data *akm = container_of(sensors_cdev,
+			struct akm_compass_data, cdev);
+
+	if(!AKM_IS_MAG_DATA_ENABLED())
+		return -EINVAL;
+
+	input_event(akm->input, EV_SYN, SYN_CONFIG, akm->flush_count++);
+	input_sync(akm->input);
+
+	dev_dbg(&akm->i2c->dev, "%s: end \n", __func__);
+
+	return 0;
+}
+
+/***** sysfs delay **************************************************/
+static int akm_poll_delay_set(struct sensors_classdev *sensors_cdev,
+		unsigned int delay_msec)
+{
+	struct akm_compass_data *akm = container_of(sensors_cdev,
+			struct akm_compass_data, cdev);
+	uint8_t mode;
+	int ret;
+
+	mutex_lock(&akm->val_mutex);
+
+	akm->delay[MAG_DATA_FLAG] = delay_msec * 1000000;
+	mode = akm_select_frequency(akm->delay[MAG_DATA_FLAG]);
+	ret = AKECS_SetMode(akm, mode);
+	if (ret < 0)
+		dev_err(&akm->i2c->dev, "Failed to set to mode(%x)\n", mode);
+
+	mutex_unlock(&akm->val_mutex);
+	return ret;
+}
+
+static ssize_t akm_compass_sysfs_delay_show(
+	struct akm_compass_data *akm, char *buf, int pos)
+{
+	int64_t val;
+
+	mutex_lock(&akm->val_mutex);
+	val = akm->delay[pos];
+	mutex_unlock(&akm->val_mutex);
+
+	return scnprintf(buf, PAGE_SIZE, "%lld\n", val);
+}
+
+static ssize_t akm_compass_sysfs_delay_store(
+	struct akm_compass_data *akm, char const *buf, size_t count, int pos)
+{
+	long long val = 0;
+
+	if (NULL == buf)
+		return -EINVAL;
+
+	if (0 == count)
+		return 0;
+
+	if (kstrtoll(buf, AKM_BASE_NUM, &val))
+		return -EINVAL;
+
+	mutex_lock(&akm->val_mutex);
+	akm->delay[pos] = val;
+	mutex_unlock(&akm->val_mutex);
+
+	return count;
+}
+
+/***** Accelerometer ***/
+static ssize_t akm_delay_acc_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_delay_show(
+		dev_get_drvdata(dev), buf, ACC_DATA_FLAG);
+}
+static ssize_t akm_delay_acc_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_delay_store(
+		dev_get_drvdata(dev), buf, count, ACC_DATA_FLAG);
+}
+
+/***** Magnetic field ***/
+static ssize_t akm_delay_mag_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_delay_show(
+		dev_get_drvdata(dev), buf, MAG_DATA_FLAG);
+}
+static ssize_t akm_delay_mag_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_delay_store(
+		dev_get_drvdata(dev), buf, count, MAG_DATA_FLAG);
+}
+
+/***** Fusion ***/
+static ssize_t akm_delay_fusion_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_delay_show(
+		dev_get_drvdata(dev), buf, FUSION_DATA_FLAG);
+}
+static ssize_t akm_delay_fusion_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_delay_store(
+		dev_get_drvdata(dev), buf, count, FUSION_DATA_FLAG);
+}
+
+/***** accel (binary) ***/
+static ssize_t akm_bin_accel_write(
+	struct file *file,
+	struct kobject *kobj,
+	struct bin_attribute *attr,
+		char *buf,
+		loff_t pos,
+		size_t size)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	int16_t *accel_data;
+
+	if (size == 0)
+		return 0;
+
+	accel_data = (int16_t *)buf;
+
+	mutex_lock(&akm->accel_mutex);
+	akm->accel_data[0] = accel_data[0];
+	akm->accel_data[1] = accel_data[1];
+	akm->accel_data[2] = accel_data[2];
+	mutex_unlock(&akm->accel_mutex);
+
+	dev_vdbg(&akm->i2c->dev, "accel:%d,%d,%d\n",
+			accel_data[0], accel_data[1], accel_data[2]);
+
+	return size;
+}
+
+
+#if AKM_DEBUG_IF
+static ssize_t akm_sysfs_mode_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	long mode = 0;
+
+	if (NULL == buf)
+		return -EINVAL;
+
+	if (0 == count)
+		return 0;
+
+	if (kstrtol(buf, AKM_BASE_NUM, &mode))
+		return -EINVAL;
+
+	if (AKECS_SetMode(akm, (uint8_t)mode) < 0)
+		return -EINVAL;
+
+	return 1;
+}
+
+static ssize_t akm_buf_print(
+	char *buf, uint8_t *data, size_t num)
+{
+	int sz, i;
+	char *cur;
+	size_t cur_len;
+
+	cur = buf;
+	cur_len = PAGE_SIZE;
+	sz = snprintf(cur, cur_len, "(HEX):");
+	if (sz < 0)
+		return sz;
+	cur += sz;
+	cur_len -= sz;
+	for (i = 0; i < num; i++) {
+		sz = snprintf(cur, cur_len, "%02X,", *data);
+		if (sz < 0)
+			return sz;
+		cur += sz;
+		cur_len -= sz;
+		data++;
+	}
+	sz = snprintf(cur, cur_len, "\n");
+	if (sz < 0)
+		return sz;
+	cur += sz;
+
+	return (ssize_t)(cur - buf);
+}
+
+static ssize_t akm_sysfs_bdata_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	uint8_t rbuf[AKM_SENSOR_DATA_SIZE];
+
+	mutex_lock(&akm->sensor_mutex);
+	memcpy(&rbuf, akm->sense_data, sizeof(rbuf));
+	mutex_unlock(&akm->sensor_mutex);
+
+	return akm_buf_print(buf, rbuf, AKM_SENSOR_DATA_SIZE);
+}
+
+static ssize_t akm_sysfs_asa_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	int err;
+	uint8_t asa[3];
+
+	err = AKECS_SetMode(akm, AKM_MODE_FUSE_ACCESS);
+	if (err < 0)
+		return err;
+
+	asa[0] = AKM_FUSE_1ST_ADDR;
+	err = akm_i2c_rxdata(akm->i2c, asa, 3);
+	if (err < 0)
+		return err;
+
+	err = AKECS_SetMode(akm, AKM_MODE_POWERDOWN);
+	if (err < 0)
+		return err;
+
+	return akm_buf_print(buf, asa, 3);
+}
+
+static ssize_t akm_sysfs_regs_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	/* The total number of registers depends on the device. */
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	int err;
+	uint8_t regs[AKM_REGS_SIZE];
+
+	/* This function does not lock mutex obj */
+	regs[0] = AKM_REGS_1ST_ADDR;
+	err = akm_i2c_rxdata(akm->i2c, regs, AKM_REGS_SIZE);
+	if (err < 0)
+		return err;
+
+	return akm_buf_print(buf, regs, AKM_REGS_SIZE);
+}
+#endif
+
+static struct device_attribute akm_compass_attributes[] = {
+	__ATTR(enable_acc   , 0660, akm_enable_acc_show   , akm_enable_acc_store),
+	__ATTR(enable_mag   , 0660, akm_enable_mag_show   , akm_enable_mag_store),
+	__ATTR(enable_fusion, 0660, akm_enable_fusion_show, akm_enable_fusion_store),
+	__ATTR(delay_acc    , 0660, akm_delay_acc_show    , akm_delay_acc_store),
+	__ATTR(delay_mag    , 0660, akm_delay_mag_show    , akm_delay_mag_store),
+	__ATTR(delay_fusion , 0660, akm_delay_fusion_show , akm_delay_fusion_store),
+#if AKM_DEBUG_IF
+	__ATTR(mode,  0220, NULL, akm_sysfs_mode_store),
+	__ATTR(bdata, 0440, akm_sysfs_bdata_show, NULL),
+	__ATTR(asa,   0440, akm_sysfs_asa_show, NULL),
+	__ATTR(regs,  0440, akm_sysfs_regs_show, NULL),
+#endif
+	__ATTR_NULL,
+};
+
+static struct bin_attribute akm_compass_bin_attributes[] = {
+	__BIN_ATTR(accel, 0220, NULL, akm_bin_accel_write, 6),
+	__BIN_ATTR_NULL
+};
+
+static char const *const device_link_name = "i2c";
+static dev_t const akm_compass_device_dev_t = MKDEV(MISC_MAJOR, 240);
+
+static int create_sysfs_interfaces(struct akm_compass_data *akm)
+{
+	int err;
+
+	if (NULL == akm)
+		return -EINVAL;
+
+	err = 0;
+
+	akm->compass = class_create(THIS_MODULE, AKM_SYSCLS_NAME);
+	if (IS_ERR(akm->compass)) {
+		err = PTR_ERR(akm->compass);
+		goto exit_class_create_failed;
+	}
+
+	akm->class_dev = device_create(
+						akm->compass,
+						NULL,
+						akm_compass_device_dev_t,
+						akm,
+						AKM_SYSDEV_NAME);
+	if (IS_ERR(akm->class_dev)) {
+		err = PTR_ERR(akm->class_dev);
+		goto exit_class_device_create_failed;
+	}
+
+	err = sysfs_create_link(
+			&akm->class_dev->kobj,
+			&akm->i2c->dev.kobj,
+			device_link_name);
+	if (0 > err)
+		goto exit_sysfs_create_link_failed;
+
+	err = create_device_attributes(
+			akm->class_dev,
+			akm_compass_attributes);
+	if (0 > err)
+		goto exit_device_attributes_create_failed;
+
+	err = create_device_binary_attributes(
+			&akm->class_dev->kobj,
+			akm_compass_bin_attributes);
+	if (0 > err)
+		goto exit_device_binary_attributes_create_failed;
+
+	return err;
+
+exit_device_binary_attributes_create_failed:
+	remove_device_attributes(akm->class_dev, akm_compass_attributes);
+exit_device_attributes_create_failed:
+	sysfs_remove_link(&akm->class_dev->kobj, device_link_name);
+exit_sysfs_create_link_failed:
+	device_destroy(akm->compass, akm_compass_device_dev_t);
+exit_class_device_create_failed:
+	akm->class_dev = NULL;
+	class_destroy(akm->compass);
+exit_class_create_failed:
+	akm->compass = NULL;
+	return err;
+}
+
+static void remove_sysfs_interfaces(struct akm_compass_data *akm)
+{
+	if (NULL == akm)
+		return;
+
+	if (NULL != akm->class_dev) {
+		remove_device_binary_attributes(
+			&akm->class_dev->kobj,
+			akm_compass_bin_attributes);
+		remove_device_attributes(
+			akm->class_dev,
+			akm_compass_attributes);
+		sysfs_remove_link(
+			&akm->class_dev->kobj,
+			device_link_name);
+		akm->class_dev = NULL;
+	}
+	if (NULL != akm->compass) {
+		device_destroy(
+			akm->compass,
+			akm_compass_device_dev_t);
+		class_destroy(akm->compass);
+		akm->compass = NULL;
+	}
+}
+
+
+/***** akm input device functions ***********************************/
+static int akm_compass_input_init(
+	struct input_dev **input)
+{
+	int err = 0;
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	/* Declare input device */
+	*input = input_allocate_device();
+	if (!*input)
+		return -ENOMEM;
+
+	/* Setup input device */
+	set_bit(EV_ABS, (*input)->evbit);
+	/* Accelerometer (720 x 16G)*/
+	input_set_abs_params(*input, ABS_X,
+			-11520, 11520, 0, 0);
+	input_set_abs_params(*input, ABS_Y,
+			-11520, 11520, 0, 0);
+	input_set_abs_params(*input, ABS_Z,
+			-11520, 11520, 0, 0);
+	input_set_abs_params(*input, ABS_RX,
+			0, 3, 0, 0);
+	/* Magnetic field (limited to 16bit) */
+	input_set_abs_params(*input, ABS_RY,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_RZ,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_THROTTLE,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_RUDDER,
+			0, 3, 0, 0);
+
+	/* Orientation (degree in Q6 format) */
+	/*  yaw[0,360) pitch[-180,180) roll[-90,90) */
+	input_set_abs_params(*input, ABS_HAT0Y,
+			0, 23040, 0, 0);
+	input_set_abs_params(*input, ABS_HAT1X,
+			-11520, 11520, 0, 0);
+	input_set_abs_params(*input, ABS_HAT1Y,
+			-5760, 5760, 0, 0);
+	/* Rotation Vector [-1,+1] in Q14 format */
+	input_set_abs_params(*input, ABS_TILT_X,
+			-16384, 16384, 0, 0);
+	input_set_abs_params(*input, ABS_TILT_Y,
+			-16384, 16384, 0, 0);
+	input_set_abs_params(*input, ABS_TOOL_WIDTH,
+			-16384, 16384, 0, 0);
+	input_set_abs_params(*input, ABS_VOLUME,
+			-16384, 16384, 0, 0);
+
+	/* Report the dummy value */
+	input_set_abs_params(*input, ABS_MISC,
+			INT_MIN, INT_MAX, 0, 0);
+
+	input_set_capability(*input, EV_REL, SYN_TIME_SEC);
+	input_set_capability(*input, EV_REL, SYN_TIME_NSEC);
+
+	/* Set name */
+	(*input)->name = AKM_INPUT_DEVICE_NAME;
+
+	/* Register */
+	err = input_register_device(*input);
+	if (err) {
+        printk("%s:%d, ACHEUL error: %d", __FUNCTION__, __LINE__, err);
+		input_free_device(*input);
+		return err;
+	}
+
+    printk("%s:%d, ACHEUL end: %d", __FUNCTION__, __LINE__, err);
+	return err;
+}
+
+/***** akm functions ************************************************/
+static irqreturn_t akm_compass_irq(int irq, void *handle)
+{
+	struct akm_compass_data *akm = handle;
+	uint8_t buffer[AKM_SENSOR_DATA_SIZE];
+	int err;
+
+	memset(buffer, 0, sizeof(buffer));
+
+	/***** lock *****/
+	mutex_lock(&akm->sensor_mutex);
+
+	/* Read whole data */
+	buffer[0] = AKM_REG_STATUS;
+	err = akm_i2c_rxdata(akm->i2c, buffer, AKM_SENSOR_DATA_SIZE);
+	if (err < 0) {
+		dev_err(&akm->i2c->dev, "IRQ I2C error.");
+		mutex_unlock(&akm->sensor_mutex);
+		/***** unlock *****/
+
+		return IRQ_HANDLED;
+	}
+	/* Check ST bit */
+	if (!(AKM_DRDY_IS_HIGH(buffer[0])))
+		goto work_func_none;
+
+	memcpy(akm->sense_data, buffer, AKM_SENSOR_DATA_SIZE);
+
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+	atomic_set(&akm->drdy, 1);
+	wake_up(&akm->drdy_wq);
+
+	dev_vdbg(&akm->i2c->dev, "IRQ handled.");
+	return IRQ_HANDLED;
+
+work_func_none:
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+	dev_vdbg(&akm->i2c->dev, "IRQ not handled.");
+	return IRQ_NONE;
+}
+
+static int akm_compass_suspend(struct device *dev)
+{
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (AKM_IS_MAG_DATA_ENABLED() && akm->auto_report) {
+		if (akm->use_hrtimer)
+			hrtimer_cancel(&akm->poll_timer);
+		else
+			cancel_delayed_work_sync(&akm->dwork);
+	}
+
+	ret = AKECS_SetMode(akm, AKM_MODE_POWERDOWN);
+	if (ret)
+		dev_warn(&akm->i2c->dev, "Failed to set to POWERDOWN mode.\n");
+
+	akm->state.power_on = akm->power_enabled;
+	if (akm->state.power_on)
+		akm_compass_power_set(akm, false);
+
+	ret = pinctrl_select_state(akm->pinctrl, akm->pin_sleep);
+	if (ret)
+		dev_err(dev, "Can't select pinctrl state\n");
+
+	dev_dbg(&akm->i2c->dev, "suspended\n");
+
+	return ret;
+}
+
+static int akm_compass_resume(struct device *dev)
+{
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	int ret = 0;
+	uint8_t mode;
+
+	ret = pinctrl_select_state(akm->pinctrl, akm->pin_default);
+	if (ret)
+		dev_err(dev, "Can't select pinctrl state\n");
+
+	if (akm->state.power_on) {
+		ret = akm_compass_power_set(akm, true);
+		if (ret) {
+			dev_err(dev, "Sensor power resume fail!\n");
+			goto exit;
+		}
+
+		if (AKM_IS_MAG_DATA_ENABLED() && akm->auto_report) {
+			mode = akm_select_frequency(akm->delay[MAG_DATA_FLAG]);
+			ret = AKECS_SetMode(akm, mode);
+			if (ret < 0) {
+				dev_err(&akm->i2c->dev, "Failed to set to mode(%d)\n",
+						mode);
+				goto exit;
+			}
+			if (akm->use_hrtimer)
+				hrtimer_start(&akm->poll_timer,
+					ns_to_ktime(akm->delay[MAG_DATA_FLAG]),
+					HRTIMER_MODE_REL);
+			else
+				queue_delayed_work(akm->work_queue, &akm->dwork,
+					(unsigned long)nsecs_to_jiffies64(
+						akm->delay[MAG_DATA_FLAG]));
+		}
+	}
+
+	dev_dbg(&akm->i2c->dev, "resumed\n");
+
+exit:
+	return ret;
+}
+
+static int akm09911_i2c_check_device(struct i2c_client *client)
+{
+	/* AK09911 specific function */
+	struct akm_compass_data *akm                = i2c_get_clientdata(client);
+	int                      err                = 0;
+    char*                    akm_compass_device = "UNKNOWN";
+
+    printk("%s:%d, ACHEUL, checking device", __FUNCTION__, __LINE__);
+
+	akm->sense_info[0] = AK09911_REG_WIA1;
+	err                = akm_i2c_rxdata(client, akm->sense_info, AKM_SENSOR_INFO_SIZE);
+
+	if (err < 0){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, err);
+		return err;
+    }
+
+	/* Check read data */
+    switch (akm->sense_info[1])
+    {
+        case AK09911_WIA2_VALUE: akm_compass_device = "AK09911";
+                                 break;
+        case AK09916_WIA2_VALUE: akm_compass_device = "AK09916";
+                                 break;
+        case AK09919_WIA2_VALUE: akm_compass_device = "AK09919";
+                                 break;
+        default                : dev_err(&client->dev, "The device is not AKM Compass WIA2(0x%02x)", akm->sense_info[1]);
+                                 printk("%s:%d, ACHEUL, unsupported compass: 0x%02X", __FUNCTION__, __LINE__, akm->sense_info[1]);
+                                 return -ENXIO;
+    }
+
+    dev_info(&client->dev, "AKM-Chip is: %s", akm_compass_device);
+    printk  ("%s:%d, ACHEUL, AKM-Chip is: %s", __FUNCTION__, __LINE__, akm_compass_device);
+
+	/* ak9916 don't need read fuse, is value fixed 0x00 */
+	if ((akm->sense_info[1] == AK09916_WIA2_VALUE) ||
+        (akm->sense_info[1] == AK09919_WIA2_VALUE)  )
+    {
+		akm->sense_conf[0] = akm->sense_conf[1] = akm->sense_conf[2] = 0x00;
+	}
+	else
+	{
+		/* Set FUSE access mode */
+		err = AKECS_SetMode(akm, AK09911_MODE_FUSE_ACCESS);
+		if (err < 0)
+			return err;
+
+		akm->sense_conf[0] = AK09911_FUSE_ASAX;
+		err = akm_i2c_rxdata(client, akm->sense_conf, AKM_SENSOR_CONF_SIZE);
+		if (err < 0)
+			return err;
+		}
+
+	err = AKECS_SetMode(akm, AK09911_MODE_POWERDOWN);
+	if (err < 0)
+    {
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, err);
+		return err;
+    }
+
+    printk("%s:%d, ACHEUL, device checked", __FUNCTION__, __LINE__);
+	return err;
+}// akm09911_i2c_check_device
+
+static int akm_compass_power_set(struct akm_compass_data *data, bool on)
+{
+	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	if (!on && data->power_enabled) {
+#ifdef AKM_REGULATOR_CONTROL_ENABLE
+		rc = regulator_disable(data->vdd);
+		if (rc) {
+			dev_err(&data->i2c->dev,
+				"Regulator vdd disable failed rc=%d\n", rc);
+			goto err_vdd_disable;
+		}
+
+		rc = regulator_disable(data->vio);
+		if (rc) {
+			dev_err(&data->i2c->dev,
+				"Regulator vio disable failed rc=%d\n", rc);
+			goto err_vio_disable;
+		}
+#endif
+		data->power_enabled = false;
+		return rc;
+	} else if (on && !data->power_enabled) {
+#ifdef AKM_REGULATOR_CONTROL_ENABLE
+		rc = regulator_enable(data->vdd);
+		if (rc) {
+			dev_err(&data->i2c->dev,
+				"Regulator vdd enable failed rc=%d\n", rc);
+			goto err_vdd_enable;
+		}
+
+		rc = regulator_enable(data->vio);
+		if (rc) {
+			dev_err(&data->i2c->dev,
+				"Regulator vio enable failed rc=%d\n", rc);
+			goto err_vio_enable;
+		}
+#endif
+		data->power_enabled = true;
+
+		/*
+		 * The max time for the power supply rise time is 50ms.
+		 * Use 80ms to make sure it meets the requirements.
+		 */
+		msleep(80);
+		return rc;
+	} else {
+		dev_warn(&data->i2c->dev,
+				"Power on=%d. enabled=%d\n",
+				on, data->power_enabled);
+		return rc;
+	}
+
+#ifdef AKM_REGULATOR_CONTROL_ENABLE
+err_vio_enable:
+	regulator_disable(data->vio);
+err_vdd_enable:
+	return rc;
+
+err_vio_disable:
+	if (regulator_enable(data->vdd))
+		dev_warn(&data->i2c->dev, "Regulator vdd enable failed\n");
+err_vdd_disable:
+#endif
+	return rc;
+}
+
+static int akm_compass_power_init(struct akm_compass_data *data, bool on)
+{
+	int rc;
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	if (!on) {
+		if (regulator_count_voltages(data->vdd) > 0)
+			regulator_set_voltage(data->vdd, 0,
+				AKM09911_VDD_MAX_UV);
+
+		regulator_put(data->vdd);
+
+		if (regulator_count_voltages(data->vio) > 0)
+			regulator_set_voltage(data->vio, 0,
+				AKM09911_VIO_MAX_UV);
+
+		regulator_put(data->vio);
+
+	} else {
+		data->vdd = regulator_get(&data->i2c->dev, "vdd");
+		if (IS_ERR(data->vdd)) {
+			rc = PTR_ERR(data->vdd);
+			dev_err(&data->i2c->dev,
+				"Regulator get failed vdd rc=%d\n", rc);
+			return rc;
+		}
+
+		if (regulator_count_voltages(data->vdd) > 0) {
+			rc = regulator_set_voltage(data->vdd,
+				AKM09911_VDD_MIN_UV, AKM09911_VDD_MAX_UV);
+			if (rc) {
+				dev_err(&data->i2c->dev,
+					"Regulator set failed vdd rc=%d\n",
+					rc);
+				goto reg_vdd_put;
+			}
+		}
+
+		data->vio = regulator_get(&data->i2c->dev, "vio");
+		if (IS_ERR(data->vio)) {
+			rc = PTR_ERR(data->vio);
+			dev_err(&data->i2c->dev,
+				"Regulator get failed vio rc=%d\n", rc);
+			goto reg_vdd_set;
+		}
+
+		if (regulator_count_voltages(data->vio) > 0) {
+			rc = regulator_set_voltage(data->vio,
+				AKM09911_VIO_MIN_UV, AKM09911_VIO_MAX_UV);
+			if (rc) {
+				dev_err(&data->i2c->dev,
+				"Regulator set failed vio rc=%d\n", rc);
+				goto reg_vio_put;
+			}
+		}
+	}
+
+	return 0;
+
+reg_vio_put:
+	regulator_put(data->vio);
+reg_vdd_set:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, AKM09911_VDD_MAX_UV);
+reg_vdd_put:
+	regulator_put(data->vdd);
+	return rc;
+}
+
+#ifdef CONFIG_OF
+static int akm_compass_parse_dt(struct device *dev, struct akm_compass_data *akm)
+{
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	int rc;
+    printk("%s:%d, ACHEUL in", __FUNCTION__, __LINE__);
+
+	rc = of_property_read_u32(np, "akm,layout", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read akm,layout\n");
+		return rc;
+	} else {
+		akm->layout = temp_val;
+	}
+
+	akm->auto_report = of_property_read_bool(np, "akm,auto-report");
+	akm->use_hrtimer = of_property_read_bool(np, "akm,use-hrtimer");
+	akm->gpio_rstn   = of_get_named_gpio_flags(dev->of_node, "akm,gpio_rstn", 0, NULL);
+
+#if 0
+	if (!gpio_is_valid(akm->gpio_rstn)) {
+		dev_err(dev, "gpio reset pin %d is invalid.\n", akm->gpio_rstn);
+		return -EINVAL;
+	}
+#endif // 0
+
+    printk("%s:%d, ACHEUL out", __FUNCTION__, __LINE__);
+	return 0;
+}
+#else
+static int akm_compass_parse_dt(struct device *dev,
+				struct akm_compass_data *akm)
+{
+	return -EINVAL;
+}
+#endif /* !CONFIG_OF */
+
+static int akm_pinctrl_init(struct akm_compass_data *akm)
+{
+	struct i2c_client *client = akm->i2c;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	akm->pinctrl = devm_pinctrl_get(&client->dev);
+	if (IS_ERR_OR_NULL(akm->pinctrl)) {
+		dev_err(&client->dev, "Failed to get pinctrl\n");
+		return PTR_ERR(akm->pinctrl);
+	}
+
+	akm->pin_default = pinctrl_lookup_state(akm->pinctrl, "default");
+	if (IS_ERR_OR_NULL(akm->pin_default)) {
+		dev_err(&client->dev, "Failed to look up default state\n");
+		return PTR_ERR(akm->pin_default);
+	}
+
+	akm->pin_sleep = pinctrl_lookup_state(akm->pinctrl, "sleep");
+	if (IS_ERR_OR_NULL(akm->pin_sleep)) {
+		dev_err(&client->dev, "Failed to look up sleep state\n");
+		return PTR_ERR(akm->pin_sleep);
+	}
+
+	return 0;
+}
+
+static int akm_report_data(struct akm_compass_data *akm)
+{
+	uint8_t dat_buf[AKM_SENSOR_DATA_SIZE];/* for GET_DATA */
+	int ret;
+	int mag_x, mag_y, mag_z;
+	int tmp;
+	uint8_t mode;
+
+    printk("%s:%d, ACHEUL in", __FUNCTION__, __LINE__);
+
+	ret = AKECS_GetData_Poll(akm, dat_buf, AKM_SENSOR_DATA_SIZE);
+	if (ret) {
+		dev_err(&akm->i2c->dev, "Get data failed.\n");
+		return -EIO;
+	}
+
+	if (STATUS_ERROR(dat_buf[8])) {
+		dev_warn(&akm->i2c->dev, "Status error. Reset...\n");
+		AKECS_Reset(akm, 0);
+		mode = akm_select_frequency(akm->delay[MAG_DATA_FLAG]);
+		AKECS_SetMode(akm, mode);
+
+		return -EIO;
+	}
+
+	if(akm->auto_report)
+		get_monotonic_boottime(&akm->ts);
+
+	tmp = (int)((int16_t)(dat_buf[2]<<8)+((int16_t)dat_buf[1]));
+	tmp = tmp * akm->sense_conf[0] / 128 + tmp;
+	mag_x = tmp;
+
+	tmp = (int)((int16_t)(dat_buf[4]<<8)+((int16_t)dat_buf[3]));
+	tmp = tmp * akm->sense_conf[1] / 128 + tmp;
+	mag_y = tmp;
+
+	tmp = (int)((int16_t)(dat_buf[6]<<8)+((int16_t)dat_buf[5]));
+	tmp = tmp * akm->sense_conf[2] / 128 + tmp;
+	mag_z = tmp;
+
+	dev_dbg(&akm->i2c->dev, "mag_x:%d mag_y:%d mag_z:%d\n",
+			mag_x, mag_y, mag_z);
+	dev_dbg(&akm->i2c->dev, "raw data: %d %d %d %d %d %d %d %d\n",
+			dat_buf[0], dat_buf[1], dat_buf[2], dat_buf[3],
+			dat_buf[4], dat_buf[5], dat_buf[6], dat_buf[7]);
+	dev_dbg(&akm->i2c->dev, "asa: %d %d %d\n", akm->sense_conf[0],
+			akm->sense_conf[1], akm->sense_conf[2]);
+
+    printk("%s:%d, ACHEUL, report data: mag_x: %d mag_y: %d mag_z: %d", __FUNCTION__, __LINE__,  mag_x, mag_y, mag_z);
+
+	switch (akm->layout) {
+	case 0:
+	case 1:
+		/* Fall into the default direction */
+		break;
+	case 2:
+		tmp = mag_x;
+		mag_x = mag_y;
+		mag_y = -tmp;
+		break;
+	case 3:
+		mag_x = -mag_x;
+		mag_y = -mag_y;
+		break;
+	case 4:
+		tmp = mag_x;
+		mag_x = -mag_y;
+		mag_y = tmp;
+		break;
+	case 5:
+		mag_x = -mag_x;
+		mag_z = -mag_z;
+		break;
+	case 6:
+		tmp = mag_x;
+		mag_x = mag_y;
+		mag_y = tmp;
+		mag_z = -mag_z;
+		break;
+	case 7:
+		mag_y = -mag_y;
+		mag_z = -mag_z;
+		break;
+	case 8:
+		tmp = mag_x;
+		mag_x = -mag_y;
+		mag_y = -tmp;
+		mag_z = -mag_z;
+		break;
+	}
+
+	input_report_abs(akm->input, ABS_X, mag_x);
+	input_report_abs(akm->input, ABS_Y, mag_y);
+	input_report_abs(akm->input, ABS_Z, mag_z);
+	input_event(akm->input,	EV_REL, SYN_TIME_SEC, akm->ts.tv_sec);
+	input_event(akm->input,	EV_REL, SYN_TIME_NSEC, akm->ts.tv_nsec);
+
+	/* avoid eaten by input subsystem framework */
+	if ((mag_x == akm->last_x) && (mag_y == akm->last_y) &&
+			(mag_z == akm->last_z))
+		input_report_abs(akm->input, ABS_MISC, akm->rep_cnt++);
+
+	akm->last_x = mag_x;
+	akm->last_y = mag_y;
+	akm->last_z = mag_z;
+
+	input_sync(akm->input);
+
+    printk("%s:%d, ACHEUL out", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static void akm_dev_poll(struct work_struct *work)
+{
+	struct akm_compass_data *akm;
+	int ret;
+
+	akm = container_of((struct delayed_work *)work, struct akm_compass_data,  dwork);
+
+	ret = akm_report_data(akm);
+	if (ret < 0) {
+		dev_warn(&akm->i2c->dev, "Failed to report data\n");
+    }
+
+	if (!akm->use_hrtimer) {
+		queue_delayed_work(akm->work_queue, &akm->dwork, (unsigned long)nsecs_to_jiffies64(akm->delay[MAG_DATA_FLAG]));
+    }
+}
+
+static enum hrtimer_restart akm_timer_func(struct hrtimer *timer)
+{
+	struct akm_compass_data *akm;
+
+	akm = container_of(timer, struct akm_compass_data, poll_timer);
+
+	queue_work(akm->work_queue, &akm->dwork.work);
+	hrtimer_forward_now(&akm->poll_timer,
+			ns_to_ktime(akm->delay[MAG_DATA_FLAG]));
+
+	return HRTIMER_RESTART;
+}
+
+static int case_test(struct akm_compass_data *akm, const char test_name[],
+		const int testdata, const int lo_limit, const int hi_limit,
+		int *fail_total)
+{
+	/* Pass:0, Fail:-1 */
+	int result = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	if (fail_total == NULL)
+		return -EINVAL;
+
+	if (strcmp(test_name, "START") == 0) {
+		dev_dbg(&akm->i2c->dev, "----------------------------------------------------------\n");
+		dev_dbg(&akm->i2c->dev, "Test Name    Fail    Test Data    [      Low         High]\n");
+		dev_dbg(&akm->i2c->dev, "----------------------------------------------------------\n");
+	} else if (strcmp(test_name, "END") == 0) {
+		dev_dbg(&akm->i2c->dev, "----------------------------------------------------------\n");
+		if (*fail_total == 0)
+			dev_dbg(&akm->i2c->dev, "Factory shipment test passed.\n\n");
+		else
+			dev_dbg(&akm->i2c->dev, "%d test cases failed.\n\n",
+					*fail_total);
+	} else {
+		if ((testdata < lo_limit) || (testdata > hi_limit)) {
+			result = -1;
+			*fail_total += 1;
+		}
+
+		dev_dbg(&akm->i2c->dev, " %-10s      %c    %9d    [%9d    %9d]\n",
+				 test_name, ((result == 0) ? ('.') : ('F')),
+				 testdata, lo_limit, hi_limit);
+	}
+
+	return result;
+}
+
+static int akm_self_test(struct sensors_classdev *sensors_cdev)
+{
+	struct akm_compass_data *akm = container_of(sensors_cdev,
+			struct akm_compass_data, cdev);
+	uint8_t i2c_data[AKM_SENSOR_DATA_SIZE];
+	int hdata[AKM09911_AXIS_COUNT];
+	int asax, asay, asaz;
+	int count;
+	int ret;
+	int fail_total = 0;
+	uint8_t mode;
+	bool power_enabled = akm->power_enabled ? true : false;
+
+	mutex_lock(&akm->op_mutex);
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	asax = akm->sense_conf[AKM09911_AXIS_X];
+	asay = akm->sense_conf[AKM09911_AXIS_Y];
+	asaz = akm->sense_conf[AKM09911_AXIS_Z];
+
+	if (!power_enabled) {
+		ret = akm_compass_power_set(akm, true);
+		if (ret) {
+			dev_err(&akm->i2c->dev, "Power up failed.\n");
+			goto exit;
+		}
+	} else {
+		i2c_data[0] = AKM_REG_MODE;
+		ret = akm_i2c_rxdata(akm->i2c, i2c_data, 1);
+		if (ret < 0) {
+			dev_err(&akm->i2c->dev, "Get mode failed.\n");
+			goto exit;
+		}
+		mode = i2c_data[1];
+	}
+
+	ret = AKECS_Reset(akm, 0);
+	if (ret < 0) {
+		dev_err(&akm->i2c->dev, "Reset failed.\n");
+		goto exit;
+	}
+
+	/* start test */
+	case_test(akm, "START", 0, 0, 0, &fail_total);
+
+	case_test(akm, TLIMIT_TN_ASAX_09911, asax, TLIMIT_LO_ASAX_09911,
+			TLIMIT_HI_ASAX_09911, &fail_total);
+	case_test(akm, TLIMIT_TN_ASAY_09911, asay, TLIMIT_LO_ASAY_09911,
+			TLIMIT_HI_ASAY_09911, &fail_total);
+	case_test(akm, TLIMIT_TN_ASAZ_09911, asaz, TLIMIT_LO_ASAZ_09911,
+			TLIMIT_HI_ASAZ_09911, &fail_total);
+
+	ret = AKECS_SetMode(akm, AK09911_MODE_SNG_MEASURE);
+	if (ret < 0) {
+		dev_err(&akm->i2c->dev, "Set to single measurement failed.\n");
+		goto exit;
+	}
+
+	count = AKM09911_RETRY_COUNT;
+	do {
+		/* The typical time for single measurement is 7.2ms */
+		ret = AKECS_GetData_Poll(akm, i2c_data, AKM_SENSOR_DATA_SIZE);
+		if (ret == -EAGAIN)
+			usleep_range(1000, 10000);
+	} while ((ret == -EAGAIN) && (--count));
+
+	if (!count) {
+		dev_err(&akm->i2c->dev, "Timeout get valid data.\n");
+		goto exit;
+	}
+
+	hdata[AKM09911_AXIS_X] = (s16)(i2c_data[1] | (i2c_data[2] << 8));
+	hdata[AKM09911_AXIS_Y] = (s16)(i2c_data[3] | (i2c_data[4] << 8));
+	hdata[AKM09911_AXIS_Z] = (s16)(i2c_data[5] | (i2c_data[6] << 8));
+
+	i2c_data[0] &= 0x7F;
+	case_test(akm, TLIMIT_TN_SNG_ST1_09911,
+	       (int)i2c_data[0], TLIMIT_LO_SNG_ST1_09911,
+		TLIMIT_HI_SNG_ST1_09911, &fail_total);
+
+	case_test(akm, TLIMIT_TN_SNG_HX_09911, hdata[0], TLIMIT_LO_SNG_HX_09911,
+			TLIMIT_HI_SNG_HX_09911, &fail_total);
+	case_test(akm, TLIMIT_TN_SNG_HY_09911, hdata[1], TLIMIT_LO_SNG_HY_09911,
+			TLIMIT_HI_SNG_HY_09911, &fail_total);
+	case_test(akm, TLIMIT_TN_SNG_HZ_09911, hdata[2], TLIMIT_LO_SNG_HZ_09911,
+			TLIMIT_HI_SNG_HZ_09911, &fail_total);
+
+	case_test(akm, TLIMIT_TN_SNG_ST2_09911, (int)i2c_data[8],
+			TLIMIT_LO_SNG_ST2_09911, TLIMIT_HI_SNG_ST2_09911,
+			&fail_total);
+
+	/* self-test mode */
+	ret = AKECS_SetMode(akm, AK09911_MODE_SELF_TEST);
+	if (ret < 0) {
+		dev_err(&akm->i2c->dev, "Set to self test mode failed\n");
+		goto exit;
+	}
+
+	count = AKM09911_RETRY_COUNT;
+	do {
+		/* The typical time for single measurement is 7.2ms */
+		ret = AKECS_GetData_Poll(akm, i2c_data, AKM_SENSOR_DATA_SIZE);
+		if (ret == -EAGAIN)
+			usleep_range(1000, 10000);
+	} while ((ret == -EAGAIN) && (--count));
+
+	if (!count) {
+		dev_err(&akm->i2c->dev, "Timeout get valid data.\n");
+		goto exit;
+	}
+
+	i2c_data[0] &= 0x7F;
+
+	case_test(akm, TLIMIT_TN_SLF_ST1_09911, (int)i2c_data[0],
+			TLIMIT_LO_SLF_ST1_09911, TLIMIT_HI_SLF_ST1_09911,
+			&fail_total);
+
+	hdata[AKM09911_AXIS_X] = (s16)(i2c_data[1] | (i2c_data[2] << 8));
+	hdata[AKM09911_AXIS_Y] = (s16)(i2c_data[3] | (i2c_data[4] << 8));
+	hdata[AKM09911_AXIS_Z] = (s16)(i2c_data[5] | (i2c_data[6] << 8));
+
+	case_test(akm, TLIMIT_TN_SLF_RVHX_09911, (hdata[0])*(asax/128 + 1),
+			TLIMIT_LO_SLF_RVHX_09911, TLIMIT_HI_SLF_RVHX_09911,
+			&fail_total);
+
+	case_test(akm, TLIMIT_TN_SLF_RVHY_09911, (hdata[1])*(asay/128 + 1),
+			TLIMIT_LO_SLF_RVHY_09911, TLIMIT_HI_SLF_RVHY_09911,
+			&fail_total);
+
+	case_test(akm, TLIMIT_TN_SLF_RVHZ_09911, (hdata[2])*(asaz/128 + 1),
+			TLIMIT_LO_SLF_RVHZ_09911, TLIMIT_HI_SLF_RVHZ_09911,
+			&fail_total);
+
+	case_test(akm, TLIMIT_TN_SLF_ST2_09911, (int)i2c_data[8],
+			TLIMIT_LO_SLF_ST2_09911, TLIMIT_HI_SLF_ST2_09911,
+			&fail_total);
+
+	case_test(akm, "END", 0, 0, 0, &fail_total);
+	/* clean up */
+	if (!power_enabled) {
+		ret = akm_compass_power_set(akm, false);
+		if (ret) {
+			dev_err(&akm->i2c->dev, "Power down failed.\n");
+			goto exit;
+		}
+	} else {
+		/* Set measure mode */
+		i2c_data[0] = AKM_REG_MODE;
+		i2c_data[1] = mode;
+		ret = akm_i2c_txdata(akm->i2c, i2c_data, 2);
+		if (ret < 0) {
+			dev_err(&akm->i2c->dev, "restore mode failed\n");
+			goto exit;
+		}
+	}
+
+exit:
+	mutex_unlock(&akm->op_mutex);
+	return ((fail_total > 0) || ret) ? -EIO : 0;
+}
+
+int akm_compass_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct akm09911_platform_data *pdata;
+	int err = 0;
+	int i;
+
+    printk("%s:%d, printk ACHEUL in", __FUNCTION__, __LINE__);
+	dev_dbg(&client->dev, "\nACHEUL dev_dbg start probing.\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev,
+				"%s: check_functionality failed.", __func__);
+		err = -ENODEV;
+		goto exit0;
+	}
+
+	/* Allocate memory for driver data */
+	s_akm = kzalloc(sizeof(struct akm_compass_data), GFP_KERNEL);
+	if (!s_akm) {
+		dev_err(&client->dev,
+				"%s: memory allocation failed.", __func__);
+		err = -ENOMEM;
+		goto exit1;
+	}
+
+	/**** initialize variables in akm_compass_data *****/
+	init_waitqueue_head(&s_akm->drdy_wq);
+	init_waitqueue_head(&s_akm->open_wq);
+
+	mutex_init(&s_akm->sensor_mutex);
+	mutex_init(&s_akm->accel_mutex);
+	mutex_init(&s_akm->val_mutex);
+	mutex_init(&s_akm->op_mutex);
+
+	atomic_set(&s_akm->active, 0);
+	atomic_set(&s_akm->drdy, 0);
+
+	s_akm->enable_flag = 0;
+
+	/* Set to 1G in Android coordination, AKSC format */
+	s_akm->accel_data[0] = 0;
+	s_akm->accel_data[1] = 0;
+	s_akm->accel_data[2] = 720;
+
+	for (i = 0; i < AKM_NUM_SENSORS; i++)
+		s_akm->delay[i] = -1;
+
+	if (client->dev.of_node) {
+		err = akm_compass_parse_dt(&client->dev, s_akm);
+		if (err) {
+			dev_err(&client->dev,
+				"Unable to parse platfrom data err=%d\n", err);
+			goto exit2;
+		}
+	} else {
+		if (client->dev.platform_data) {
+			/* Copy platform data to local. */
+			pdata = client->dev.platform_data;
+			s_akm->layout = pdata->layout;
+			s_akm->gpio_rstn = pdata->gpio_RSTN;
+		} else {
+		/* Platform data is not available.
+		   Layout and information should be set by each application. */
+			s_akm->layout = 0;
+			s_akm->gpio_rstn = 0;
+			dev_warn(&client->dev, "%s: No platform data.",
+				__func__);
+		}
+	}
+
+	/***** I2C initialization *****/
+	s_akm->i2c = client;
+	/* set client data */
+	i2c_set_clientdata(client, s_akm);
+
+	/* initialize pinctrl */
+	if (!akm_pinctrl_init(s_akm)) {
+		err = pinctrl_select_state(s_akm->pinctrl, s_akm->pin_default);
+		if (err) {
+			dev_err(&client->dev, "Can't select pinctrl state\n");
+			goto exit2;
+		}
+	}
+
+	/* Pull up the reset pin */
+	AKECS_Reset(s_akm, 0);
+
+	/* check connection */
+	err = akm_compass_power_init(s_akm, 1);
+	if (err < 0)
+		goto exit2;
+	err = akm_compass_power_set(s_akm, 1);
+	if (err < 0)
+		goto exit3;
+
+	err = akm09911_i2c_check_device(client);
+	if (err < 0)
+		goto exit4;
+
+	/***** input *****/
+	err = akm_compass_input_init(&s_akm->input);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: input_dev register failed", __func__);
+		goto exit4;
+	}
+	input_set_drvdata(s_akm->input, s_akm);
+
+	/***** IRQ setup *****/
+	s_akm->irq = client->irq;
+
+	dev_dbg(&client->dev, "%s: IRQ is #%d.",
+			__func__, s_akm->irq);
+
+	if (s_akm->irq) {
+		err = request_threaded_irq(
+				s_akm->irq,
+				NULL,
+				akm_compass_irq,
+				IRQF_TRIGGER_HIGH|IRQF_ONESHOT,
+				dev_name(&client->dev),
+				s_akm);
+		if (err < 0) {
+			dev_err(&client->dev,
+				"%s: request irq failed.", __func__);
+			goto exit5;
+		}
+	} else if (s_akm->auto_report) {
+
+        printk("%s:%d, ACHEUL, auto report", __FUNCTION__, __LINE__);
+
+		if (s_akm->use_hrtimer) {
+			hrtimer_init(&s_akm->poll_timer, CLOCK_MONOTONIC,
+					HRTIMER_MODE_REL);
+			s_akm->poll_timer.function = akm_timer_func;
+			s_akm->work_queue = alloc_workqueue("akm_poll_work",
+				WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_HIGHPRI, 1);
+			INIT_WORK(&s_akm->dwork.work, akm_dev_poll);
+		} else {
+			s_akm->work_queue = alloc_workqueue("akm_poll_work", 0, 0);
+			INIT_DELAYED_WORK(&s_akm->dwork, akm_dev_poll);
+		}
+	}
+
+	/***** misc *****/
+	err = misc_register(&akm_compass_dev);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: akm_compass_dev register failed", __func__);
+		goto exit6;
+	}
+
+	/***** sysfs *****/
+	err = create_sysfs_interfaces(s_akm);
+	if (0 > err) {
+		dev_err(&client->dev,
+			"%s: create sysfs failed.", __func__);
+		goto exit7;
+	}
+
+	s_akm->cdev = sensors_cdev;
+	s_akm->cdev.sensors_enable = akm_enable_set;
+	s_akm->cdev.sensors_poll_delay = akm_poll_delay_set;
+	s_akm->cdev.sensors_self_test = akm_self_test;
+	s_akm->cdev.sensors_flush = akm_flush_set;
+
+	s_akm->delay[MAG_DATA_FLAG] = sensors_cdev.delay_msec * 1000000;
+
+	err = sensors_classdev_register(&client->dev, &s_akm->cdev);
+
+	if (err) {
+		dev_err(&client->dev, "class device create failed: %d\n", err);
+		goto exit8;
+	}
+
+	akm_compass_power_set(s_akm, true);
+
+	dev_info(&client->dev, "successfully probed.");
+	return 0;
+
+exit8:
+	remove_sysfs_interfaces(s_akm);
+exit7:
+	misc_deregister(&akm_compass_dev);
+exit6:
+	if (s_akm->irq)
+		free_irq(s_akm->irq, s_akm);
+exit5:
+	input_unregister_device(s_akm->input);
+exit4:
+	akm_compass_power_set(s_akm, 0);
+exit3:
+	akm_compass_power_init(s_akm, 0);
+exit2:
+	kfree(s_akm);
+exit1:
+exit0:
+
+    printk("%s:%d, printk ACHEUL out: %d", __FUNCTION__, __LINE__, err);
+	return err;
+}
+
+static int akm_compass_remove(struct i2c_client *client)
+{
+	struct akm_compass_data *akm = i2c_get_clientdata(client);
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	if (akm->auto_report) {
+		if (akm->use_hrtimer) {
+			hrtimer_cancel(&akm->poll_timer);
+			cancel_work_sync(&akm->dwork.work);
+		} else {
+			cancel_delayed_work_sync(&akm->dwork);
+		}
+		destroy_workqueue(akm->work_queue);
+	}
+
+	if (akm_compass_power_set(akm, 0))
+		dev_err(&client->dev, "power set failed.");
+	if (akm_compass_power_init(akm, 0))
+		dev_err(&client->dev, "power deinit failed.");
+	remove_sysfs_interfaces(akm);
+	sensors_classdev_unregister(&akm->cdev);
+
+    // ACHEUL
+	//if (misc_deregister(&akm_compass_dev) < 0)
+    //    dev_err(&client->dev, "misc deregister failed.");
+	misc_deregister(&akm_compass_dev);
+    // ACHEUL
+
+	if (akm->irq)
+		free_irq(akm->irq, akm);
+	input_unregister_device(akm->input);
+	kfree(akm);
+	dev_info(&client->dev, "successfully removed.");
+	return 0;
+}
+
+static const struct i2c_device_id akm_compass_id[] = {
+	{AKM_I2C_NAME, 0 },
+	{ }
+};
+
+static const struct dev_pm_ops akm_compass_pm_ops = {
+	.suspend	= akm_compass_suspend,
+	.resume		= akm_compass_resume,
+};
+
+static struct of_device_id akm09911_match_table[] = {
+	{ .compatible = "ak,ak09911", },
+	{ },
+};
+
+static struct i2c_driver akm_compass_driver = {
+	.probe		= akm_compass_probe,
+	.remove		= akm_compass_remove,
+	.id_table	= akm_compass_id,
+	.driver = {
+		.name	= AKM_I2C_NAME,
+		.owner  = THIS_MODULE,
+		.of_match_table = akm09911_match_table,
+		.pm		= &akm_compass_pm_ops,
+	},
+};
+
+static int __init akm_compass_init(void)
+{
+    int ret = 0;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	pr_info("AKM compass driver: initialize.");
+    ret = i2c_add_driver(&akm_compass_driver);
+
+    printk("%s:%d, ACHEUL ret: %d", __FUNCTION__, __LINE__, ret);
+
+	return ret;
+}
+
+static void __exit akm_compass_exit(void)
+{
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	pr_info("%s:%d, AKM compass driver: release.", __FUNCTION__, __LINE__);
+	i2c_del_driver(&akm_compass_driver);
+}
+
+module_init(akm_compass_init);
+module_exit(akm_compass_exit);
+
+MODULE_AUTHOR("Bruno Gauthier <bruno.gauthier@acheul.com>");
+MODULE_DESCRIPTION("ACHEUL AKM compass driver");
+MODULE_LICENSE("GPL");
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: apanel.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: arizona-haptics.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: ati_remote2.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: atlas_btns.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: atmel_captouch.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: axp20x-pek.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: bma150.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: cm109.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: cma3000_d0x.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: cma3000_d0x.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: cma3000_d0x_i2c.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: cobalt_btns.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: cpcap-pwrbutton.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: da9052_onkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: da9055_onkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: da9063_onkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: dm355evm_keys.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: drv260x.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: drv2665.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: drv2667.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: e3x0-button.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: gp2ap002a00f.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio-beeper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_axis.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_decoder.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_event.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_input.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_matrix.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_output.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: hisi_powerkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: hp_sdc_rtc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: ideapad_slidebar.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: ims-pcu.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: ixp4xx-beeper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: keyspan_remote.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: kxtj9.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: m68kspkr.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: max77693-haptic.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: max8925_onkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: max8997_haptic.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: mc13783-pwrbutton.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: mma8450.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: palmas-pwrbutton.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: pcap_keys.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: pcf50633-input.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: pcf8574_keypad.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: pcspkr.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: pm8941-pwrkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: pm8xxx-vibrator.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: pmic8xxx-pwrkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: powermate.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: pwm-beeper.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: pwm-vibra.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: qpnp-power-on.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: qti-haptics.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: rave-sp-pwrbutton.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: rb532_button.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: regulator-haptic.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: retu-pwrbutton.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: rk805-pwrkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: rotary_encoder.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: sc27xx-vibra.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: sgi_btns.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: sirfsoc-onkey.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: soc_button_array.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: sparcspkr.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: tps65218-pwrbutton.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: twl4030-pwrbutton.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: twl4030-vibra.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: twl6040-vibra.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: uinput.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: wistron_btns.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: wm831x-on.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: xen-kbdfront.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: yealink.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input/misc: yealink.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: mouse
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: mousedev.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: rmi4
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: serio
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: sparse-keymap.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: tablet
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/input: touchscreen
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: iommu
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: ipack
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: irqchip
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: isdn
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: leds
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: lightnvm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: macintosh
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: mailbox
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: mcb
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: md
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: media
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: memory
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: memstick
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: message
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: mfd
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: misc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: mmc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: mtd
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: mux
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: net
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: nfc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: ntb
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: nubus
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: nvdimm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: nvme
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: nvmem
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: of
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: opp
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: oprofile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: parisc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: parport
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: pci
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: pcmcia
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: perf
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: phy
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: pinctrl
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: platform
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: pnp
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: power
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: powercap
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: pps
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: ps3
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: ptp
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: pwm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: rapidio
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: ras
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: regulator
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: remoteproc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: reset
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: rpmsg
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: rtc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: s390
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: sbus
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: scsi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: sensors
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: sfi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: sh
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: siox
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: slimbus
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: sn
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: Kconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: actions
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: amlogic
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: atmel
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: bcm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: dove
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: fsl
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: gemini
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: imx
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: lantiq
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: mediatek
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: Kconfig
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: apr.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: boot_stats.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: cdsprm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: cmd-db.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: core_hang_detect.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: cpuss_dump.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: cx_ipeak.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: dcc_v2.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: ddr_stats.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: dfc_defs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: dfc_qmap.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: dfc_qmi.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: early_random.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: eud.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: event_timer.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: fsa4480-i2c.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: gladiator_erp.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: gladiator_hang_detect.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: glink_pkt.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: glink_probe.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: glink_ssr.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: hyp_core_ctl.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: icnss.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: icnss2
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: icnss_private.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: icnss_qmi.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: icnss_qmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: jtagv8-etm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: jtagv8.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc-kona.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc-lagoon.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc-lito.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc-sdm845.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc-slice.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc_events.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc_perfmon.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc_perfmon.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: lpm-stats.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: mdt_loader.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: mem-offline.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: memory_dump_v2.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: memshare
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: microdump_collector.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: minidump_log.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: minidump_private.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_adhoc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_arb_adhoc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_arb_rpmh.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_bimc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_bimc_adhoc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_bimc_rpmh.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_client_api.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_core.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_core.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_dbg.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_dbg_rpmh.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_fabric_adhoc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_fabric_rpmh.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_noc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_noc_adhoc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_noc_rpmh.c
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus/msm_bus_of.c msm-4.19/drivers/soc/qcom/msm_bus/msm_bus_of.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus/msm_bus_of.c	2024-04-16 19:15:01.520043055 +0000
+++ msm-4.19/drivers/soc/qcom/msm_bus/msm_bus_of.c	2024-04-20 18:36:20.826499294 +0000
@@ -43,6 +43,9 @@
 	int i = 0, j, ret, num_usecases = 0, num_paths, len;
 	const uint32_t *vec_arr = NULL;
 	bool mem_err = false;
+    const char *compatible = NULL;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!dev) {
 		pr_err("Error: Null device\n");
@@ -56,9 +59,13 @@
 		goto err;
 	}
 
+	of_property_read_string(of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
 	ret = of_property_read_string(of_node, "qcom,msm-bus,name",
 		&pdata->name);
 	if (ret) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		pr_err("Error: Client name not found\n");
 		goto err;
 	}
@@ -190,6 +197,8 @@
 	struct device_node *of_node;
 	struct msm_bus_scale_pdata *pdata = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!pdev) {
 		pr_err("Error: Null Platform device\n");
 		return NULL;
@@ -198,6 +207,7 @@
 	of_node = pdev->dev.of_node;
 	pdata = get_pdata(&pdev->dev, of_node);
 	if (!pdata) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		pr_err("client has to provide missing entry for successful registration\n");
 		return NULL;
 	}
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_of_adhoc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_of_rpmh.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_proxy_client.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_qnoc_adhoc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_rpm_smd.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_rpmh.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_rules.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_buspm_coresight_adhoc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: msm_minidump.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: msm_performance.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: msm_tz_smmu.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: peripheral-loader.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: peripheral-loader.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qbt_handler.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qcom-geni-se.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qcom_gsbi.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qcom_ipcc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qdsp6v2
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qdss_bridge.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qdss_bridge.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qmi_encdec.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qmi_interface.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qmi_rmnet.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qmi_rmnet_i.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qmp-debugfs-client.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qpnp-pbs.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qsee_ipc_irq.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qsee_ipc_irq_bridge.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qtee_shmbridge.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: ramdump.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: remoteqdss.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rmnet_ctl
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rmtfs_mem.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpm-smd-debug.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpm_master_stat.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpm_stats.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpmh-internal.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpmh-rsc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpmh.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpmh_master_stat.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpmh_master_stat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rq_stats.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: scm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: secure_buffer.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: service-locator-private.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: service-locator.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: service-notifier-private.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: service-notifier.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smcinvoke.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smcinvoke_object.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smd-rpm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smem.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smem_state.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smp2p.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smp2p_sleepstate.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smsm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: socinfo.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: spcom.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: spm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: spss_utils.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: subsys-pil-tz.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: subsystem_notif.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: subsystem_restart.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: sysmon-qmi.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: sysmon.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: system_pm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: trace-rpmh.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: trace_secure_buffer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: watchdog_v2.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: wcnss_ctrl.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: wda_qmi.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: wlan_firmware_service_v01.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: wlan_firmware_service_v01.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: renesas
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: rockchip
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: samsung
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: sunxi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: tegra
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: ti
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: ux500
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: versatile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: xilinx
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers/soc: zte
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: soundwire
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: spi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: spmi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: ssb
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: staging
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: target
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: tc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: tee
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: thermal
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: thunderbolt
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: tty
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: uio
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: usb
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: uwb
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: vfio
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: vhost
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: video
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: virt
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: virtio
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: visorbus
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: vlynq
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: vme
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: vservices
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: w1
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: watchdog
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: xen
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/drivers: zorro
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: firmware
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: fs
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: Kbuild
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: acpi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: asm-generic
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: clocksource
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: crypto
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: drm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: dt-bindings
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: keys
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: kvm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: 8250_pci.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: Kbuild.vservices
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: a.out.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: acct.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: acpi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: acpi_dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: acpi_iort.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: acpi_pmtmr.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: adb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: adc-tm-clients.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: adfs_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: aer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: agp_backend.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: agpgart.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ahci-remap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ahci_platform.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: aio.h
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux/akm09911.h msm-4.19/include/linux/akm09911.h
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux/akm09911.h	1970-01-01 00:00:00.000000000 +0000
+++ msm-4.19/include/linux/akm09911.h	2024-04-20 18:36:20.826499294 +0000
@@ -0,0 +1,171 @@
+/*
+ * Definitions for akm09911 compass chip.
+ */
+#ifndef AKM09911_H
+#define AKM09911_H
+
+#include <linux/ioctl.h>
+
+/* Device specific constant values */
+#define AK09911_REG_WIA1			0x00
+#define AK09911_REG_WIA2			0x01
+#define AK09911_REG_INFO1			0x02
+#define AK09911_REG_INFO2			0x03
+#define AK09911_REG_ST1				0x10
+#define AK09911_REG_HXL				0x11
+#define AK09911_REG_HXH				0x12
+#define AK09911_REG_HYL				0x13
+#define AK09911_REG_HYH				0x14
+#define AK09911_REG_HZL				0x15
+#define AK09911_REG_HZH				0x16
+#define AK09911_REG_TMPS			0x17
+#define AK09911_REG_ST2				0x18
+#define AK09911_REG_CNTL1			0x30
+#define AK09911_REG_CNTL2			0x31
+#define AK09911_REG_CNTL3			0x32
+
+#define AK09911_FUSE_ASAX			0x60
+#define AK09911_FUSE_ASAY			0x61
+#define AK09911_FUSE_ASAZ			0x62
+
+#define AK09911_MODE_SNG_MEASURE	0x01
+#define AK09911_MODE_SELF_TEST		0x10
+#define AK09911_MODE_FUSE_ACCESS	0x1F
+#define AK09911_MODE_POWERDOWN		0x00
+#define AK09911_MODE_CONTINUOUS_10HZ	0x02 /* 10Hz */
+#define AK09911_MODE_CONTINUOUS_20HZ	0x04 /* 20Hz */
+#define AK09911_MODE_CONTINUOUS_50HZ	0x06 /* 50Hz */
+#define AK09911_MODE_CONTINUOUS_100HZ	0x08 /* 100Hz */
+#define AK09911_RESET_DATA			0x01
+
+/* ACHEUL */
+
+#define AK09911_REGS_SIZE		13
+#define AK09911_WIA1_VALUE		0x48
+#define AK09911_WIA2_VALUE		0x05
+#define AK09916_WIA2_VALUE		0x09
+#define AK09919_WIA2_VALUE		0x0E
+
+/*** Limit of factory shipment test *******************************************/
+#define TLIMIT_TN_REVISION_09911				""
+#define TLIMIT_TN_RST_WIA1_09911				"RST_WIA1"
+#define TLIMIT_LO_RST_WIA1_09911				0x48
+#define TLIMIT_HI_RST_WIA1_09911				0x48
+#define TLIMIT_TN_RST_WIA2_09911				"RST_WIA2"
+#define TLIMIT_LO_RST_WIA2_09911				0x05
+#define TLIMIT_HI_RST_WIA2_09911				0x05
+
+#define TLIMIT_TN_ASAX_09911					"ASAX"
+#define TLIMIT_LO_ASAX_09911					1
+#define TLIMIT_HI_ASAX_09911					254
+#define TLIMIT_TN_ASAY_09911					"ASAY"
+#define TLIMIT_LO_ASAY_09911					1
+#define TLIMIT_HI_ASAY_09911					254
+#define TLIMIT_TN_ASAZ_09911					"ASAZ"
+#define TLIMIT_LO_ASAZ_09911					1
+#define TLIMIT_HI_ASAZ_09911					254
+
+#define TLIMIT_TN_SNG_ST1_09911				"SNG_ST1"
+#define TLIMIT_LO_SNG_ST1_09911				1
+#define TLIMIT_HI_SNG_ST1_09911				1
+
+#define TLIMIT_TN_SNG_HX_09911				"SNG_HX"
+#define TLIMIT_LO_SNG_HX_09911				-8189
+#define TLIMIT_HI_SNG_HX_09911				8189
+
+#define TLIMIT_TN_SNG_HY_09911				"SNG_HY"
+#define TLIMIT_LO_SNG_HY_09911				-8189
+#define TLIMIT_HI_SNG_HY_09911				8189
+
+#define TLIMIT_TN_SNG_HZ_09911				"SNG_HZ"
+#define TLIMIT_LO_SNG_HZ_09911				-8189
+#define TLIMIT_HI_SNG_HZ_09911				8189
+
+#define TLIMIT_TN_SNG_ST2_09911				"SNG_ST2"
+#define TLIMIT_LO_SNG_ST2_09911				0
+#define TLIMIT_HI_SNG_ST2_09911				0
+
+#define TLIMIT_TN_SLF_ST1_09911				"SLF_ST1"
+#define TLIMIT_LO_SLF_ST1_09911				1
+#define TLIMIT_HI_SLF_ST1_09911				1
+
+#define TLIMIT_TN_SLF_RVHX_09911				"SLF_REVSHX"
+#define TLIMIT_LO_SLF_RVHX_09911				-30
+#define TLIMIT_HI_SLF_RVHX_09911				30
+
+#define TLIMIT_TN_SLF_RVHY_09911				"SLF_REVSHY"
+#define TLIMIT_LO_SLF_RVHY_09911				-30
+#define TLIMIT_HI_SLF_RVHY_09911				30
+
+#define TLIMIT_TN_SLF_RVHZ_09911				"SLF_REVSHZ"
+#define TLIMIT_LO_SLF_RVHZ_09911				-400
+#define TLIMIT_HI_SLF_RVHZ_09911				-50
+
+#define TLIMIT_TN_SLF_ST2_09911				"SLF_ST2"
+#define TLIMIT_LO_SLF_ST2_09911				0
+#define TLIMIT_HI_SLF_ST2_09911				0
+
+/* To avoid device dependency, convert to general name */
+#define AKM_I2C_NAME			"akm09911"
+#define AKM_MISCDEV_NAME		"akm09911_dev"
+#define AKM_SYSCLS_NAME			"compass"
+#define AKM_SYSDEV_NAME			"akm09911"
+#define AKM_REG_MODE			AK09911_REG_CNTL2
+#define AKM_REG_RESET			AK09911_REG_CNTL3
+#define AKM_REG_STATUS			AK09911_REG_ST1
+#define AKM_MEASURE_TIME_US		10000
+#define AKM_DRDY_IS_HIGH(x)		((x) & 0x01)
+#define AKM_DOR_IS_HIGH(x)		((x) & 0x02)
+#define AKM_SENSOR_INFO_SIZE	2
+#define AKM_SENSOR_CONF_SIZE	3
+#define AKM_SENSOR_DATA_SIZE	9
+
+#define AKM_YPR_DATA_SIZE		16
+#define AKM_RWBUF_SIZE			16
+#define AKM_REGS_SIZE			AK09911_REGS_SIZE
+#define AKM_REGS_1ST_ADDR		AK09911_REG_WIA1
+#define AKM_FUSE_1ST_ADDR		AK09911_FUSE_ASAX
+
+#define AKM_MODE_SNG_MEASURE	AK09911_MODE_SNG_MEASURE
+#define AKM_MODE_SELF_TEST		AK09911_MODE_SELF_TEST
+#define AKM_MODE_FUSE_ACCESS	AK09911_MODE_FUSE_ACCESS
+#define AKM_MODE_POWERDOWN		AK09911_MODE_POWERDOWN
+#define AKM_MODE_CONTINUOUS_10HZ	AK09911_MODE_CONTINUOUS_10HZ
+#define AKM_MODE_CONTINUOUS_20HZ	AK09911_MODE_CONTINUOUS_20HZ
+#define AKM_MODE_CONTINUOUS_50HZ	AK09911_MODE_CONTINUOUS_50HZ
+#define AKM_MODE_CONTINUOUS_100HZ	AK09911_MODE_CONTINUOUS_100HZ
+#define AKM_RESET_DATA			AK09911_RESET_DATA
+
+#define ACC_DATA_FLAG		0
+#define MAG_DATA_FLAG		1
+#define FUSION_DATA_FLAG	2
+#define AKM_NUM_SENSORS		3
+
+#define ACC_DATA_READY		(1<<(ACC_DATA_FLAG))
+#define MAG_DATA_READY		(1<<(MAG_DATA_FLAG))
+#define FUSION_DATA_READY	(1<<(FUSION_DATA_FLAG))
+
+#define AKMIO				0xA1
+
+/* IOCTLs for AKM library */
+#define ECS_IOCTL_READ				_IOWR(AKMIO, 0x01, char)
+#define ECS_IOCTL_WRITE				_IOW(AKMIO, 0x02, char)
+#define ECS_IOCTL_RESET				_IO(AKMIO, 0x03)
+#define ECS_IOCTL_SET_MODE			_IOW(AKMIO, 0x10, char)
+#define ECS_IOCTL_SET_YPR			_IOW(AKMIO, 0x11, int[AKM_YPR_DATA_SIZE])
+#define ECS_IOCTL_GET_INFO			_IOR(AKMIO, 0x20, unsigned char[AKM_SENSOR_INFO_SIZE])
+#define ECS_IOCTL_GET_CONF			_IOR(AKMIO, 0x21, unsigned char[AKM_SENSOR_CONF_SIZE])
+#define ECS_IOCTL_GET_DATA			_IOR(AKMIO, 0x22, unsigned char[AKM_SENSOR_DATA_SIZE])
+#define ECS_IOCTL_GET_OPEN_STATUS	_IOR(AKMIO, 0x23, int)
+#define ECS_IOCTL_GET_CLOSE_STATUS	_IOR(AKMIO, 0x24, int)
+#define ECS_IOCTL_GET_DELAY			_IOR(AKMIO, 0x25, long long int)
+#define ECS_IOCTL_GET_LAYOUT		_IOR(AKMIO, 0x26, char)
+#define ECS_IOCTL_GET_ACCEL			_IOR(AKMIO, 0x30, short[3])
+
+struct akm09911_platform_data {
+	char layout;
+	int gpio_DRDY;
+	int gpio_RSTN;
+};
+
+#endif
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: alarmtimer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: altera_jtaguart.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: altera_uart.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: amba
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: amd-iommu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: amifd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: amifdreg.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: android_aid.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: anon_inodes.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: apm-emulation.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: apm_bios.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: apple-gmux.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: apple_bl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: arch_topology.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: arm-cci.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: arm-smccc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: arm_sdei.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ascii85.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: asn1.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: asn1_ber_bytecode.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: asn1_decoder.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: assoc_array.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: assoc_array_priv.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: async.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: async_tx.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ata.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ata_platform.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: atalk.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ath9k_platform.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: atm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: atm_suni.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: atm_tcp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: atmdev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: atmel-mci.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: atmel-ssc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: atmel_pdc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: atmel_tc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: atomic.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: attribute_container.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: audit.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: auto_dev-ioctl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: auto_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: auxvec.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: average.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: avf
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: b1pcmcia.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: backing-dev-defs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: backing-dev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: backlight.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: badblocks.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: balloon_compaction.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: batterydata-lib.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bcd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bch.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bcm47xx_nvram.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bcm47xx_sprom.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bcm47xx_wdt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bcm963xx_nvram.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bcm963xx_tag.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bcma
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: binfmts.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bit_spinlock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bitfield.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bitmap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bitops.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bitrev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bits.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: blk-cgroup.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: blk-mq-pci.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: blk-mq-rdma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: blk-mq-virtio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: blk-mq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: blk_types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: blkdev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: blkpg.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: blktrace_api.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: blockgroup_lock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bluetooth-power.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bma150.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bootmem.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bottom_half.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bpf-cgroup.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bpf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bpf_lirc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bpf_trace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bpf_types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bpf_verifier.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bpfilter.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: brcmphy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bsearch.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bsg-lib.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bsg.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: btf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: btree-128.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: btree-type.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: btree.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: btrfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: buffer_head.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bug.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: build-salt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: build_bug.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: bvec.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: byteorder
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: c2port.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cache.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cacheinfo.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: can
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: capability.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cb710.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cciss_ioctl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ccp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cdev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cdrom.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ceph
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cfag12864b.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cfi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cgroup-defs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cgroup.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cgroup_rdma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cgroup_subsys.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: circ_buf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cleancache.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: clk
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: clk-provider.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: clk.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: clkdev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: clock_cooling.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: clockchips.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: clocksource.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cm4000_cs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cmdline-parser.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cn_proc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cnt32_to_63.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: coda.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: coda_psdev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: compaction.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: compat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: compat_time.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: compiler-clang.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: compiler-gcc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: compiler-intel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: compiler.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: compiler_types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: completion.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: component.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: concap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: configfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: connector.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: console.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: console_struct.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: consolemap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: const.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: container.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: context_tracking.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: context_tracking_state.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cordic.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: coredump.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: coresight-cti.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: coresight-pmu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: coresight-stm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: coresight.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: count_zeros.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cper.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpu_cooling.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpu_pm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpu_rmap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpufeature.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpufreq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpufreq_times.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpuhotplug.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpuidle.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpumask.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cpuset.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crash_core.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crash_dump.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc-ccitt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc-itu-t.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc-t10dif.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc16.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc32.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc32c.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc32poly.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc4.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc64.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc7.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crc8.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cred.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crush
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: crypto.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cryptohash.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cs5535.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ctype.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cuda.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: cyclades.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: davinci_emac.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dax.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dca.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dcache.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dccp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dcookies.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: debug_locks.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: debugfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: debugobjects.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: decompress
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: delay.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: delayacct.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: delayed_call.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dell-led.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: devcoredump.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: devfreq-event.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: devfreq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: devfreq_cooling.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: device-mapper.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: device.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: device_cgroup.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: devpts_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: diagchar.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: digsig.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dirent.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dlm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dlm_plock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dm-bufio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dm-dirty-log.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dm-io.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dm-kcopyd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dm-region-hash.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dm9000.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-buf-ref.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-buf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-contiguous.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-debug.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-direct.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-direction.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-fence-array.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-fence.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-iommu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-mapping-fast.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-mapping.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-noncoherent.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma-removed.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dma_remapping.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dmaengine.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dmapool.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dmar.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dnotify.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dns_resolver.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dqblk_qtree.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dqblk_v1.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dqblk_v2.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: drbd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: drbd_genl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: drbd_genl_api.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: drbd_limits.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ds2782_battery.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dsa
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dtlk.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dw_apb_timer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dynamic_debug.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: dynamic_queue_limits.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: earlycpio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ecm_ipa.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ecryptfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: edac.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: edd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: edma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: eeprom_93cx6.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: eeprom_93xx46.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: efi-bgrt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: efi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: efs_vh.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: eisa.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: elevator.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: elf-fdpic.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: elf-randomize.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: elf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: elfcore-compat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: elfcore.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: elfnote.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: enclosure.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: energy_model.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: err.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: errno.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: error-injection.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: errqueue.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: errseq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: esoc_client.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: etherdevice.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ethtool.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: eventfd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: eventpoll.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: evm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: export.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: exportfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ext2_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: extable.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: extcon
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: extcon-provider.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: extcon.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: f2fs_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: f75375s.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: falloc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fanotify.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fastcvpd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fault-inject.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fbcon.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fcdevice.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fcntl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fddidevice.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fdtable.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fec.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: file.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: filter.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fips.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: firewire.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: firmware
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: firmware-map.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: firmware.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fixp-arith.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: flat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: flex_array.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: flex_proportions.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fmc-sdb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fmc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: font.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fpga
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: frame.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: freezer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: frontswap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fs_enet_pd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fs_pin.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fs_stack.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fs_struct.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fs_uart_pd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fscache-cache.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fscache.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fscrypt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fsi-sbefifo.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fsi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fsl
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fsl-diu-fb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fsl_devices.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fsl_hypervisor.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fsl_ifc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fsldma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fsnotify.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fsnotify_backend.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ftrace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ftrace_irq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: futex.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: fwnode.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: gameport.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: gcd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: genalloc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: genetlink.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: genhd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: genl_magic_func.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: genl_magic_struct.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: getcpu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: gfp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: glob.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: gnss.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: goldfish.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: gpio
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: gpio-pxa.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: gpio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: gpio_event.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: gpio_keys.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hardirq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hash.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hashtable.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hdcp_qseecom.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hdlc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hdlcdrv.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hdmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hid-debug.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hid-roccat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hid-sensor-hub.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hid-sensor-ids.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hid.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hiddev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hidraw.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: highmem.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: highuid.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hil.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hil_mlc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hippidevice.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hmm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: host1x.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hp_sdc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hpet.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hrtimer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hsi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: htcpld.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: huge_mm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hugetlb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hugetlb_cgroup.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hugetlb_inline.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hw_breakpoint.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hw_random.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hwmon-sysfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hwmon-vid.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hwmon.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hwspinlock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hyperv.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: hypervisor.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i2c-algo-bit.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i2c-algo-pca.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i2c-algo-pcf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i2c-dev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i2c-mux.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i2c-pxa.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i2c-smbus.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i2c.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i3c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i8042.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: i8253.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: icmp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: icmpv6.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ide.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: idle_inject.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: idr.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ieee80211.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ieee802154.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_arp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_bridge.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_eql.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_ether.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_fddi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_frad.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_link.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_ltalk.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_macvlan.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_phonet.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_pppol2tp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_pppox.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_tap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_team.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_tun.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_tunnel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: if_vlan.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: igmp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ihex.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: iio
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ima.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: imx-media.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: in.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: in6.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: inet.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: inet_diag.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: inetdevice.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: init.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: init_ohci1394_dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: init_task.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: initramfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: initrd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: inotify.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: input
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: input-polldev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: input.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: integrity.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: intel-iommu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: intel-pti.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: intel-svm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: interrupt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: interval_tree.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: interval_tree_generic.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: io-64-nonatomic-hi-lo.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: io-64-nonatomic-lo-hi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: io-mapping.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: io-pgtable-fast.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: io.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ioc3.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ioc4.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: iocontext.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: iomap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: iommu-helper.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: iommu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ion_kernel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: iopoll.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ioport.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ioprio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: iova.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ip.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipa.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipa_mhi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipa_odu_bridge.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipa_uc_offload.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipa_usb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipa_wdi3.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipa_wigig.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipack.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipc_logging.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipc_namespace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipmi-fru.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipmi_smi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipv6.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ipv6_route.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irq_cpustat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irq_poll.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irq_sim.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irq_work.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irqbypass.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irqchip
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irqchip.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irqdesc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irqdomain.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irqflags.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irqhandler.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irqnr.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: irqreturn.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: isa.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: isapnp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: iscsi_boot_sysfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: iscsi_ibft.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: isdn
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: isdn.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: isdn_divertif.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: isdn_ppp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: isdnif.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: isicom.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: iversion.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: jbd2.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: jhash.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: jiffies.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: journal-head.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: joystick.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: jump_label.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: jump_label_ratelimit.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: jz4740-adc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: jz4780-nemc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kallsyms.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kasan-checks.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kasan.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kbd_diacr.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kbd_kern.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kbuild.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kconfig.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kcore.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kcov.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kdb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kdebug.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kdev_t.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kern_levels.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kernel-page-flags.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kernel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kernel_stat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kernelcapi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kernfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kexec.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: key-type.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: key.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: keyboard.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: keycombo.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: keyreset.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kfifo.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kgdb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: khugepaged.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: klist.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kmemleak.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kmod.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kmsg_dump.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kobj_map.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kobject.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kobject_ns.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kprobes.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kref.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ks0108.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ks8842.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ks8851_mll.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ksm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kthread.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ktime.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kvm_host.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kvm_irqfd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kvm_para.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: kvm_types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: l2tp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lapb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: latencytop.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lcd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lcm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: led-class-flash.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: led-lm3530.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: leds-bd2802.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: leds-lp3944.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: leds-lp3952.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: leds-pca9532.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: leds-qpnp-flash-v2.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: leds-qpnp-flash.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: leds-regulator.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: leds-tca6507.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: leds.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: leds_pwm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: libata.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: libfdt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: libfdt_env.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: libgcc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: libnvdimm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: libps2.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: license.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lightnvm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: linkage.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: linux_logo.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lis3lv02d.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: list.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: list_bl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: list_lru.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: list_nulls.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: list_sort.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: livepatch.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: llc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: llist.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lockd
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lockdep.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lockref.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: log2.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: logic_pio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lru_cache.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lsm_audit.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lsm_hooks.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lz4.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: lzo.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mISDNdsp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mISDNhw.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mISDNif.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mailbox
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mailbox_client.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mailbox_controller.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: maple.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: marvell_phy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: math64.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: max17040_battery.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mbcache.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mbus.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mc146818rtc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mc6821.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mcb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mdev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mdio-bitbang.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mdio-gpio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mdio-mux.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mdio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mei_cl_bus.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mem_encrypt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: memblock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: memcontrol.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: memfd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: memory-state-time.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: memory.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: memory_hotplug.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mempolicy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mempool.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: memremap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: memstick.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mfd
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mhi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mic_bus.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: micrel_phy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: microchipphy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: migrate.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: migrate_mode.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mii.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: miscdevice.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mlx4
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mlx5
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mm-arch-hooks.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mm_inline.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mm_types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mm_types_task.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mman.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mmc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mmdebug.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mmiotrace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mmu_context.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mmu_notifier.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mmzone.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mnt_namespace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mod_devicetable.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: module.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: moduleloader.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: moduleparam.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mount.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mpage.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mpi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mpls.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mpls_iptunnel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mroute.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mroute6.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mroute_base.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msdos_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msg.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm-bus-board.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm-bus.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm-sps.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_adreno_devfreq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_bus_rules.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_dma_iommu_mapping.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_ext_display.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_gpi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_gsi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_hdcp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_hdmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_kgsl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_pcie.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: msm_rtb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mtd
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mutex.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mux
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mv643xx.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mv643xx_eth.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mv643xx_i2c.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mvebu-pmsu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: mxm-wmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: n_r3964.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: namei.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: net.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: net_dim.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netdev_features.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netdevice.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter_arp
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter_bridge
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter_bridge.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter_defs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter_ingress.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter_ipv4
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter_ipv4.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter_ipv6
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netfilter_ipv6.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netlink.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: netpoll.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfcinfo.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfs3.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfs4.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfs_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfs_fs_i.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfs_fs_sb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfs_iostat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfs_page.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfs_xdr.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nfsacl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nl802154.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nls.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: node.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nodemask.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nospec.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: notifier.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ns_common.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nsc_gpio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nsproxy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ntb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ntb_transport.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nubus.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: numa.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nvme-fc-driver.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nvme-fc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nvme-rdma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nvme.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nvmem-consumer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nvmem-provider.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: nvram.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_address.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_batterydata.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_clk.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_device.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_fdt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_gpio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_graph.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_iommu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_irq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_mdio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_net.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_pci.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_pdt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_platform.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_reserved_mem.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: of_slimbus.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: oid_registry.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: olpc-ec.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: omap-dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: omap-dmaengine.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: omap-gpmc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: omap-iommu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: omap-mailbox.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: omapfb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: once.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: oom.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: openvswitch.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: oprofile.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: osq_lock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: overflow.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: oxu210hp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: padata.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: page-flags-layout.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: page-flags.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: page-isolation.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: page_counter.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: page_ext.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: page_idle.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: page_owner.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: page_ref.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pageblock-flags.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pagemap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pagevec.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: parman.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: parport.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: parport_pc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: parser.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pata_arasan_cf_data.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: patchkey.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: path.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pch_dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci-acpi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci-aspm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci-ats.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci-dma-compat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci-dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci-ecam.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci-ep-cfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci-epc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci-epf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci_hotplug.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pci_ids.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pda_power.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pe.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: percpu-defs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: percpu-refcount.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: percpu-rwsem.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: percpu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: percpu_counter.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: perf
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: perf_event.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: perf_regs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: personality.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pfk.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pfn.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pfn_t.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: phonet.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: phy
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: phy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: phy_fixed.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: phy_led_triggers.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: phylink.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pid.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pid_namespace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pim.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pinctrl
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pipe_fs_i.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pkeys.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pktcdvd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pl320-ipc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: platform_data
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: platform_device.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: plist.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pm-trace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pm2301_charger.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pm_clock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pm_domain.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pm_opp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pm_qos.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pm_runtime.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pm_wakeirq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pm_wakeup.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pmbus.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pmic-voter.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pmu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pnfs_osd_xdr.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pnp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: poison.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: poll.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: posix-clock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: posix-timers.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: posix_acl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: posix_acl_xattr.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: power
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: power_supply.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: powercap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ppp-comp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ppp_channel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ppp_defs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pps-gpio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pps_kernel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pr.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: preempt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: prefetch.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: prime_numbers.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: printk.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: proc_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: proc_ns.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: processor.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: profile.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: projid.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: property.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: psci.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: psi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: psi_types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: psp-sev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pstore.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pstore_ram.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pti.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ptp_classify.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ptp_clock_kernel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ptr_ring.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ptrace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: purgatory.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pvclock_gtod.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pwm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pwm_backlight.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pxa168_eth.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: pxa2xx_ssp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: qcom-geni-se.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: qcom_scm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: qcom_tspp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: qcrypto.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: qed
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: qnx6_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: qpnp
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: quicklist.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: quota.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: quotaops.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: radix-tree.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: raid
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: raid_class.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ramfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: random.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: range.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ras.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ratelimit.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rational.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rbtree.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rbtree_augmented.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rbtree_latch.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rcu_node_tree.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rcu_segcblist.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rcu_sync.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rculist.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rculist_bl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rculist_nulls.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rcupdate.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rcupdate_wait.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rcutiny.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rcutree.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rcuwait.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: reboot-mode.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: reboot.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: reciprocal_div.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: refcount.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: regmap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: regset.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: regulator
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: relay.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: remoteproc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: remoteproc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: reservation.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: reset
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: reset-controller.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: reset.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: resource.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: resource_ext.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: restart_block.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rfkill.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rhashtable-types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rhashtable.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ring_buffer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rio_drv.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rio_ids.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rio_regs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rmap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rndis.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rndis_ipa.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rodata_test.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: root_dev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rpmsg
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rpmsg.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rq_stats.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rslib.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rtc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rtc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rtmutex.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rtnetlink.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rtsx_common.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rtsx_pci.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rtsx_usb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rwlock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rwlock_api_smp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rwlock_types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rwsem-spinlock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: rwsem.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: s3c_adc_battery.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sa11x0-dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sbitmap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: scatterlist.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: scc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sched
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sched.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sched_clock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: scif.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: scmi_protocol.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: scpi_protocol.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: screen_info.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sctp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: scx200.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: scx200_gpio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sdb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sde_io_util.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sde_rsc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sdla.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seccomp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: securebits.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: security.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sed-opal.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seg6.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seg6_genl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seg6_hmac.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seg6_iptunnel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seg6_local.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: selection.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: selinux.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sem.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: semaphore.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seq_buf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seq_file.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seq_file_net.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seqlock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: seqno-fence.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: serdev.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: serial.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: serial_8250.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: serial_bcm63xx.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: serial_core.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: serial_max3100.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: serial_pnx8xxx.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: serial_s3c.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: serial_sci.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: serio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: set_memory.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sfi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sfi_acpi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sfp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sh_clk.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sh_dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sh_eth.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sh_intc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sh_timer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sha256.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: shdma-base.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: shm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: shmem_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: show_mem_notifier.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: shrinker.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: signal.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: signal_types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: signalfd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: siox.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: siphash.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sirfsoc_dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sizes.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: skb_array.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: skbuff.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: slab.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: slab_def.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: slimbus
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: slub_def.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sm501-regs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sm501.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: smc911x.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: smc91x.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: smp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: smpboot.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: smsc911x.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: smscphy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: soc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sock_diag.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: socket.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sonet.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sony-laptop.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sonypi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sort.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sound.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: soundcard.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: soundwire
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: spi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: spinlock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: spinlock_api_smp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: spinlock_api_up.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: spinlock_types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: spinlock_types_up.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: spinlock_up.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: splice.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: spmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sram.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: srcu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: srcutiny.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: srcutree.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ssb
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ssbi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stackdepot.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stackprotector.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stacktrace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: start_kernel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: statfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: static_key.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stddef.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stmmac.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stmp3xxx_rtc_wdt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stmp_device.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stop_machine.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: string.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: string_helpers.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stringhash.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: stringify.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sudmac.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sungem_phy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sunrpc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sunserialcore.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sunxi-rsb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: superhyway.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: suspend.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: svga.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sw842.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: swab.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: swait.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: swap.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: swap_cgroup.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: swap_slots.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: swapfile.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: swapops.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: swiotlb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: switchtec.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sxgbe_platform.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sync_core.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sync_file.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: synclink.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sys.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sys_soc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: syscalls.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: syscore_ops.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sysctl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sysfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: syslog.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sysrq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: sysv_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: t10-pi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: task_io_accounting.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: task_io_accounting_ops.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: task_work.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: taskstats_kern.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tboot.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tca6416_keypad.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tcp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tee_drv.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: textsearch.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: textsearch_fsm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tfrc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: thermal.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: thinkpad_acpi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: thread_info.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: threads.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: thunderbolt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ti-emif-sram.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ti_wilink_st.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tick.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tifm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timb_dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timb_gpio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: time.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: time32.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: time64.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timecounter.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timekeeper_internal.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timekeeping.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timekeeping32.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timerfd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timeriomem-rng.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timerqueue.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: timex.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tnum.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: topology.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: torture.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: toshiba.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tpm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tpm_command.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tpm_eventlog.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: trace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: trace_clock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: trace_events.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: trace_seq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tracefs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tracehook.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tracepoint-defs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tracepoint.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: transport_class.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ts-nbus.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tsacct_kern.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tty.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tty_driver.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tty_flip.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: tty_ldisc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: typecheck.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: types.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: u64_stats_sync.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: uaccess.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ucb1400.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ucs2_string.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: udp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: uidgid.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: uio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: uio_driver.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ulpi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: umh.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: unaligned
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: uprobes.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: usb
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: usb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: usb_bam.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: usb_usual.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: usbdevice_fs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: user-return-notifier.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: user.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: user_namespace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: userfaultfd_k.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: util_macros.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: uts.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: utsname.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: uuid.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: uwb
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: uwb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vbox_utils.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: verification.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vermagic.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vexpress.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vfio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vfs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vga_switcheroo.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vgaarb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: via-core.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: via-gpio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: via.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: via_i2c.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: videodev2.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: virtio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: virtio_byteorder.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: virtio_caif.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: virtio_config.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: virtio_console.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: virtio_net.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: virtio_ring.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: virtio_vsock.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: visorbus.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vlynq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vm_event_item.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vm_sockets.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vmacache.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vmalloc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vme.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vmpressure.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vmstat.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vmw_vmci_api.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vmw_vmci_defs.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vringh.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vt.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vt_buffer.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vt_kern.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: vtime.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: w1-gpio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: w1.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: wait.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: wait_bit.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: wakeup_reason.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: wanrouter.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: watchdog.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: wimax
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: win_minmax.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: wireless.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: wkup_m3_ipc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: wl12xx.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: wm97xx.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: wmi.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: workqueue.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: writeback.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: ww_mutex.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: xarray.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: xattr.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: xxhash.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: xz.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: yam.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: z2_battery.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: zbud.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: zconf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: zlib.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: zorro.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: zpool.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: zsmalloc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: zstd.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include/linux: zutil.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: math-emu
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: media
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: memory
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: microvisor
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: misc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: net
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: pcmcia
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: ras
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: rdma
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: scsi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: soc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: sound
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: target
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: trace
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: uapi
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: video
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: vservices
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/include: xen
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: init
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: ipc
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: kernel
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: lib
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: mm
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: net
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: samples
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: scripts
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: security
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: sound
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack: .gitignore
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack: Kbuild
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack: camera
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display: .git
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display: NOTICE
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display: config
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: Makefile
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: dp
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_catalog.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_catalog.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_clk.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_clk_manager.c
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_ctrl.c msm-4.19/techpack/display/msm/dsi/dsi_ctrl.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_ctrl.c	2024-04-16 19:15:06.808039510 +0000
+++ msm-4.19/techpack/display/msm/dsi/dsi_ctrl.c	2024-04-20 18:36:20.830499291 +0000
@@ -807,9 +807,12 @@
 	int rc = 0;
 	struct dsi_ctrl_bus_scale_info *bus = &ctrl->axi_bus_info;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	bus->bus_scale_table = msm_bus_cl_get_pdata(pdev);
 	if (IS_ERR_OR_NULL(bus->bus_scale_table)) {
 		rc = PTR_ERR(bus->bus_scale_table);
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		DSI_CTRL_DEBUG(ctrl, "msm_bus_cl_get_pdata() failed, rc = %d\n",
 				rc);
 		bus->bus_scale_table = NULL;
@@ -819,9 +822,11 @@
 	bus->bus_handle = msm_bus_scale_register_client(bus->bus_scale_table);
 	if (!bus->bus_handle) {
 		rc = -EINVAL;
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		DSI_CTRL_ERR(ctrl, "failed to register axi bus client\n");
 	}
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -1915,6 +1920,9 @@
 	const struct of_device_id *id;
 	enum dsi_ctrl_version version;
 	int rc = 0;
+    const char *compatible = NULL;
+
+    printk("%s:%d, ACHEUL, in", __FUNCTION__, __LINE__);
 
 	id = of_match_node(msm_dsi_of_match, pdev->dev.of_node);
 	if (!id)
@@ -1934,6 +1942,9 @@
 	dsi_ctrl->irq_info.irq_num = -1;
 	dsi_ctrl->irq_info.irq_stat_mask = 0x0;
 
+    of_property_read_string(pdev->dev.of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
 	INIT_WORK(&dsi_ctrl->dma_cmd_wait, dsi_ctrl_dma_cmd_wait_for_done);
 	atomic_set(&dsi_ctrl->dma_irq_trig, 0);
 
@@ -1976,9 +1987,12 @@
 	}
 
 	rc = dsi_ctrl_axi_bus_client_init(pdev, dsi_ctrl);
-	if (rc)
+	if (rc){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, rc);
 		DSI_CTRL_DEBUG(dsi_ctrl, "failed to init axi bus client, rc = %d\n",
 				rc);
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+    }
 
 	if (dsi_ctrl->hw.ops.map_mdp_regs)
 		dsi_ctrl->hw.ops.map_mdp_regs(pdev, &dsi_ctrl->hw);
@@ -1996,6 +2010,7 @@
 	platform_set_drvdata(pdev, dsi_ctrl);
 	DSI_CTRL_INFO(dsi_ctrl, "Probe successful\n");
 
+    printk("%s:%d, ACHEUL, out, OK", __FUNCTION__, __LINE__);
 	return 0;
 
 fail_supplies:
@@ -2003,6 +2018,7 @@
 fail_clks:
 	(void)dsi_ctrl_clocks_deinit(dsi_ctrl);
 fail:
+    printk("%s:%d, ACHEUL, out, error: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_hw.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_hw_1_4.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_hw_2_0.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_hw_2_2.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_hw_cmn.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_reg.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_defs.h
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_display.c msm-4.19/techpack/display/msm/dsi/dsi_display.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_display.c	2024-04-16 19:15:06.812039508 +0000
+++ msm-4.19/techpack/display/msm/dsi/dsi_display.c	2024-04-20 18:36:20.830499291 +0000
@@ -34,6 +34,7 @@
 
 #define DSI_CLOCK_BITRATE_RADIX 10
 #define MAX_TE_SOURCE_ID  2
+#define CONFIG_DEBUG_FS 1
 
 static char dsi_display_primary[MAX_CMDLINE_PARAM_LEN];
 static char dsi_display_secondary[MAX_CMDLINE_PARAM_LEN];
@@ -53,6 +54,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return;
 
@@ -72,19 +74,20 @@
 	enum dsi_clk_gate_type clk_selection;
 	enum dsi_clk_gate_type const default_clk_select = PIXEL_CLK | DSI_PHY;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (display->panel->host_config.force_hs_clk_lane) {
-		DSI_DEBUG("no dsi clock gating for continuous clock mode\n");
+		printk("no dsi clock gating for continuous clock mode\n");
 		return 0;
 	}
 
 	mctrl = &display->ctrl[display->clk_master_idx];
 	if (!mctrl) {
-		DSI_ERR("Invalid controller\n");
+		printk("Invalid controller\n");
 		return -EINVAL;
 	}
 
@@ -100,14 +103,14 @@
 		clk_selection = 0;
 	}
 
-	DSI_DEBUG("%s clock gating Byte:%s Pixel:%s PHY:%s\n",
+	printk("%s clock gating Byte:%s Pixel:%s PHY:%s\n",
 		enable ? "Enabling" : "Disabling",
 		clk_selection & BYTE_CLK ? "yes" : "no",
 		clk_selection & PIXEL_CLK ? "yes" : "no",
 		clk_selection & DSI_PHY ? "yes" : "no");
 	rc = dsi_ctrl_config_clk_gating(mctrl->ctrl, enable, clk_selection);
 	if (rc) {
-		DSI_ERR("[%s] failed to %s clk gating for clocks %d, rc=%d\n",
+		printk("[%s] failed to %s clk gating for clocks %d, rc=%d\n",
 				display->name, enable ? "enable" : "disable",
 				clk_selection, rc);
 		return rc;
@@ -125,7 +128,7 @@
 		rc = dsi_ctrl_config_clk_gating(ctrl->ctrl, enable,
 				clk_selection);
 		if (rc) {
-			DSI_ERR("[%s] failed to %s clk gating for clocks %d, rc=%d\n",
+			printk("[%s] failed to %s clk gating for clocks %d, rc=%d\n",
 				display->name, enable ? "enable" : "disable",
 				clk_selection, rc);
 			return rc;
@@ -141,6 +144,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return;
 
@@ -157,6 +161,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return;
 
@@ -174,6 +179,7 @@
 {
 	int l, t, r, b;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!r1 || !r2 || !result)
 		return;
 
@@ -201,6 +207,7 @@
 	u64 bl_temp;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (dsi_display == NULL || dsi_display->panel == NULL)
 		return -EINVAL;
 
@@ -221,24 +228,24 @@
 	bl_scale_sv = panel->bl_config.bl_scale_sv;
 	bl_temp = (u32)bl_temp * bl_scale_sv / MAX_SV_BL_SCALE_LEVEL;
 
-	DSI_DEBUG("bl_scale = %u, bl_scale_sv = %u, bl_lvl = %u\n",
+	printk("bl_scale = %u, bl_scale_sv = %u, bl_lvl = %u\n",
 		bl_scale, bl_scale_sv, (u32)bl_temp);
 	rc = dsi_display_clk_ctrl(dsi_display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI core clocks, rc=%d\n",
 		       dsi_display->name, rc);
 		goto error;
 	}
 
 	rc = dsi_panel_set_backlight(panel, (u32)bl_temp);
 	if (rc)
-		DSI_ERR("unable to set backlight\n");
+		printk("unable to set backlight\n");
 
 	rc = dsi_display_clk_ctrl(dsi_display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_OFF);
 	if (rc) {
-		DSI_ERR("[%s] failed to disable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to disable DSI core clocks, rc=%d\n",
 		       dsi_display->name, rc);
 		goto error;
 	}
@@ -254,6 +261,7 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 	mutex_lock(&m_ctrl->ctrl->ctrl_lock);
 
@@ -264,7 +272,7 @@
 
 	rc = dsi_ctrl_set_cmd_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+		printk("[%s] failed to enable cmd engine, rc=%d\n",
 		       display->name, rc);
 		goto done;
 	}
@@ -277,7 +285,7 @@
 		rc = dsi_ctrl_set_cmd_engine_state(ctrl->ctrl,
 						   DSI_CTRL_ENGINE_ON);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+			printk("[%s] failed to enable cmd engine, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_master;
 		}
@@ -298,11 +306,12 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 	mutex_lock(&m_ctrl->ctrl->ctrl_lock);
 
 	if (display->cmd_engine_refcount == 0) {
-		DSI_ERR("[%s] Invalid refcount\n", display->name);
+		printk("[%s] Invalid refcount\n", display->name);
 		goto done;
 	} else if (display->cmd_engine_refcount > 1) {
 		display->cmd_engine_refcount--;
@@ -317,13 +326,13 @@
 		rc = dsi_ctrl_set_cmd_engine_state(ctrl->ctrl,
 						   DSI_CTRL_ENGINE_OFF);
 		if (rc)
-			DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+			printk("[%s] failed to enable cmd engine, rc=%d\n",
 			       display->name, rc);
 	}
 
 	rc = dsi_ctrl_set_cmd_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_OFF);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+		printk("[%s] failed to enable cmd engine, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -341,8 +350,9 @@
 	struct dsi_display_ctrl *display_ctrl;
 	int rc, cnt;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!cb_data) {
-		DSI_ERR("aspace cb called with invalid cb_data\n");
+		printk("aspace cb called with invalid cb_data\n");
 		return;
 	}
 	display = (struct dsi_display *)cb_data;
@@ -365,7 +375,7 @@
 		rc = msm_gem_get_iova(display->tx_cmd_buf,
 				display->aspace, &(display->cmd_buffer_iova));
 		if (rc) {
-			DSI_ERR("failed to get the iova rc %d\n", rc);
+			printk("failed to get the iova rc %d\n", rc);
 			goto end;
 		}
 
@@ -373,7 +383,7 @@
 			(void *) msm_gem_get_vaddr(display->tx_cmd_buf);
 
 		if (IS_ERR_OR_NULL(display->vaddr)) {
-			DSI_ERR("failed to get va rc %d\n", rc);
+			printk("failed to get va rc %d\n", rc);
 			goto end;
 		}
 	}
@@ -412,7 +422,7 @@
 					bool enable)
 {
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return;
 	}
 
@@ -435,13 +445,13 @@
 
 	pdev = display->pdev;
 	if (!pdev) {
-		DSI_ERR("invalid platform device\n");
+		printk("invalid platform device\n");
 		return;
 	}
 
 	dev = &pdev->dev;
 	if (!dev) {
-		DSI_ERR("invalid device\n");
+		printk("invalid device\n");
 		return;
 	}
 
@@ -460,7 +470,7 @@
 			      IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 			      "TE_GPIO", display);
 	if (rc) {
-		DSI_ERR("TE request_irq failed for ESD rc:%d\n", rc);
+		printk("TE request_irq failed for ESD rc:%d\n", rc);
 		irq_clear_status_flags(te_irq, IRQ_DISABLE_UNLAZY);
 		goto error;
 	}
@@ -483,12 +493,13 @@
 	int rc = 0, cnt = 0;
 	struct dsi_display_ctrl *display_ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display->tx_cmd_buf = msm_gem_new(display->drm_dev,
 			SZ_4K,
 			MSM_BO_UNCACHED);
 
 	if ((display->tx_cmd_buf) == NULL) {
-		DSI_ERR("Failed to allocate cmd tx buf memory\n");
+		printk("Failed to allocate cmd tx buf memory\n");
 		rc = -ENOMEM;
 		goto error;
 	}
@@ -498,7 +509,7 @@
 	display->aspace = msm_gem_smmu_address_space_get(
 			display->drm_dev, MSM_SMMU_DOMAIN_UNSECURE);
 	if (!display->aspace) {
-		DSI_ERR("failed to get aspace\n");
+		printk("failed to get aspace\n");
 		rc = -EINVAL;
 		goto free_gem;
 	}
@@ -506,21 +517,21 @@
 	rc = msm_gem_address_space_register_cb(display->aspace,
 			dsi_display_aspace_cb_locked, (void *)display);
 	if (rc) {
-		DSI_ERR("failed to register callback %d\n", rc);
+		printk("failed to register callback %d\n", rc);
 		goto free_gem;
 	}
 
 	rc = msm_gem_get_iova(display->tx_cmd_buf, display->aspace,
 				&(display->cmd_buffer_iova));
 	if (rc) {
-		DSI_ERR("failed to get the iova rc %d\n", rc);
+		printk("failed to get the iova rc %d\n", rc);
 		goto free_aspace_cb;
 	}
 
 	display->vaddr =
 		(void *) msm_gem_get_vaddr(display->tx_cmd_buf);
 	if (IS_ERR_OR_NULL(display->vaddr)) {
-		DSI_ERR("failed to get va rc %d\n", rc);
+		printk("failed to get va rc %d\n", rc);
 		rc = -EINVAL;
 		goto put_iova;
 	}
@@ -556,6 +567,7 @@
 	int group = 0, count = 0;
 	struct drm_panel_esd_config *config;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!panel)
 		return false;
 
@@ -595,15 +607,16 @@
 	int rc = 0;
 	u32 val = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	pdev = display->pdev;
 	if (!pdev) {
-		DSI_ERR("Invalid platform device\n");
+		printk("Invalid platform device\n");
 		return;
 	}
 
 	dev = &pdev->dev;
 	if (!dev) {
-		DSI_ERR("Invalid platform device\n");
+		printk("Invalid platform device\n");
 		return;
 	}
 
@@ -618,7 +631,7 @@
 			"qcom,panel-te-source", &val);
 
 	if (rc || (val  > MAX_TE_SOURCE_ID)) {
-		DSI_ERR("invalid vsync source selection\n");
+		printk("invalid vsync source selection\n");
 		val = 0;
 	}
 
@@ -633,6 +646,7 @@
 	struct dsi_cmd_desc *cmds;
 	u32 flags = 0;
 
+    printk("%s:%d, ACHEUL, panel name: %s", __FUNCTION__, __LINE__, panel->name);
 	if (!panel || !ctrl || !ctrl->ctrl)
 		return -EINVAL;
 
@@ -663,7 +677,7 @@
 		cmds[i].msg.rx_len = config->status_cmds_rlen[i];
 		rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &cmds[i].msg, &flags);
 		if (rc <= 0) {
-			DSI_ERR("rx cmd transfer failed rc=%d\n", rc);
+			printk("rx cmd transfer failed rc=%d\n", rc);
 			return rc;
 		}
 
@@ -680,6 +694,7 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL, panel name: %s", __FUNCTION__, __LINE__, panel->name);
 	rc = dsi_display_read_status(ctrl, panel);
 	if (rc <= 0) {
 		goto exit;
@@ -704,27 +719,28 @@
 	int rc = 0, i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
-	DSI_DEBUG(" ++\n");
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	printk(" ++\n");
 
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 
 	if (display->tx_cmd_buf == NULL) {
 		rc = dsi_host_alloc_cmd_tx_buffer(display);
 		if (rc) {
-			DSI_ERR("failed to allocate cmd tx buffer memory\n");
+			printk("failed to allocate cmd tx buffer memory\n");
 			goto done;
 		}
 	}
 
 	rc = dsi_display_cmd_engine_enable(display);
 	if (rc) {
-		DSI_ERR("cmd engine enable failed\n");
+		printk("cmd engine enable failed\n");
 		return -EPERM;
 	}
 
 	rc = dsi_display_validate_status(m_ctrl, display->panel);
 	if (rc <= 0) {
-		DSI_ERR("[%s] read status failed on master,rc=%d\n",
+		printk("[%s] read status failed on master,rc=%d\n",
 		       display->name, rc);
 		goto exit;
 	}
@@ -739,7 +755,7 @@
 
 		rc = dsi_display_validate_status(ctrl, display->panel);
 		if (rc <= 0) {
-			DSI_ERR("[%s] read status failed on slave,rc=%d\n",
+			printk("[%s] read status failed on slave,rc=%d\n",
 			       display->name, rc);
 			goto exit;
 		}
@@ -754,7 +770,8 @@
 {
 	int rc = 0;
 
-	DSI_DEBUG(" ++\n");
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	printk(" ++\n");
 	/* TODO: trigger SW BTA and wait for acknowledgment */
 
 	return rc;
@@ -765,12 +782,13 @@
 	int rc = 1;
 	int const esd_te_timeout = msecs_to_jiffies(3*20);
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	dsi_display_change_te_irq_status(display, true);
 
 	reinit_completion(&display->esd_te_gate);
 	if (!wait_for_completion_timeout(&display->esd_te_gate,
 				esd_te_timeout)) {
-		DSI_ERR("TE check failed\n");
+		printk("TE check failed\n");
 		rc = -EINVAL;
 	}
 
@@ -788,6 +806,7 @@
 	int rc = 0x1, ret;
 	u32 mask;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!dsi_display || !dsi_display->panel)
 		return -EINVAL;
 
@@ -796,7 +815,7 @@
 	dsi_panel_acquire_panel_lock(panel);
 
 	if (!panel->panel_initialized) {
-		DSI_DEBUG("Panel not initialized\n");
+		printk("Panel not initialized\n");
 		goto release_panel_lock;
 	}
 
@@ -871,6 +890,7 @@
 {
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	memset(cmd, 0x00, sizeof(*cmd));
 	cmd->msg.type = cmd_buf[0];
 	cmd->last_command = (cmd_buf[1] == 1);
@@ -881,7 +901,7 @@
 	cmd->msg.tx_len = ((cmd_buf[5] << 8) | (cmd_buf[6]));
 
 	if (cmd->msg.tx_len > payload_len) {
-		DSI_ERR("Incorrect payload length tx_len %zu, payload_len %d\n",
+		printk("Incorrect payload length tx_len %zu, payload_len %d\n",
 		       cmd->msg.tx_len, payload_len);
 		return -EINVAL;
 	}
@@ -902,6 +922,7 @@
 	struct dsi_display_ctrl *ctrl;
 	int i, rc = -EINVAL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, dsi_display) {
 		ctrl = &dsi_display->ctrl[i];
 		rc = dsi_ctrl_get_host_engine_init_state(ctrl->ctrl, state);
@@ -921,17 +942,18 @@
 	int rc = 0;
 	bool state = false;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!dsi_display || !cmd_buf) {
-		DSI_ERR("[DSI] invalid params\n");
+		printk("[DSI] invalid params\n");
 		return -EINVAL;
 	}
 
-	DSI_DEBUG("[DSI] Display command transfer\n");
+	printk("[DSI] Display command transfer\n");
 
 	rc = dsi_display_cmd_prepare(cmd_buf, cmd_buf_len,
 			&cmd, cmd_payload, MAX_CMD_PAYLOAD_SIZE);
 	if (rc) {
-		DSI_ERR("[DSI] command prepare failed. rc %d\n", rc);
+		printk("[DSI] command prepare failed. rc %d\n", rc);
 		return rc;
 	}
 
@@ -949,7 +971,7 @@
 		goto end;
 	}
 	if (rc || !state) {
-		DSI_ERR("[DSI] Invalid host state %d rc %d\n",
+		printk("[DSI] Invalid host state %d rc %d\n",
 				state, rc);
 		rc = -EPERM;
 		goto end;
@@ -968,6 +990,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->panel->host_config.force_hs_clk_lane)
 		return;
 
@@ -996,6 +1019,7 @@
 	int rc = 0;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -EINVAL;
 
@@ -1005,7 +1029,7 @@
 		ctrl = &dsi_display->ctrl[i];
 		rc = dsi_ctrl_soft_reset(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("[%s] failed to soft reset host_%d, rc=%d\n",
+			printk("[%s] failed to soft reset host_%d, rc=%d\n",
 					dsi_display->name, i, rc);
 			break;
 		}
@@ -1021,8 +1045,9 @@
 	enum dsi_pixel_format format = DSI_PIXEL_FORMAT_MAX;
 	struct dsi_display *dsi_display = (struct dsi_display *)display;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!dsi_display || !dsi_display->panel) {
-		DSI_ERR("Invalid params(s) dsi_display %pK, panel %pK\n",
+		printk("Invalid params(s) dsi_display %pK, panel %pK\n",
 			dsi_display,
 			((dsi_display) ? dsi_display->panel : NULL));
 		return format;
@@ -1036,6 +1061,7 @@
 {
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		dsi_ctrl_setup_misr(display->ctrl[i].ctrl,
 				display->misr_enable,
@@ -1049,8 +1075,9 @@
 	struct dsi_display *display = disp;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->panel) {
-		DSI_ERR("invalid display/panel\n");
+		printk("invalid display/panel\n");
 		return -EINVAL;
 	}
 
@@ -1072,7 +1099,7 @@
 	}
 
 	SDE_EVT32(display->panel->power_mode, power_mode, rc);
-	DSI_DEBUG("Power mode transition from %d to %d %s",
+	printk("Power mode transition from %d to %d %s",
 			display->panel->power_mode, power_mode,
 			rc ? "failed" : "successful");
 	if (!rc)
@@ -1086,8 +1113,9 @@
 {
 	u32 status_mode = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display->panel) {
-		DSI_ERR("Invalid panel data\n");
+		printk("Invalid panel data\n");
 		return false;
 	}
 
@@ -1109,6 +1137,7 @@
 	u32 len = 0;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1164,6 +1193,7 @@
 	size_t len;
 	u32 enable, frame_count;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1195,7 +1225,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto unlock;
 	}
@@ -1205,7 +1235,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_OFF);
 	if (rc) {
-		DSI_ERR("[%s] failed to disable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to disable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto unlock;
 	}
@@ -1232,6 +1262,7 @@
 	u32 misr;
 	size_t max_len = min_t(size_t, user_len, MISR_BUFF_SIZE);
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1246,7 +1277,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -1265,7 +1296,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_OFF);
 	if (rc) {
-		DSI_ERR("[%s] failed to disable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to disable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -1295,6 +1326,7 @@
 	u32 esd_trigger;
 	size_t len;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1312,7 +1344,7 @@
 		return user_len;
 
 	if (!esd_config->esd_enabled) {
-		DSI_ERR("ESD feature is not enabled\n");
+		printk("ESD feature is not enabled\n");
 		return -EINVAL;
 	}
 
@@ -1344,7 +1376,7 @@
 		DSI_INFO("ESD attack triggered by user\n");
 		rc = dsi_panel_trigger_esd_attack(display->panel);
 		if (rc) {
-			DSI_ERR("Failed to trigger ESD attack\n");
+			printk("Failed to trigger ESD attack\n");
 			goto error;
 		}
 	}
@@ -1366,6 +1398,7 @@
 	int rc = 0;
 	size_t len;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1390,7 +1423,7 @@
 
 	esd_config = &display->panel->esd_config;
 	if (!esd_config) {
-		DSI_ERR("Invalid panel esd config\n");
+		printk("Invalid panel esd config\n");
 		rc = -EINVAL;
 		goto error;
 	}
@@ -1412,7 +1445,7 @@
 		DSI_INFO("ESD check is switched to reg read by user\n");
 		rc = dsi_panel_parse_esd_reg_read_configs(display->panel);
 		if (rc) {
-			DSI_ERR("failed to alter esd check mode,rc=%d\n",
+			printk("failed to alter esd check mode,rc=%d\n",
 						rc);
 			rc = user_len;
 			goto error;
@@ -1445,6 +1478,7 @@
 	int rc = 0;
 	size_t len;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1452,7 +1486,7 @@
 		return 0;
 
 	if (!display->panel) {
-		DSI_ERR("invalid panel data\n");
+		printk("invalid panel data\n");
 		return -EINVAL;
 	}
 
@@ -1462,7 +1496,7 @@
 
 	esd_config = &display->panel->esd_config;
 	if (!esd_config) {
-		DSI_ERR("Invalid panel esd config\n");
+		printk("Invalid panel esd config\n");
 		rc = -EINVAL;
 		goto error;
 	}
@@ -1538,10 +1572,11 @@
 	char name[MAX_NAME_SIZE];
 	int i;
 
+    printk("%s:%d, ACHEUL, display name: %s", __FUNCTION__, __LINE__);
 	dir = debugfs_create_dir(display->name, NULL);
 	if (IS_ERR_OR_NULL(dir)) {
 		rc = PTR_ERR(dir);
-		DSI_ERR("[%s] debugfs create dir failed, rc = %d\n",
+		printk("[%s] debugfs create dir failed, rc = %d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -1553,7 +1588,7 @@
 					&dump_info_fops);
 	if (IS_ERR_OR_NULL(dump_file)) {
 		rc = PTR_ERR(dump_file);
-		DSI_ERR("[%s] debugfs create dump info file failed, rc=%d\n",
+		printk("[%s] debugfs create dump info file failed, rc=%d\n",
 		       display->name, rc);
 		goto error_remove_dir;
 	}
@@ -1565,7 +1600,7 @@
 					&esd_trigger_fops);
 	if (IS_ERR_OR_NULL(dump_file)) {
 		rc = PTR_ERR(dump_file);
-		DSI_ERR("[%s] debugfs for esd trigger file failed, rc=%d\n",
+		printk("[%s] debugfs for esd trigger file failed, rc=%d\n",
 		       display->name, rc);
 		goto error_remove_dir;
 	}
@@ -1577,7 +1612,7 @@
 					&esd_check_mode_fops);
 	if (IS_ERR_OR_NULL(dump_file)) {
 		rc = PTR_ERR(dump_file);
-		DSI_ERR("[%s] debugfs for esd check mode failed, rc=%d\n",
+		printk("[%s] debugfs for esd check mode failed, rc=%d\n",
 		       display->name, rc);
 		goto error_remove_dir;
 	}
@@ -1589,7 +1624,7 @@
 					&misr_data_fops);
 	if (IS_ERR_OR_NULL(misr_data)) {
 		rc = PTR_ERR(misr_data);
-		DSI_ERR("[%s] debugfs create misr datafile failed, rc=%d\n",
+		printk("[%s] debugfs create misr datafile failed, rc=%d\n",
 		       display->name, rc);
 		goto error_remove_dir;
 	}
@@ -1606,7 +1641,7 @@
 				&phy->allow_phy_power_off);
 		if (IS_ERR_OR_NULL(dump_file)) {
 			rc = PTR_ERR(dump_file);
-			DSI_ERR("[%s] debugfs create %s failed, rc=%d\n",
+			printk("[%s] debugfs create %s failed, rc=%d\n",
 			       display->name, name, rc);
 			goto error_remove_dir;
 		}
@@ -1617,7 +1652,7 @@
 				&phy->regulator_min_datarate_bps);
 		if (IS_ERR_OR_NULL(dump_file)) {
 			rc = PTR_ERR(dump_file);
-			DSI_ERR("[%s] debugfs create %s failed, rc=%d\n",
+			printk("[%s] debugfs create %s failed, rc=%d\n",
 			       display->name, name, rc);
 			goto error_remove_dir;
 		}
@@ -1625,28 +1660,28 @@
 
 	if (!debugfs_create_bool("ulps_feature_enable", 0600, dir,
 			&display->panel->ulps_feature_enabled)) {
-		DSI_ERR("[%s] debugfs create ulps feature enable file failed\n",
+		printk("[%s] debugfs create ulps feature enable file failed\n",
 		       display->name);
 		goto error_remove_dir;
 	}
 
 	if (!debugfs_create_bool("ulps_suspend_feature_enable", 0600, dir,
 			&display->panel->ulps_suspend_enabled)) {
-		DSI_ERR("[%s] debugfs create ulps-suspend feature enable file failed\n",
+		printk("[%s] debugfs create ulps-suspend feature enable file failed\n",
 		       display->name);
 		goto error_remove_dir;
 	}
 
 	if (!debugfs_create_bool("ulps_status", 0400, dir,
 			&display->ulps_enabled)) {
-		DSI_ERR("[%s] debugfs create ulps status file failed\n",
+		printk("[%s] debugfs create ulps status file failed\n",
 		       display->name);
 		goto error_remove_dir;
 	}
 
 	if (!debugfs_create_u32("clk_gating_config", 0600, dir,
 			&display->clk_gating_config)) {
-		DSI_ERR("[%s] debugfs create clk gating config failed\n",
+		printk("[%s] debugfs create clk gating config failed\n",
 		       display->name);
 		goto error_remove_dir;
 	}
@@ -1707,30 +1742,30 @@
 {
 	/* TODO: make checks based on cont. splash */
 
-	DSI_DEBUG("checking ulps req validity\n");
+	printk("checking ulps req validity\n");
 
 	if (atomic_read(&display->panel->esd_recovery_pending)) {
-		DSI_DEBUG("%s: ESD recovery sequence underway\n", __func__);
+		printk("%s: ESD recovery sequence underway\n", __func__);
 		return false;
 	}
 
 	if (!dsi_panel_ulps_feature_enabled(display->panel) &&
 			!display->panel->ulps_suspend_enabled) {
-		DSI_DEBUG("%s: ULPS feature is not enabled\n", __func__);
+		printk("%s: ULPS feature is not enabled\n", __func__);
 		return false;
 	}
 
 	if (!dsi_panel_initialized(display->panel) &&
 			!display->panel->ulps_suspend_enabled) {
-		DSI_DEBUG("%s: panel not yet initialized\n", __func__);
+		printk("%s: panel not yet initialized\n", __func__);
 		return false;
 	}
 
 	if (enable && display->ulps_enabled) {
-		DSI_DEBUG("ULPS already enabled\n");
+		printk("ULPS already enabled\n");
 		return false;
 	} else if (!enable && !display->ulps_enabled) {
-		DSI_DEBUG("ULPS already disabled\n");
+		printk("ULPS already disabled\n");
 		return false;
 	}
 
@@ -1762,13 +1797,14 @@
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!dsi_display_is_ulps_req_valid(display, enable)) {
-		DSI_DEBUG("%s: skipping ULPS config, enable=%d\n",
+		printk("%s: skipping ULPS config, enable=%d\n",
 			__func__, enable);
 		return 0;
 	}
@@ -1787,7 +1823,7 @@
 			display->clamp_enabled);
 
 	if (rc == DSI_PHY_ULPS_ERROR) {
-		DSI_ERR("Ulps PHY state change(%d) failed\n", enable);
+		printk("Ulps PHY state change(%d) failed\n", enable);
 		return -EINVAL;
 	}
 
@@ -1800,7 +1836,7 @@
 			rc = dsi_phy_set_ulps(ctrl->phy, &display->config,
 					enable, display->clamp_enabled);
 			if (rc == DSI_PHY_ULPS_ERROR) {
-				DSI_ERR("Ulps PHY state change(%d) failed\n",
+				printk("Ulps PHY state change(%d) failed\n",
 						enable);
 				return -EINVAL;
 			}
@@ -1810,7 +1846,7 @@
 	else if (rc == DSI_PHY_ULPS_NOT_HANDLED) {
 		rc = dsi_ctrl_set_ulps(m_ctrl->ctrl, enable);
 		if (rc) {
-			DSI_ERR("Ulps controller state change(%d) failed\n",
+			printk("Ulps controller state change(%d) failed\n",
 					enable);
 			return rc;
 		}
@@ -1821,7 +1857,7 @@
 
 			rc = dsi_ctrl_set_ulps(ctrl->ctrl, enable);
 			if (rc) {
-				DSI_ERR("Ulps controller state change(%d) failed\n",
+				printk("Ulps controller state change(%d) failed\n",
 						enable);
 				return rc;
 			}
@@ -1847,8 +1883,9 @@
 	bool ulps_enabled = false;
 
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -1861,13 +1898,13 @@
 	 */
 	rc = dsi_ctrl_set_clamp_state(m_ctrl->ctrl, enable, ulps_enabled);
 	if (rc) {
-		DSI_ERR("DSI ctrl clamp state change(%d) failed\n", enable);
+		printk("DSI ctrl clamp state change(%d) failed\n", enable);
 		return rc;
 	}
 
 	rc = dsi_phy_set_clamp_state(m_ctrl->phy, enable);
 	if (rc) {
-		DSI_ERR("DSI phy clamp state change(%d) failed\n", enable);
+		printk("DSI phy clamp state change(%d) failed\n", enable);
 		return rc;
 	}
 
@@ -1878,18 +1915,18 @@
 
 		rc = dsi_ctrl_set_clamp_state(ctrl->ctrl, enable, ulps_enabled);
 		if (rc) {
-			DSI_ERR("DSI Clamp state change(%d) failed\n", enable);
+			printk("DSI Clamp state change(%d) failed\n", enable);
 			return rc;
 		}
 
 		rc = dsi_phy_set_clamp_state(ctrl->phy, enable);
 		if (rc) {
-			DSI_ERR("DSI phy clamp state change(%d) failed\n",
+			printk("DSI phy clamp state change(%d) failed\n",
 				enable);
 			return rc;
 		}
 
-		DSI_DEBUG("Clamps %s for ctrl%d\n",
+		printk("Clamps %s for ctrl%d\n",
 			enable ? "enabled" : "disabled", i);
 	}
 
@@ -1909,16 +1946,17 @@
 	int i = 0;
 	struct dsi_display_ctrl *ctrl, *m_ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 	rc = dsi_ctrl_setup(m_ctrl->ctrl);
 	if (rc) {
-		DSI_ERR("DSI controller setup failed\n");
+		printk("DSI controller setup failed\n");
 		return rc;
 	}
 
@@ -1929,7 +1967,7 @@
 
 		rc = dsi_ctrl_setup(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("DSI controller setup failed\n");
+			printk("DSI controller setup failed\n");
 			return rc;
 		}
 	}
@@ -1952,9 +1990,10 @@
 	int i = 0;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -1966,7 +2005,7 @@
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 	rc = dsi_phy_idle_ctrl(m_ctrl->phy, true);
 	if (rc) {
-		DSI_ERR("DSI controller setup failed\n");
+		printk("DSI controller setup failed\n");
 		return rc;
 	}
 
@@ -1977,7 +2016,7 @@
 
 		rc = dsi_phy_idle_ctrl(ctrl->phy, true);
 		if (rc) {
-			DSI_ERR("DSI controller setup failed\n");
+			printk("DSI controller setup failed\n");
 			return rc;
 		}
 	}
@@ -1998,10 +2037,11 @@
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		struct msm_dsi_phy *phy = display->ctrl[i].phy;
 
@@ -2009,7 +2049,7 @@
 			continue;
 
 		if (!phy->allow_phy_power_off) {
-			DSI_DEBUG("phy doesn't support this feature\n");
+			printk("phy doesn't support this feature\n");
 			return 0;
 		}
 	}
@@ -2018,7 +2058,7 @@
 
 	rc = dsi_phy_idle_ctrl(m_ctrl->phy, false);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+		printk("[%s] failed to enable cmd engine, rc=%d\n",
 		       display->name, rc);
 		return rc;
 	}
@@ -2030,7 +2070,7 @@
 
 		rc = dsi_phy_idle_ctrl(ctrl->phy, false);
 		if (rc) {
-			DSI_ERR("DSI controller setup failed\n");
+			printk("DSI controller setup failed\n");
 			return rc;
 		}
 	}
@@ -2046,8 +2086,9 @@
 	uint32_t irq_status_idx = DSI_STATUS_INTERRUPT_COUNT;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("invalid display\n");
+		printk("invalid display\n");
 		return;
 	}
 
@@ -2071,7 +2112,7 @@
 		break;
 	default:
 		/* nothing to do */
-		DSI_DEBUG("[%s] unhandled event %d\n", display->name, event_idx);
+		printk("[%s] unhandled event %d\n", display->name, event_idx);
 		return;
 	}
 
@@ -2100,6 +2141,7 @@
 	struct dsi_display_ctrl *ctrl;
 	enum dsi_engine_state host_state = DSI_CTRL_ENGINE_ON;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Sequence does not matter for split dsi usecases */
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -2117,6 +2159,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Sequence does not matter for split dsi usecases */
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -2126,7 +2169,7 @@
 		rc = dsi_ctrl_set_power_state(ctrl->ctrl,
 					      DSI_CTRL_POWER_VREG_ON);
 		if (rc) {
-			DSI_ERR("[%s] Failed to set power state, rc=%d\n",
+			printk("[%s] Failed to set power state, rc=%d\n",
 			       ctrl->ctrl->name, rc);
 			goto error;
 		}
@@ -2150,6 +2193,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Sequence does not matter for split dsi usecases */
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -2159,7 +2203,7 @@
 		rc = dsi_ctrl_set_power_state(ctrl->ctrl,
 			DSI_CTRL_POWER_VREG_OFF);
 		if (rc) {
-			DSI_ERR("[%s] Failed to power off, rc=%d\n",
+			printk("[%s] Failed to power off, rc=%d\n",
 			       ctrl->ctrl->name, rc);
 			goto error;
 		}
@@ -2177,8 +2221,9 @@
 	unsigned long cmdline_topology = NO_OVERRIDE;
 	unsigned long cmdline_timing = NO_OVERRIDE;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (display_type >= MAX_DSI_ACTIVE_DISPLAY) {
-		DSI_ERR("display_type=%d not supported\n", display_type);
+		printk("display_type=%d not supported\n", display_type);
 		goto end;
 	}
 
@@ -2197,7 +2242,7 @@
 
 	if (kstrtol(str + strlen(":config"), INT_BASE_10,
 				(unsigned long *)&cmdline_topology)) {
-		DSI_ERR("invalid config index override: %s\n", boot_str);
+		printk("invalid config index override: %s\n", boot_str);
 		goto end;
 	}
 
@@ -2207,12 +2252,12 @@
 
 	if (kstrtol(str + strlen(":timing"), INT_BASE_10,
 				(unsigned long *)&cmdline_timing)) {
-		DSI_ERR("invalid timing index override: %s. resetting both timing and config\n",
+		printk("invalid timing index override: %s. resetting both timing and config\n",
 			boot_str);
 		cmdline_topology = NO_OVERRIDE;
 		goto end;
 	}
-	DSI_DEBUG("successfully parsed command line topology and timing\n");
+	printk("successfully parsed command line topology and timing\n");
 end:
 	display->cmdline_topology = cmdline_topology;
 	display->cmdline_timing = cmdline_timing;
@@ -2229,6 +2274,7 @@
 	char disp_buf[MAX_CMDLINE_PARAM_LEN] = {'\0'};
 	int i, j;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	for (i = 0; i < MAX_DSI_ACTIVE_DISPLAY; i++) {
 		strlcpy(disp_buf, boot_displays[i].boot_param,
 			MAX_CMDLINE_PARAM_LEN);
@@ -2237,7 +2283,7 @@
 
 		/* Use ':' as a delimiter to retrieve the display name */
 		if (!pos) {
-			DSI_DEBUG("display name[%s]is not valid\n", disp_buf);
+			printk("display name[%s]is not valid\n", disp_buf);
 			continue;
 		}
 
@@ -2258,6 +2304,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Sequence does not matter for split dsi usecases */
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -2266,7 +2313,7 @@
 
 		rc = dsi_phy_set_power_state(ctrl->phy, true);
 		if (rc) {
-			DSI_ERR("[%s] Failed to set power state, rc=%d\n",
+			printk("[%s] Failed to set power state, rc=%d\n",
 			       ctrl->phy->name, rc);
 			goto error;
 		}
@@ -2289,6 +2336,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Sequence does not matter for split dsi usecases */
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -2297,7 +2345,7 @@
 
 		rc = dsi_phy_set_power_state(ctrl->phy, false);
 		if (rc) {
-			DSI_ERR("[%s] Failed to power off, rc=%d\n",
+			printk("[%s] Failed to power off, rc=%d\n",
 			       ctrl->ctrl->name, rc);
 			goto error;
 		}
@@ -2312,6 +2360,7 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/*
 	 * For CPHY mode, the parent of mux_clks need to be set
 	 * to Cphy_clks to have correct dividers for byte and
@@ -2321,7 +2370,7 @@
 		rc = dsi_clk_update_parent(&display->clock_info.cphy_clks,
 			      &display->clock_info.mux_clks);
 		if (rc) {
-			DSI_ERR("failed update mux parent to shadow\n");
+			printk("failed update mux parent to shadow\n");
 			return rc;
 		}
 	}
@@ -2336,7 +2385,7 @@
 	rc = dsi_ctrl_set_clock_source(m_ctrl->ctrl,
 				&display->clock_info.mux_clks);
 	if (rc) {
-		DSI_ERR("[%s] failed to set source clocks for master, rc=%d\n",
+		printk("[%s] failed to set source clocks for master, rc=%d\n",
 			   display->name, rc);
 		return rc;
 	}
@@ -2350,7 +2399,7 @@
 		rc = dsi_ctrl_set_clock_source(ctrl->ctrl,
 					&display->clock_info.mux_clks);
 		if (rc) {
-			DSI_ERR("[%s] failed to set source clocks, rc=%d\n",
+			printk("[%s] failed to set source clocks, rc=%d\n",
 				   display->name, rc);
 			return rc;
 		}
@@ -2365,11 +2414,12 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_phy_reset_config(ctrl->ctrl, enable);
 		if (rc) {
-			DSI_ERR("[%s] failed to %s phy reset, rc=%d\n",
+			printk("[%s] failed to %s phy reset, rc=%d\n",
 			       display->name, enable ? "mask" : "unmask", rc);
 			return rc;
 		}
@@ -2385,6 +2435,7 @@
 	if (!display)
 		return;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		dsi_phy_toggle_resync_fifo(ctrl->phy);
@@ -2411,11 +2462,12 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_host_timing_update(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("[%s] failed to update host_%d, rc=%d\n",
+			printk("[%s] failed to update host_%d, rc=%d\n",
 				   display->name, i, rc);
 			goto error_host_deinit;
 		}
@@ -2437,6 +2489,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* when ULPS suspend feature is enabled, we will keep the lanes in
 	 * ULPS during suspend state and clamp DSI phy. Hence while resuming
 	 * we will programe DSI controller as part of core clock enable.
@@ -2450,7 +2503,7 @@
 			rc = dsi_ctrl_host_init(ctrl->ctrl,
 					display->is_cont_splash_enabled);
 			if (rc) {
-				DSI_ERR("[%s] failed to init host_%d, rc=%d\n",
+				printk("[%s] failed to init host_%d, rc=%d\n",
 				       display->name, i, rc);
 				goto error_host_deinit;
 			}
@@ -2462,7 +2515,7 @@
 							DSI_CTRL_OP_HOST_INIT,
 							true);
 			if (rc)
-				DSI_DEBUG("host init update failed rc=%d\n",
+				printk("host init update failed rc=%d\n",
 						rc);
 		}
 	}
@@ -2482,11 +2535,12 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_host_deinit(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("[%s] failed to deinit host_%d, rc=%d\n",
+			printk("[%s] failed to deinit host_%d, rc=%d\n",
 			       display->name, i, rc);
 		}
 	}
@@ -2500,11 +2554,12 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Host engine states are already taken care for
 	 * continuous splash case
 	 */
 	if (display->is_cont_splash_enabled) {
-		DSI_DEBUG("cont splash enabled, host enable not required\n");
+		printk("cont splash enabled, host enable not required\n");
 		return 0;
 	}
 
@@ -2512,7 +2567,7 @@
 
 	rc = dsi_ctrl_set_host_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable host engine, rc=%d\n",
+		printk("[%s] failed to enable host engine, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2525,7 +2580,7 @@
 		rc = dsi_ctrl_set_host_engine_state(ctrl->ctrl,
 						    DSI_CTRL_ENGINE_ON);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable sl host engine, rc=%d\n",
+			printk("[%s] failed to enable sl host engine, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_master;
 		}
@@ -2544,6 +2599,7 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 	/*
 	 * For platforms where ULPS is controlled by DSI controller block,
@@ -2559,7 +2615,7 @@
 					DSI_CTRL_OP_HOST_ENGINE,
 					false);
 			if (rc)
-				DSI_DEBUG("host state update failed %d\n", rc);
+				printk("host state update failed %d\n", rc);
 		}
 		return rc;
 	}
@@ -2572,13 +2628,13 @@
 		rc = dsi_ctrl_set_host_engine_state(ctrl->ctrl,
 						    DSI_CTRL_ENGINE_OFF);
 		if (rc)
-			DSI_ERR("[%s] failed to disable host engine, rc=%d\n",
+			printk("[%s] failed to disable host engine, rc=%d\n",
 			       display->name, rc);
 	}
 
 	rc = dsi_ctrl_set_host_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_OFF);
 	if (rc) {
-		DSI_ERR("[%s] failed to disable host engine, rc=%d\n",
+		printk("[%s] failed to disable host engine, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2593,11 +2649,12 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->video_master_idx];
 
 	rc = dsi_ctrl_set_vid_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable vid engine, rc=%d\n",
+		printk("[%s] failed to enable vid engine, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2610,7 +2667,7 @@
 		rc = dsi_ctrl_set_vid_engine_state(ctrl->ctrl,
 						   DSI_CTRL_ENGINE_ON);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable vid engine, rc=%d\n",
+			printk("[%s] failed to enable vid engine, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_master;
 		}
@@ -2629,6 +2686,7 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->video_master_idx];
 
 	display_for_each_ctrl(i, display) {
@@ -2639,13 +2697,13 @@
 		rc = dsi_ctrl_set_vid_engine_state(ctrl->ctrl,
 						   DSI_CTRL_ENGINE_OFF);
 		if (rc)
-			DSI_ERR("[%s] failed to disable vid engine, rc=%d\n",
+			printk("[%s] failed to disable vid engine, rc=%d\n",
 			       display->name, rc);
 	}
 
 	rc = dsi_ctrl_set_vid_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_OFF);
 	if (rc)
-		DSI_ERR("[%s] failed to disable mvid engine, rc=%d\n",
+		printk("[%s] failed to disable mvid engine, rc=%d\n",
 		       display->name, rc);
 
 	return rc;
@@ -2658,6 +2716,7 @@
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 	enum dsi_phy_pll_source m_src = DSI_PLL_SOURCE_STANDALONE;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->clk_master_idx];
 	if (display->ctrl_count > 1)
 		m_src = DSI_PLL_SOURCE_NATIVE;
@@ -2668,7 +2727,7 @@
 			    true,
 			    display->is_cont_splash_enabled);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI PHY, rc=%d\n",
+		printk("[%s] failed to enable DSI PHY, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2684,7 +2743,7 @@
 				    true,
 				    display->is_cont_splash_enabled);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable DSI PHY, rc=%d\n",
+			printk("[%s] failed to enable DSI PHY, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_master;
 		}
@@ -2704,6 +2763,7 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->clk_master_idx];
 
 	display_for_each_ctrl(i, display) {
@@ -2713,13 +2773,13 @@
 
 		rc = dsi_phy_disable(ctrl->phy);
 		if (rc)
-			DSI_ERR("[%s] failed to disable DSI PHY, rc=%d\n",
+			printk("[%s] failed to disable DSI PHY, rc=%d\n",
 			       display->name, rc);
 	}
 
 	rc = dsi_phy_disable(m_ctrl->phy);
 	if (rc)
-		DSI_ERR("[%s] failed to disable DSI PHY, rc=%d\n",
+		printk("[%s] failed to disable DSI PHY, rc=%d\n",
 		       display->name, rc);
 
 	return rc;
@@ -2736,6 +2796,7 @@
 	struct dsi_display_ctrl *ctrl;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!(flags & DSI_CTRL_CMD_LAST_COMMAND))
 		return;
 
@@ -2755,6 +2816,7 @@
 	struct dsi_display_ctrl *ctrl, *m_ctrl;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_flags = (DSI_CTRL_CMD_BROADCAST | DSI_CTRL_CMD_BROADCAST_MASTER |
 		   DSI_CTRL_CMD_DEFER_TRIGGER | DSI_CTRL_CMD_FETCH_MEMORY);
 	flags = (DSI_CTRL_CMD_BROADCAST | DSI_CTRL_CMD_DEFER_TRIGGER |
@@ -2779,7 +2841,7 @@
 	dsi_display_mask_overflow(display, m_flags, true);
 	rc = dsi_ctrl_cmd_transfer(m_ctrl->ctrl, msg, &m_flags);
 	if (rc) {
-		DSI_ERR("[%s] cmd transfer failed on master,rc=%d\n",
+		printk("[%s] cmd transfer failed on master,rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2791,14 +2853,14 @@
 
 		rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, msg, &flags);
 		if (rc) {
-			DSI_ERR("[%s] cmd transfer failed, rc=%d\n",
+			printk("[%s] cmd transfer failed, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
 
 		rc = dsi_ctrl_cmd_tx_trigger(ctrl->ctrl, flags);
 		if (rc) {
-			DSI_ERR("[%s] cmd trigger failed, rc=%d\n",
+			printk("[%s] cmd trigger failed, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
@@ -2806,7 +2868,7 @@
 
 	rc = dsi_ctrl_cmd_tx_trigger(m_ctrl->ctrl, m_flags);
 	if (rc) {
-		DSI_ERR("[%s] cmd trigger failed for master, rc=%d\n",
+		printk("[%s] cmd trigger failed for master, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2818,7 +2880,7 @@
 
 		rc = dsi_ctrl_clear_slave_dma_status(ctrl->ctrl, flags);
 		if (rc) {
-			DSI_ERR("[%s] clear interrupt status failed, rc=%d\n",
+			printk("[%s] clear interrupt status failed, rc=%d\n",
 				display->name, rc);
 			goto error;
 		}
@@ -2835,11 +2897,12 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* For continuous splash use case ctrl states are updated
 	 * separately and hence we do an early return
 	 */
 	if (display->is_cont_splash_enabled) {
-		DSI_DEBUG("cont splash enabled, phy sw reset not required\n");
+		printk("cont splash enabled, phy sw reset not required\n");
 		return 0;
 	}
 
@@ -2847,7 +2910,7 @@
 
 	rc = dsi_ctrl_phy_sw_reset(m_ctrl->ctrl);
 	if (rc) {
-		DSI_ERR("[%s] failed to reset phy, rc=%d\n", display->name, rc);
+		printk("[%s] failed to reset phy, rc=%d\n", display->name, rc);
 		goto error;
 	}
 
@@ -2858,7 +2921,7 @@
 
 		rc = dsi_ctrl_phy_sw_reset(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("[%s] failed to reset phy, rc=%d\n",
+			printk("[%s] failed to reset phy, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
@@ -2886,8 +2949,9 @@
 	struct dsi_display *display;
 	int rc = 0, ret = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!host || !msg) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return 0;
 	}
 
@@ -2895,28 +2959,28 @@
 
 	/* Avoid sending DCS commands when ESD recovery is pending */
 	if (atomic_read(&display->panel->esd_recovery_pending)) {
-		DSI_DEBUG("ESD recovery pending\n");
+		printk("ESD recovery pending\n");
 		return 0;
 	}
 
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable all DSI clocks, rc=%d\n",
+		printk("[%s] failed to enable all DSI clocks, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
 
 	rc = dsi_display_wake_up(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to wake up display, rc=%d\n",
+		printk("[%s] failed to wake up display, rc=%d\n",
 		       display->name, rc);
 		goto error_disable_clks;
 	}
 
 	rc = dsi_display_cmd_engine_enable(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+		printk("[%s] failed to enable cmd engine, rc=%d\n",
 		       display->name, rc);
 		goto error_disable_clks;
 	}
@@ -2924,7 +2988,7 @@
 	if (display->tx_cmd_buf == NULL) {
 		rc = dsi_host_alloc_cmd_tx_buffer(display);
 		if (rc) {
-			DSI_ERR("failed to allocate cmd tx buffer memory\n");
+			printk("failed to allocate cmd tx buffer memory\n");
 			goto error_disable_cmd_engine;
 		}
 	}
@@ -2932,7 +2996,7 @@
 	if (display->ctrl_count > 1 && !(msg->flags & MIPI_DSI_MSG_UNICAST)) {
 		rc = dsi_display_broadcast_cmd(display, msg);
 		if (rc) {
-			DSI_ERR("[%s] cmd broadcast failed, rc=%d\n",
+			printk("[%s] cmd broadcast failed, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_cmd_engine;
 		}
@@ -2948,7 +3012,7 @@
 		rc = dsi_ctrl_cmd_transfer(display->ctrl[ctrl_idx].ctrl, msg,
 				&cmd_flags);
 		if (rc) {
-			DSI_ERR("[%s] cmd transfer failed, rc=%d\n",
+			printk("[%s] cmd transfer failed, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_cmd_engine;
 		}
@@ -2957,14 +3021,14 @@
 error_disable_cmd_engine:
 	ret = dsi_display_cmd_engine_disable(display);
 	if (ret) {
-		DSI_ERR("[%s]failed to disable DSI cmd engine, rc=%d\n",
+		printk("[%s]failed to disable DSI cmd engine, rc=%d\n",
 				display->name, ret);
 	}
 error_disable_clks:
 	ret = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_OFF);
 	if (ret) {
-		DSI_ERR("[%s] failed to disable all DSI clocks, rc=%d\n",
+		printk("[%s] failed to disable all DSI clocks, rc=%d\n",
 		       display->name, ret);
 	}
 error:
@@ -2988,7 +3052,7 @@
 
 	rc = mipi_dsi_host_register(host);
 	if (rc) {
-		DSI_ERR("[%s] failed to register mipi dsi host, rc=%d\n",
+		printk("[%s] failed to register mipi dsi host, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -3001,6 +3065,7 @@
 	int rc = 0;
 	struct mipi_dsi_host *host = &display->host;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	mipi_dsi_host_unregister(host);
 
 	host->dev = NULL;
@@ -3016,6 +3081,7 @@
 	struct dsi_clk_link_set *mux = &display->clock_info.mux_clks;
 	struct dsi_clk_link_set *shadow = &display->clock_info.shadow_clks;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (src->byte_clk) {
 		devm_clk_put(&display->pdev->dev, src->byte_clk);
 		src->byte_clk = NULL;
@@ -3105,19 +3171,19 @@
 
 	num_clk = dsi_display_get_clocks_count(display, dsi_clock_name);
 
-	DSI_DEBUG("clk count=%d\n", num_clk);
+	printk("clk count=%d\n", num_clk);
 
 	for (i = 0; i < num_clk; i++) {
 		dsi_display_get_clock_name(display, dsi_clock_name, i,
 						&clk_name);
 
-		DSI_DEBUG("clock name:%s\n", clk_name);
+		printk("clock name:%s\n", clk_name);
 
 		dsi_clk = devm_clk_get(&display->pdev->dev, clk_name);
 		if (IS_ERR_OR_NULL(dsi_clk)) {
 			rc = PTR_ERR(dsi_clk);
 
-			DSI_ERR("failed to get %s, rc=%d\n", clk_name, rc);
+			printk("failed to get %s, rc=%d\n", clk_name, rc);
 
 			if (dsi_display_check_prefix(mux_byte, clk_name)) {
 				mux->byte_clk = NULL;
@@ -3229,7 +3295,7 @@
 	void *clk_handle = NULL;
 
 	if (!priv) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -3240,7 +3306,7 @@
 	} else if (clk_state_info.client == DSI_CLK_REQ_DSI_CLIENT) {
 		clk_handle = display->dsi_clk_handle;
 	} else {
-		DSI_ERR("invalid clk handle, return error\n");
+		printk("invalid clk handle, return error\n");
 		return -EINVAL;
 	}
 
@@ -3251,7 +3317,7 @@
 	rc = dsi_display_clk_ctrl(clk_handle,
 		clk_state_info.clk_type, clk_state_info.clk_state);
 	if (rc) {
-		DSI_ERR("[%s] failed to %d DSI %d clocks, rc=%d\n",
+		printk("[%s] failed to %d DSI %d clocks, rc=%d\n",
 		       display->name, clk_state_info.clk_state,
 		       clk_state_info.clk_type, rc);
 		return rc;
@@ -3320,7 +3386,7 @@
 			rc = dsi_display_set_ulps(display, true);
 		}
 		if (rc)
-			DSI_ERR("%s: failed enable ulps, rc = %d\n",
+			printk("%s: failed enable ulps, rc = %d\n",
 			       __func__, rc);
 	}
 
@@ -3334,7 +3400,7 @@
 		 */
 		rc = dsi_display_config_clk_gating(display, false);
 		if (rc)
-			DSI_ERR("[%s] failed to disable clk gating, rc=%d\n",
+			printk("[%s] failed to disable clk gating, rc=%d\n",
 					display->name, rc);
 	}
 
@@ -3348,12 +3414,12 @@
 			dsi_display_phy_idle_off(display);
 			rc = dsi_display_set_clamp(display, true);
 			if (rc)
-				DSI_ERR("%s: Failed to enable dsi clamps. rc=%d\n",
+				printk("%s: Failed to enable dsi clamps. rc=%d\n",
 					__func__, rc);
 
 			rc = dsi_display_phy_reset_config(display, false);
 			if (rc)
-				DSI_ERR("%s: Failed to reset phy, rc=%d\n",
+				printk("%s: Failed to reset phy, rc=%d\n",
 						__func__, rc);
 		} else {
 			/* Make sure that controller is not in ULPS state when
@@ -3361,7 +3427,7 @@
 			 */
 			rc = dsi_display_set_ulps(display, false);
 			if (rc)
-				DSI_ERR("%s: failed to disable ulps. rc=%d\n",
+				printk("%s: failed to disable ulps. rc=%d\n",
 					__func__, rc);
 		}
 		/* dsi will not be able to serve irqs from here on */
@@ -3423,7 +3489,7 @@
 			display->ulps_enabled = false;
 			rc = dsi_display_set_ulps(display, true);
 			if (rc) {
-				DSI_ERR("%s: Failed to enter ULPS. rc=%d\n",
+				printk("%s: Failed to enter ULPS. rc=%d\n",
 					__func__, rc);
 				goto error;
 			}
@@ -3431,14 +3497,14 @@
 
 		rc = dsi_display_phy_reset_config(display, true);
 		if (rc) {
-			DSI_ERR("%s: Failed to reset phy, rc=%d\n",
+			printk("%s: Failed to reset phy, rc=%d\n",
 						__func__, rc);
 			goto error;
 		}
 
 		rc = dsi_display_set_clamp(display, false);
 		if (rc) {
-			DSI_ERR("%s: Failed to disable dsi clamps. rc=%d\n",
+			printk("%s: Failed to disable dsi clamps. rc=%d\n",
 				__func__, rc);
 			goto error;
 		}
@@ -3457,7 +3523,7 @@
 		if (display->ulps_enabled) {
 			rc = dsi_display_set_ulps(display, false);
 			if (rc) {
-				DSI_ERR("%s: failed to disable ulps, rc= %d\n",
+				printk("%s: failed to disable ulps, rc= %d\n",
 				       __func__, rc);
 				goto error;
 			}
@@ -3468,7 +3534,7 @@
 
 		rc = dsi_display_config_clk_gating(display, true);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable clk gating %d\n",
+			printk("[%s] failed to enable clk gating %d\n",
 					display->name, rc);
 			goto error;
 		}
@@ -3491,7 +3557,7 @@
 	struct dsi_display *display = priv;
 
 	if (!display) {
-		DSI_ERR("%s: Invalid arg\n", __func__);
+		printk("%s: Invalid arg\n", __func__);
 		return -EINVAL;
 	}
 
@@ -3499,12 +3565,12 @@
 	    (curr_state == DSI_CLK_OFF)) {
 		rc = dsi_display_phy_power_off(display);
 		if (rc)
-			DSI_ERR("[%s] failed to power off PHY, rc=%d\n",
+			printk("[%s] failed to power off PHY, rc=%d\n",
 				   display->name, rc);
 
 		rc = dsi_display_ctrl_power_off(display);
 		if (rc)
-			DSI_ERR("[%s] failed to power DSI vregs, rc=%d\n",
+			printk("[%s] failed to power DSI vregs, rc=%d\n",
 				   display->name, rc);
 	}
 	return rc;
@@ -3519,7 +3585,7 @@
 	struct dsi_display *display = priv;
 
 	if (!display) {
-		DSI_ERR("%s: invalid input\n", __func__);
+		printk("%s: invalid input\n", __func__);
 		return -EINVAL;
 	}
 
@@ -3533,22 +3599,22 @@
 		 *     not be changed during static screen.
 		 */
 
-		DSI_DEBUG("updating power states for ctrl and phy\n");
+		printk("updating power states for ctrl and phy\n");
 		rc = dsi_display_ctrl_power_on(display);
 		if (rc) {
-			DSI_ERR("[%s] failed to power on dsi controllers, rc=%d\n",
+			printk("[%s] failed to power on dsi controllers, rc=%d\n",
 				   display->name, rc);
 			return rc;
 		}
 
 		rc = dsi_display_phy_power_on(display);
 		if (rc) {
-			DSI_ERR("[%s] failed to power on dsi phy, rc = %d\n",
+			printk("[%s] failed to power on dsi phy, rc = %d\n",
 				   display->name, rc);
 			return rc;
 		}
 
-		DSI_DEBUG("%s: Enable DSI core power\n", __func__);
+		printk("%s: Enable DSI core power\n", __func__);
 	}
 
 	return rc;
@@ -3571,12 +3637,17 @@
 	int rc = 0, i = 0;
 	const char *data;
 	u8 temp[DSI_LANE_MAX - 1];
+    const char* compatible = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("invalid params\n");
+		printk("invalid params\n");
 		return -EINVAL;
 	}
 
+    of_property_read_string(display->pdev->dev.of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
 	/* lane-map-v2 supersedes lane-map-v1 setting */
 	rc = of_property_read_u8_array(display->pdev->dev.of_node,
 		"qcom,lane-map-v2", temp, (DSI_LANE_MAX - 1));
@@ -3585,7 +3656,7 @@
 			display->lane_map.lane_map_v2[i] = BIT(temp[i]);
 		return 0;
 	} else if (rc != EINVAL) {
-		DSI_DEBUG("Incorrect mapping, configure default\n");
+		printk("Incorrect mapping, configure default\n");
 		goto set_default;
 	}
 
@@ -3649,6 +3720,7 @@
 			__func__, data);
 		goto set_default;
 	}
+
 	return 0;
 
 set_default:
@@ -3667,6 +3739,7 @@
 	u32 *val = NULL;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	val = kcalloc(count, sizeof(*val), GFP_KERNEL);
 	if (ZERO_OR_NULL_PTR(val)) {
 		rc = -ENOMEM;
@@ -3687,7 +3760,7 @@
 
 	rc = val[index];
 
-	DSI_DEBUG("%s index=%d\n", propname, rc);
+	printk("%s index=%d\n", propname, rc);
 end:
 	kfree(val);
 	return rc;
@@ -3711,6 +3784,7 @@
 	struct device_node *of_node = display->pdev->dev.of_node;
 	char *dsi_ctrl_name, *dsi_phy_name;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!strcmp(display->display_type, "primary")) {
 		dsi_ctrl_name = "qcom,dsi-ctrl-num";
 		dsi_phy_name = "qcom,dsi-phy-num";
@@ -3725,17 +3799,17 @@
 
 	phy_count = dsi_display_get_phandle_count(display, dsi_phy_name);
 
-	DSI_DEBUG("ctrl count=%d, phy count=%d\n",
+	printk("ctrl count=%d, phy count=%d\n",
 			display->ctrl_count, phy_count);
 
 	if (!phy_count || !display->ctrl_count) {
-		DSI_ERR("no ctrl/phys found\n");
+		printk("no ctrl/phys found\n");
 		rc = -ENODEV;
 		goto error;
 	}
 
 	if (phy_count != display->ctrl_count) {
-		DSI_ERR("different ctrl and phy counts\n");
+		printk("different ctrl and phy counts\n");
 		rc = -ENODEV;
 		goto error;
 	}
@@ -3769,7 +3843,7 @@
 			break;
 	}
 
-	DSI_DEBUG("success\n");
+	printk("success\n");
 error:
 	return rc;
 }
@@ -3780,12 +3854,13 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		ctrl->ctrl = dsi_ctrl_get(ctrl->ctrl_of_node);
 		if (IS_ERR_OR_NULL(ctrl->ctrl)) {
 			rc = PTR_ERR(ctrl->ctrl);
-			DSI_ERR("failed to get dsi controller, rc=%d\n", rc);
+			printk("failed to get dsi controller, rc=%d\n", rc);
 			ctrl->ctrl = NULL;
 			goto error_ctrl_put;
 		}
@@ -3793,7 +3868,7 @@
 		ctrl->phy = dsi_phy_get(ctrl->phy_of_node);
 		if (IS_ERR_OR_NULL(ctrl->phy)) {
 			rc = PTR_ERR(ctrl->phy);
-			DSI_ERR("failed to get phy controller, rc=%d\n", rc);
+			printk("failed to get phy controller, rc=%d\n", rc);
 			dsi_ctrl_put(ctrl->ctrl);
 			ctrl->phy = NULL;
 			goto error_ctrl_put;
@@ -3807,7 +3882,7 @@
 				display->cmdline_topology);
 	if (IS_ERR_OR_NULL(display->panel)) {
 		rc = PTR_ERR(display->panel);
-		DSI_ERR("failed to get panel, rc=%d\n", rc);
+		printk("failed to get panel, rc=%d\n", rc);
 		display->panel = NULL;
 		goto error_ctrl_put;
 	}
@@ -3823,13 +3898,13 @@
 
 	rc = dsi_display_parse_lane_map(display);
 	if (rc) {
-		DSI_ERR("Lane map not found, rc=%d\n", rc);
+		printk("Lane map not found, rc=%d\n", rc);
 		goto error_ctrl_put;
 	}
 
 	rc = dsi_display_clocks_init(display);
 	if (rc) {
-		DSI_ERR("Failed to parse clock data, rc=%d\n", rc);
+		printk("Failed to parse clock data, rc=%d\n", rc);
 		goto error_ctrl_put;
 	}
 
@@ -3849,9 +3924,10 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	rc = dsi_display_clocks_deinit(display);
 	if (rc)
-		DSI_ERR("clocks deinit failed, rc=%d\n", rc);
+		printk("clocks deinit failed, rc=%d\n", rc);
 
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -3873,6 +3949,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/*
 	 * To set a mode:
 	 * 1. Controllers should be turned off.
@@ -3900,35 +3977,36 @@
 {
 	struct dsi_display_mode *cur;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !tgt || !display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return false;
 	}
 
 	cur = display->panel->cur_mode;
 
 	if (cur->timing.h_active != tgt->timing.h_active) {
-		DSI_DEBUG("timing.h_active differs %d %d\n",
+		printk("timing.h_active differs %d %d\n",
 				cur->timing.h_active, tgt->timing.h_active);
 		return false;
 	}
 
 	if (cur->timing.h_back_porch != tgt->timing.h_back_porch) {
-		DSI_DEBUG("timing.h_back_porch differs %d %d\n",
+		printk("timing.h_back_porch differs %d %d\n",
 				cur->timing.h_back_porch,
 				tgt->timing.h_back_porch);
 		return false;
 	}
 
 	if (cur->timing.h_sync_width != tgt->timing.h_sync_width) {
-		DSI_DEBUG("timing.h_sync_width differs %d %d\n",
+		printk("timing.h_sync_width differs %d %d\n",
 				cur->timing.h_sync_width,
 				tgt->timing.h_sync_width);
 		return false;
 	}
 
 	if (cur->timing.h_front_porch != tgt->timing.h_front_porch) {
-		DSI_DEBUG("timing.h_front_porch differs %d %d\n",
+		printk("timing.h_front_porch differs %d %d\n",
 				cur->timing.h_front_porch,
 				tgt->timing.h_front_porch);
 		if (dfps_type != DSI_DFPS_IMMEDIATE_HFP)
@@ -3936,7 +4014,7 @@
 	}
 
 	if (cur->timing.h_skew != tgt->timing.h_skew) {
-		DSI_DEBUG("timing.h_skew differs %d %d\n",
+		printk("timing.h_skew differs %d %d\n",
 				cur->timing.h_skew,
 				tgt->timing.h_skew);
 		return false;
@@ -3945,28 +4023,28 @@
 	/* skip polarity comparison */
 
 	if (cur->timing.v_active != tgt->timing.v_active) {
-		DSI_DEBUG("timing.v_active differs %d %d\n",
+		printk("timing.v_active differs %d %d\n",
 				cur->timing.v_active,
 				tgt->timing.v_active);
 		return false;
 	}
 
 	if (cur->timing.v_back_porch != tgt->timing.v_back_porch) {
-		DSI_DEBUG("timing.v_back_porch differs %d %d\n",
+		printk("timing.v_back_porch differs %d %d\n",
 				cur->timing.v_back_porch,
 				tgt->timing.v_back_porch);
 		return false;
 	}
 
 	if (cur->timing.v_sync_width != tgt->timing.v_sync_width) {
-		DSI_DEBUG("timing.v_sync_width differs %d %d\n",
+		printk("timing.v_sync_width differs %d %d\n",
 				cur->timing.v_sync_width,
 				tgt->timing.v_sync_width);
 		return false;
 	}
 
 	if (cur->timing.v_front_porch != tgt->timing.v_front_porch) {
-		DSI_DEBUG("timing.v_front_porch differs %d %d\n",
+		printk("timing.v_front_porch differs %d %d\n",
 				cur->timing.v_front_porch,
 				tgt->timing.v_front_porch);
 		if (dfps_type != DSI_DFPS_IMMEDIATE_VFP)
@@ -3976,16 +4054,16 @@
 	/* skip polarity comparison */
 
 	if (cur->timing.refresh_rate == tgt->timing.refresh_rate)
-		DSI_DEBUG("timing.refresh_rate identical %d %d\n",
+		printk("timing.refresh_rate identical %d %d\n",
 				cur->timing.refresh_rate,
 				tgt->timing.refresh_rate);
 
 	if (cur->pixel_clk_khz != tgt->pixel_clk_khz)
-		DSI_DEBUG("pixel_clk_khz differs %d %d\n",
+		printk("pixel_clk_khz differs %d %d\n",
 				cur->pixel_clk_khz, tgt->pixel_clk_khz);
 
 	if (cur->dsi_mode_flags != tgt->dsi_mode_flags)
-		DSI_DEBUG("flags differs %d %d\n",
+		printk("flags differs %d %d\n",
 				cur->dsi_mode_flags, tgt->dsi_mode_flags);
 
 	return true;
@@ -4013,14 +4091,14 @@
 	int rc = 0;
 	int i;
 
-	DSI_DEBUG("%s:bit rate:%d\n", __func__, bit_clk_rate);
+	printk("%s:bit rate:%d\n", __func__, bit_clk_rate);
 	if (!display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (bit_clk_rate == 0) {
-		DSI_ERR("Invalid bit clock rate\n");
+		printk("Invalid bit clock rate\n");
 		return -EINVAL;
 	}
 
@@ -4048,7 +4126,7 @@
 			num_of_lanes++;
 
 		if (num_of_lanes == 0) {
-			DSI_ERR("Invalid lane count\n");
+			printk("Invalid lane count\n");
 			rc = -EINVAL;
 			goto error;
 		}
@@ -4079,11 +4157,11 @@
 			byte_intf_clk_rate = byte_clk_rate;
 		}
 
-		DSI_DEBUG("bit_clk_rate = %llu, bit_clk_rate_per_lane = %llu\n",
+		printk("bit_clk_rate = %llu, bit_clk_rate_per_lane = %llu\n",
 			 bit_rate, bit_rate_per_lane);
-		DSI_DEBUG("byte_clk_rate = %llu, byte_intf_clk_rate = %llu\n",
+		printk("byte_clk_rate = %llu, byte_intf_clk_rate = %llu\n",
 			  byte_clk_rate, byte_intf_clk_rate);
-		DSI_DEBUG("pclk_rate = %llu\n", pclk_rate);
+		printk("pclk_rate = %llu\n", pclk_rate);
 		SDE_EVT32(i, bit_rate, byte_clk_rate, pclk_rate);
 
 		ctrl->clk_freq.byte_clk_rate = byte_clk_rate;
@@ -4092,7 +4170,7 @@
 		rc = dsi_clk_set_link_frequencies(display->dsi_clk_handle,
 			ctrl->clk_freq, ctrl->cell_index);
 		if (rc) {
-			DSI_ERR("Failed to update link frequencies\n");
+			printk("Failed to update link frequencies\n");
 			goto error;
 		}
 
@@ -4120,6 +4198,7 @@
 	struct dsi_phy_cfg *cfg;
 	int phy_ver;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->clk_master_idx];
 	dsi_ctrl = m_ctrl->ctrl;
 
@@ -4202,7 +4281,7 @@
 	rc = dsi_clk_update_parent(parent_clk,
 				&display->clock_info.mux_clks);
 	if (rc) {
-		DSI_ERR("failed to update mux parent\n");
+		printk("failed to update mux parent\n");
 		goto exit;
 	}
 
@@ -4214,13 +4293,13 @@
 				ctrl->ctrl->clk_freq.byte_clk_rate,
 				ctrl->ctrl->clk_freq.byte_intf_clk_rate, i);
 		if (rc) {
-			DSI_ERR("failed to set byte rate for index:%d\n", i);
+			printk("failed to set byte rate for index:%d\n", i);
 			goto recover_byte_clk;
 		}
 		rc = dsi_clk_set_pixel_clk_rate(display->dsi_clk_handle,
 				   ctrl->ctrl->clk_freq.pix_clk_rate, i);
 		if (rc) {
-			DSI_ERR("failed to set pix rate for index:%d\n", i);
+			printk("failed to set pix rate for index:%d\n", i);
 			goto recover_pix_clk;
 		}
 	}
@@ -4238,7 +4317,7 @@
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_wait4dynamic_refresh_done(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("wait4dynamic refresh failed for dsi:%d\n", i);
+			printk("wait4dynamic refresh failed for dsi:%d\n", i);
 			goto recover_pix_clk;
 		} else {
 			DSI_INFO("dynamic refresh done on dsi: %s\n",
@@ -4255,7 +4334,7 @@
 				&display->clock_info.mux_clks);
 
 	if (rc)
-		DSI_ERR("could not switch back to src clks %d\n", rc);
+		printk("could not switch back to src clks %d\n", rc);
 
 	dsi_clk_disable_unprepare(enable_clk);
 
@@ -4319,7 +4398,7 @@
 
 	rc = dsi_display_update_dsi_bitrate(display, mode->timing.clk_rate_hz);
 	if (rc) {
-		DSI_ERR("failed set link frequencies %d\n", rc);
+		printk("failed set link frequencies %d\n", rc);
 		goto exit;
 	}
 
@@ -4361,8 +4440,9 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (clk_rate <= 0) {
-		DSI_ERR("%s: bitrate should be greater than 0\n", __func__);
+		printk("%s: bitrate should be greater than 0\n", __func__);
 		return -EINVAL;
 	}
 
@@ -4379,7 +4459,7 @@
 				__func__, clk_rate);
 		atomic_set(&display->clkrate_change_pending, 1);
 	} else {
-		DSI_ERR("%s: Failed to prepare to configure '%d'. rc = %d\n",
+		printk("%s: Failed to prepare to configure '%d'. rc = %d\n",
 				__func__, clk_rate, rc);
 		/* Caching clock failed, so don't go on doing so. */
 		atomic_set(&display->clkrate_change_pending, 0);
@@ -4400,8 +4480,9 @@
 	int i = 0;
 	struct dsi_dyn_clk_caps *dyn_clk_caps;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !dsi_mode || !display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 	timing = &dsi_mode->timing;
@@ -4409,24 +4490,24 @@
 	dsi_panel_get_dfps_caps(display->panel, &dfps_caps);
 	dyn_clk_caps = &(display->panel->dyn_clk_caps);
 	if (!dfps_caps.dfps_support && !dyn_clk_caps->maintain_const_fps) {
-		DSI_ERR("dfps or constant fps not supported\n");
+		printk("dfps or constant fps not supported\n");
 		return -ENOTSUPP;
 	}
 
 	if (dfps_caps.type == DSI_DFPS_IMMEDIATE_CLK) {
-		DSI_ERR("dfps clock method not supported\n");
+		printk("dfps clock method not supported\n");
 		return -ENOTSUPP;
 	}
 
 	/* For split DSI, update the clock master first */
 
-	DSI_DEBUG("configuring seamless dynamic fps\n\n");
+	printk("configuring seamless dynamic fps\n\n");
 	SDE_EVT32(SDE_EVTLOG_FUNC_ENTRY);
 
 	m_ctrl = &display->ctrl[display->clk_master_idx];
 	rc = dsi_ctrl_async_timing_update(m_ctrl->ctrl, timing);
 	if (rc) {
-		DSI_ERR("[%s] failed to dfps update host_%d, rc=%d\n",
+		printk("[%s] failed to dfps update host_%d, rc=%d\n",
 				display->name, i, rc);
 		goto error;
 	}
@@ -4439,7 +4520,7 @@
 
 		rc = dsi_ctrl_async_timing_update(ctrl->ctrl, timing);
 		if (rc) {
-			DSI_ERR("[%s] failed to dfps update host_%d, rc=%d\n",
+			printk("[%s] failed to dfps update host_%d, rc=%d\n",
 					display->name, i, rc);
 			goto error;
 		}
@@ -4472,12 +4553,12 @@
 	int add_porches, diff;
 
 	if (!b_fp_out) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!a_total || !new_fps) {
-		DSI_ERR("Invalid pixel total or new fps in mode request\n");
+		printk("Invalid pixel total or new fps in mode request\n");
 		return -EINVAL;
 	}
 
@@ -4495,11 +4576,11 @@
 	else
 		b_fp_new = b_fp - add_porches;
 
-	DSI_DEBUG("fps %u a %u b %u b_fp %u new_fp %d\n",
+	printk("fps %u a %u b %u b_fp %u new_fp %d\n",
 			new_fps, a_total, b_total, b_fp, b_fp_new);
 
 	if (b_fp_new < 0) {
-		DSI_ERR("Invalid new_hfp calcluated%d\n", b_fp_new);
+		printk("Invalid new_hfp calcluated%d\n", b_fp_new);
 		return -EINVAL;
 	}
 
@@ -4535,14 +4616,14 @@
 	int rc = 0;
 
 	if (!display || !adj_mode) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 	m_ctrl = display->ctrl[display->clk_master_idx].ctrl;
 
 	dsi_panel_get_dfps_caps(display->panel, &dfps_caps);
 	if (!dfps_caps.dfps_support) {
-		DSI_ERR("dfps not supported by panel\n");
+		printk("dfps not supported by panel\n");
 		return -EINVAL;
 	}
 
@@ -4552,14 +4633,14 @@
 	if (!curr_refresh_rate) {
 		if (!dsi_display_is_seamless_dfps_possible(display,
 				&per_ctrl_mode, dfps_caps.type)) {
-			DSI_ERR("seamless dynamic fps not supported for mode\n");
+			printk("seamless dynamic fps not supported for mode\n");
 			return -EINVAL;
 		}
 		if (display->panel->cur_mode) {
 			curr_refresh_rate =
 				display->panel->cur_mode->timing.refresh_rate;
 		} else {
-			DSI_ERR("cur_mode is not initialized\n");
+			printk("cur_mode is not initialized\n");
 			return -EINVAL;
 		}
 	}
@@ -4596,7 +4677,7 @@
 		break;
 
 	default:
-		DSI_ERR("Unsupported DFPS mode %d\n", dfps_caps.type);
+		printk("Unsupported DFPS mode %d\n", dfps_caps.type);
 		rc = -ENOTSUPP;
 	}
 
@@ -4609,16 +4690,16 @@
 	int rc = 0;
 
 	if (!display || !adj_mode) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return false;
 	}
 
 	/* Currently the only seamless transition is dynamic fps */
 	rc = dsi_display_get_dfps_timing(display, adj_mode, 0);
 	if (rc) {
-		DSI_DEBUG("Dynamic FPS not supported for seamless\n");
+		printk("Dynamic FPS not supported for seamless\n");
 	} else {
-		DSI_DEBUG("Mode switch is seamless Dynamic FPS\n");
+		printk("Mode switch is seamless Dynamic FPS\n");
 		adj_mode->dsi_mode_flags |= DSI_MODE_FLAG_DFPS |
 				DSI_MODE_FLAG_VBLANK_PRE_MODESET;
 	}
@@ -4643,7 +4724,7 @@
 	if ((cur_h_active == to_h_active) && (cur_v_active == to_v_active) &&
 			(cur_fps != to_fps)) {
 		to_mode->dsi_mode_flags |= DSI_MODE_FLAG_DMS_FPS;
-		DSI_DEBUG("DMS Modeset with FPS change\n");
+		printk("DMS Modeset with FPS change\n");
 	} else {
 		to_mode->dsi_mode_flags &= ~DSI_MODE_FLAG_DMS_FPS;
 	}
@@ -4662,7 +4743,7 @@
 
 	priv_info = mode->priv_info;
 	if (!priv_info) {
-		DSI_ERR("[%s] failed to get private info of the display mode\n",
+		printk("[%s] failed to get private info of the display mode\n",
 			display->name);
 		return -EINVAL;
 	}
@@ -4676,7 +4757,7 @@
 					     mode,
 					     &display->config);
 	if (rc) {
-		DSI_ERR("[%s] failed to get host config for mode, rc=%d\n",
+		printk("[%s] failed to get host config for mode, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -4688,7 +4769,7 @@
 			(DSI_MODE_FLAG_DFPS | DSI_MODE_FLAG_VRR)) {
 		rc = dsi_display_dfps_update(display, mode);
 		if (rc) {
-			DSI_ERR("[%s]DSI dfps update failed, rc=%d\n",
+			printk("[%s]DSI dfps update failed, rc=%d\n",
 					display->name, rc);
 			goto error;
 		}
@@ -4698,7 +4779,7 @@
 				&display->config, mode, mode->dsi_mode_flags,
 					display->dsi_clk_handle);
 			if (rc) {
-				DSI_ERR("failed to update ctrl config\n");
+				printk("failed to update ctrl config\n");
 				goto error;
 			}
 		}
@@ -4710,7 +4791,7 @@
 						priv_info->phy_timing_len,
 						commit_phy_timing);
 				if (rc)
-					DSI_ERR("Fail to add timing params\n");
+					printk("Fail to add timing params\n");
 			}
 		}
 		if (!(mode->dsi_mode_flags & DSI_MODE_FLAG_DYN_CLK))
@@ -4721,7 +4802,7 @@
 		if (display->panel->panel_mode == DSI_OP_VIDEO_MODE) {
 			rc = dsi_display_dynamic_clk_switch_vid(display, mode);
 			if (rc)
-				DSI_ERR("dynamic clk change failed %d\n", rc);
+				printk("dynamic clk change failed %d\n", rc);
 			/*
 			 * skip rest of the opearations since
 			 * dsi_display_dynamic_clk_switch_vid() already takes
@@ -4733,7 +4814,7 @@
 			rc = dsi_display_dynamic_clk_configure_cmd(display,
 					clk_rate);
 			if (rc) {
-				DSI_ERR("Failed to configure dynamic clk\n");
+				printk("Failed to configure dynamic clk\n");
 				return rc;
 			}
 		}
@@ -4745,7 +4826,7 @@
 				mode, mode->dsi_mode_flags,
 				display->dsi_clk_handle);
 		if (rc) {
-			DSI_ERR("[%s] failed to update ctrl config, rc=%d\n",
+			printk("[%s] failed to update ctrl config, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
@@ -4772,7 +4853,7 @@
 				priv_info->phy_timing_len,
 				commit_phy_timing);
 			if (rc)
-				DSI_ERR("failed to add DSI PHY timing params\n");
+				printk("failed to add DSI PHY timing params\n");
 		}
 	}
 error:
@@ -4790,8 +4871,11 @@
 {
 	int rc = 0;
 
+    const char* compatible = NULL;
+
+    printk("%s:%d, ACHEUL, display name: %s", __FUNCTION__, __LINE__, display->name);
 	if (!display) {
-		DSI_ERR("invalid display\n");
+		printk("invalid display\n");
 		return -EINVAL;
 	}
 
@@ -4800,6 +4884,9 @@
 
 	mutex_lock(&display->display_lock);
 
+    of_property_read_string(display->pdev->dev.of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
 	display->parser = dsi_parser_get(&display->pdev->dev);
 	if (display->fw && display->parser)
 		display->parser_node = dsi_parser_get_head_node(
@@ -4808,13 +4895,13 @@
 
 	rc = dsi_display_parse_dt(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to parse dt, rc=%d\n", display->name, rc);
+		printk("[%s] failed to parse dt, rc=%d\n", display->name, rc);
 		goto error;
 	}
 
 	rc = dsi_display_res_init(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to initialize resources, rc=%d\n",
+		printk("[%s] failed to initialize resources, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -4833,8 +4920,9 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("invalid display\n");
+		printk("invalid display\n");
 		return -EINVAL;
 	}
 
@@ -4842,7 +4930,7 @@
 
 	rc = dsi_display_res_deinit(display);
 	if (rc)
-		DSI_ERR("[%s] failed to deinitialize resource, rc=%d\n",
+		printk("[%s] failed to deinitialize resource, rc=%d\n",
 		       display->name, rc);
 
 	mutex_unlock(&display->display_lock);
@@ -4860,15 +4948,16 @@
 	struct dsi_display *display = dsi_display;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Vote for gdsc required to read register address space */
 	if (!display) {
-		DSI_ERR("invalid input display param\n");
+		printk("invalid input display param\n");
 		return -EINVAL;
 	}
 
 	rc = pm_runtime_get_sync(display->drm_dev->dev);
 	if (rc < 0) {
-		DSI_ERR("failed to vote gdsc for continuous splash, rc=%d\n",
+		printk("failed to vote gdsc for continuous splash, rc=%d\n",
 							rc);
 		return rc;
 	}
@@ -4891,7 +4980,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI link clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI link clocks, rc=%d\n",
 		       display->name, rc);
 		goto clk_manager_update;
 	}
@@ -4899,7 +4988,7 @@
 	/* Vote on panel regulator will be removed during suspend path */
 	rc = dsi_pwr_enable_regulator(&display->panel->power_info, true);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable vregs, rc=%d\n",
+		printk("[%s] failed to enable vregs, rc=%d\n",
 				display->panel->name, rc);
 		goto clks_disabled;
 	}
@@ -4936,13 +5025,14 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display->is_cont_splash_enabled)
 		return 0;
 
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_OFF);
 	if (rc)
-		DSI_ERR("[%s] failed to disable DSI link clocks, rc=%d\n",
+		printk("[%s] failed to disable DSI link clocks, rc=%d\n",
 		       display->name, rc);
 
 	pm_runtime_put_sync(display->drm_dev->dev);
@@ -4968,7 +5058,7 @@
 
 		atomic_set(&display->clkrate_change_pending, 0);
 	} else {
-		DSI_ERR("Failed to configure dsi bit clock '%d'. rc = %d\n",
+		printk("Failed to configure dsi bit clock '%d'. rc = %d\n",
 			display->cached_clk_rate, rc);
 	}
 
@@ -4985,7 +5075,7 @@
 		return 0;
 
 	if (display->panel->panel_mode == DSI_OP_CMD_MODE) {
-		DSI_ERR("[%s] split link is not supported in command mode\n",
+		printk("[%s] split link is not supported in command mode\n",
 			display->name);
 		rc = -ENOTSUPP;
 		goto error;
@@ -4994,7 +5084,7 @@
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		if (!ctrl->ctrl->split_link_supported) {
-			DSI_ERR("[%s] split link is not supported by hw\n",
+			printk("[%s] split link is not supported by hw\n",
 				display->name);
 			rc = -ENOTSUPP;
 			goto error;
@@ -5003,7 +5093,7 @@
 		set_bit(DSI_PHY_SPLIT_LINK, ctrl->phy->hw.feature_map);
 	}
 
-	DSI_DEBUG("Split link is enabled\n");
+	printk("Split link is enabled\n");
 	return 0;
 
 error:
@@ -5033,8 +5123,9 @@
 	char *client2 = "mdp_event_client";
 	int i, rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!dev || !pdev || !master) {
-		DSI_ERR("invalid param(s), dev %pK, pdev %pK, master %pK\n",
+		printk("invalid param(s), dev %pK, pdev %pK, master %pK\n",
 				dev, pdev, master);
 		return -EINVAL;
 	}
@@ -5042,22 +5133,27 @@
 	drm = dev_get_drvdata(master);
 	display = platform_get_drvdata(pdev);
 	if (!drm || !display) {
-		DSI_ERR("invalid param(s), drm %pK, display %pK\n",
+		printk("invalid param(s), drm %pK, display %pK\n",
 				drm, display);
 		return -EINVAL;
 	}
-	if (!display->panel_node)
+	if (!display->panel_node) {
+        printk("%s:%d, ACHEUL, no panel node", __FUNCTION__, __LINE__);
 		return 0;
+    }
 
-	if (!display->fw)
+	if (!display->fw){
 		display->name = display->panel_node->name;
+    }
+
+    printk("%s:%d, ACHEUL, display name: %s", __FUNCTION__, __LINE__, display->name);
 
 	/* defer bind if ext bridge driver is not loaded */
 	if (display->panel && display->panel->host_config.ext_bridge_mode) {
 		for (i = 0; i < display->ext_bridge_cnt; i++) {
 			if (!of_drm_find_bridge(
 					display->ext_bridge[i].node_of)) {
-				DSI_DEBUG("defer for bridge[%d] %s\n", i,
+				printk("defer for bridge[%d] %s\n", i,
 				  display->ext_bridge[i].node_of->full_name);
 				return -EPROBE_DEFER;
 			}
@@ -5068,14 +5164,14 @@
 
 	rc = dsi_display_validate_split_link(display);
 	if (rc) {
-		DSI_ERR("[%s] split link validation failed, rc=%d\n",
+		printk("[%s] split link validation failed, rc=%d\n",
 						 display->name, rc);
 		goto error;
 	}
 
 	rc = dsi_display_debugfs_init(display);
 	if (rc) {
-		DSI_ERR("[%s] debugfs init failed, rc=%d\n", display->name, rc);
+		printk("[%s] debugfs init failed, rc=%d\n", display->name, rc);
 		goto error;
 	}
 
@@ -5088,7 +5184,7 @@
 		display_ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_drv_init(display_ctrl->ctrl, display->root);
 		if (rc) {
-			DSI_ERR("[%s] failed to initialize ctrl[%d], rc=%d\n",
+			printk("[%s] failed to initialize ctrl[%d], rc=%d\n",
 			       display->name, i, rc);
 			goto error_ctrl_deinit;
 		}
@@ -5096,7 +5192,7 @@
 
 		rc = dsi_phy_drv_init(display_ctrl->phy);
 		if (rc) {
-			DSI_ERR("[%s] Failed to initialize phy[%d], rc=%d\n",
+			printk("[%s] Failed to initialize phy[%d], rc=%d\n",
 				display->name, i, rc);
 			(void)dsi_ctrl_drv_deinit(display_ctrl->ctrl);
 			goto error_ctrl_deinit;
@@ -5133,14 +5229,14 @@
 	if (IS_ERR_OR_NULL(display->clk_mngr)) {
 		rc = PTR_ERR(display->clk_mngr);
 		display->clk_mngr = NULL;
-		DSI_ERR("dsi clock registration failed, rc = %d\n", rc);
+		printk("dsi clock registration failed, rc = %d\n", rc);
 		goto error_ctrl_deinit;
 	}
 
 	handle = dsi_register_clk_handle(display->clk_mngr, client1);
 	if (IS_ERR_OR_NULL(handle)) {
 		rc = PTR_ERR(handle);
-		DSI_ERR("failed to register %s client, rc = %d\n",
+		printk("failed to register %s client, rc = %d\n",
 		       client1, rc);
 		goto error_clk_deinit;
 	} else {
@@ -5150,7 +5246,7 @@
 	handle = dsi_register_clk_handle(display->clk_mngr, client2);
 	if (IS_ERR_OR_NULL(handle)) {
 		rc = PTR_ERR(handle);
-		DSI_ERR("failed to register %s client, rc = %d\n",
+		printk("failed to register %s client, rc = %d\n",
 		       client2, rc);
 		goto error_clk_client_deinit;
 	} else {
@@ -5165,14 +5261,14 @@
 
 		rc = dsi_ctrl_clk_cb_register(display_ctrl->ctrl, &clk_cb);
 		if (rc) {
-			DSI_ERR("[%s] failed to register ctrl clk_cb[%d], rc=%d\n",
+			printk("[%s] failed to register ctrl clk_cb[%d], rc=%d\n",
 			       display->name, i, rc);
 			goto error_ctrl_deinit;
 		}
 
 		rc = dsi_phy_clk_cb_register(display_ctrl->phy, &clk_cb);
 		if (rc) {
-			DSI_ERR("[%s] failed to register phy clk_cb[%d], rc=%d\n",
+			printk("[%s] failed to register phy clk_cb[%d], rc=%d\n",
 			       display->name, i, rc);
 			goto error_ctrl_deinit;
 		}
@@ -5181,7 +5277,7 @@
 	dsi_display_update_byte_intf_div(display);
 	rc = dsi_display_mipi_host_init(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to initialize mipi host, rc=%d\n",
+		printk("[%s] failed to initialize mipi host, rc=%d\n",
 		       display->name, rc);
 		goto error_ctrl_deinit;
 	}
@@ -5189,7 +5285,7 @@
 	rc = dsi_panel_drv_init(display->panel, &display->host);
 	if (rc) {
 		if (rc != -EPROBE_DEFER)
-			DSI_ERR("[%s] failed to initialize panel driver, rc=%d\n",
+			printk("[%s] failed to initialize panel driver, rc=%d\n",
 			       display->name, rc);
 		goto error_host_deinit;
 	}
@@ -5208,7 +5304,7 @@
 		rc = dsi_phy_set_clk_freq(display_ctrl->phy,
 				&display_ctrl->ctrl->clk_freq);
 		if (rc) {
-			DSI_ERR("[%s] failed to set phy clk freq, rc=%d\n",
+			printk("[%s] failed to set phy clk freq, rc=%d\n",
 					display->name, rc);
 			goto error;
 		}
@@ -5217,6 +5313,7 @@
 	/* register te irq handler */
 	dsi_display_register_te_irq(display);
 
+    printk("%s:%d, ACHEUL error", __FUNCTION__, __LINE__);
 	goto error;
 
 error_host_deinit:
@@ -5234,6 +5331,7 @@
 	(void)dsi_display_debugfs_deinit(display);
 error:
 	mutex_unlock(&display->display_lock);
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -5251,14 +5349,15 @@
 	struct platform_device *pdev = to_platform_device(dev);
 	int i, rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!dev || !pdev) {
-		DSI_ERR("invalid param(s)\n");
+		printk("invalid param(s)\n");
 		return;
 	}
 
 	display = platform_get_drvdata(pdev);
 	if (!display) {
-		DSI_ERR("invalid display\n");
+		printk("invalid display\n");
 		return;
 	}
 
@@ -5266,12 +5365,12 @@
 
 	rc = dsi_panel_drv_deinit(display->panel);
 	if (rc)
-		DSI_ERR("[%s] failed to deinit panel driver, rc=%d\n",
+		printk("[%s] failed to deinit panel driver, rc=%d\n",
 		       display->name, rc);
 
 	rc = dsi_display_mipi_host_deinit(display);
 	if (rc)
-		DSI_ERR("[%s] failed to deinit mipi hosts, rc=%d\n",
+		printk("[%s] failed to deinit mipi hosts, rc=%d\n",
 		       display->name,
 		       rc);
 
@@ -5280,13 +5379,13 @@
 
 		rc = dsi_phy_drv_deinit(display_ctrl->phy);
 		if (rc)
-			DSI_ERR("[%s] failed to deinit phy%d driver, rc=%d\n",
+			printk("[%s] failed to deinit phy%d driver, rc=%d\n",
 			       display->name, i, rc);
 
 		display->ctrl->ctrl->dma_cmd_workq = NULL;
 		rc = dsi_ctrl_drv_deinit(display_ctrl->ctrl);
 		if (rc)
-			DSI_ERR("[%s] failed to deinit ctrl%d driver, rc=%d\n",
+			printk("[%s] failed to deinit ctrl%d driver, rc=%d\n",
 			       display->name, i, rc);
 	}
 
@@ -5315,21 +5414,32 @@
 {
 	int rc = 0;
 	struct platform_device *pdev = display->pdev;
+    const char* compatible    = NULL;
+    const char* acheul_tag    = NULL;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+    of_property_read_string(pdev->dev.of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible  : %s", __FUNCTION__, __LINE__, compatible);
+
+    of_property_read_string(pdev->dev.of_node, "acheul-tag", &acheul_tag);
+    printk("%s:%d, ACHEUL, acheul-tag: %s", __FUNCTION__, __LINE__, acheul_tag);
 
 	mutex_init(&display->display_lock);
 
 	rc = _dsi_display_dev_init(display);
 	if (rc) {
-		DSI_ERR("device init failed, rc=%d\n", rc);
+		printk("device init failed, rc=%d\n", rc);
 		goto end;
 	}
 
 	rc = component_add(&pdev->dev, &dsi_display_comp_ops);
 	if (rc)
-		DSI_ERR("component add failed, rc=%d\n", rc);
+		printk("component add failed, rc=%d\n", rc);
 
-	DSI_DEBUG("component add success: %s\n", display->name);
+	printk("component add success: %s\n", display->name);
 end:
+    printk("%s:%d, ACHEUL, out: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -5338,8 +5448,10 @@
 {
 	struct dsi_display *display = context;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	mutex_init(&display->display_lock);
 	if (fw) {
-		DSI_DEBUG("reading data from firmware, size=%zd\n",
+		printk("reading data from firmware, size=%zd\n",
 			fw->size);
 
 		display->fw = fw;
@@ -5349,7 +5461,7 @@
 	if (dsi_display_init(display))
 		return;
 
-	DSI_DEBUG("success\n");
+	printk("success\n");
 }
 
 int dsi_display_dev_probe(struct platform_device *pdev)
@@ -5360,8 +5472,20 @@
 	bool firm_req = false;
 	struct dsi_display_boot_param *boot_disp;
 
+    const char* compatible    = NULL;
+    const char* default_panel = NULL;
+    const char* panel_name    = NULL;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+    of_property_read_string(pdev->dev.of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
+    of_property_read_string(pdev->dev.of_node, "qcom,dsi-default-panel", &default_panel);
+    printk("%s:%d, ACHEUL, default_panel: %s", __FUNCTION__, __LINE__, default_panel);
+
 	if (!pdev || !pdev->dev.of_node) {
-		DSI_ERR("pdev not found\n");
+		printk("pdev not found\n");
 		rc = -ENODEV;
 		goto end;
 	}
@@ -5375,22 +5499,26 @@
 	display->dma_cmd_workq = create_singlethread_workqueue(
 			"dsi_dma_cmd_workq");
 	if (!display->dma_cmd_workq)  {
-		DSI_ERR("failed to create work queue\n");
+		printk("failed to create work queue\n");
 		rc =  -EINVAL;
 		goto end;
 	}
 
 	display->display_type = of_get_property(pdev->dev.of_node,
 				"label", NULL);
-	if (!display->display_type)
+	if (!display->display_type){
+        printk("%s:%d, ACHEUL, primary found", __FUNCTION__, __LINE__);
 		display->display_type = "primary";
+    }
 
-	if (!strcmp(display->display_type, "secondary"))
+	if (!strcmp(display->display_type, "secondary")){
+        printk("%s:%d, ACHEUL, secondary found", __FUNCTION__, __LINE__);
 		index = DSI_SECONDARY;
+    }
 
 	if (of_get_property(pdev->dev.of_node, "boot-panel-param", NULL)) {
 		boot_displays[index].boot_disp_en = false;
-		DSI_DEBUG("boot_displays[%d].boot_disp_en false!\n", index);
+		printk("boot_displays[%d].boot_disp_en false!\n", index);
 	}
 
 	boot_disp = &boot_displays[index];
@@ -5398,20 +5526,36 @@
 	if (boot_disp->boot_disp_en) {
 		mdp_node = of_parse_phandle(node, "qcom,mdp", 0);
 		if (!mdp_node) {
-			DSI_ERR("mdp_node not found\n");
+			printk("mdp_node not found\n");
 			rc = -ENODEV;
 			goto end;
 		}
 
 		/* The panel name should be same as UEFI name index */
 		panel_node = of_find_node_by_name(mdp_node, boot_disp->name);
-		if (!panel_node)
+		if (!panel_node){
+            printk("%s:%d, ACHEUL, panel node not found", __FUNCTION__, __LINE__);
 			DSI_WARN("panel_node %s not found\n", boot_disp->name);
+        }
+        else {
+            printk("%s:%d, ACHEUL, panel node found", __FUNCTION__, __LINE__);
+
+            of_property_read_string(panel_node, "qcom,mdss-dsi-panel-name", &panel_name);
+            printk("%s:%d, ACHEUL, default_panel: %s", __FUNCTION__, __LINE__, panel_name);
+        }
 	} else {
 		panel_node = of_parse_phandle(node,
 				"qcom,dsi-default-panel", 0);
-		if (!panel_node)
+		if (!panel_node){
+            printk("%s:%d, ACHEUL, panel node not found", __FUNCTION__, __LINE__);
 			DSI_WARN("default panel not found\n");
+        }
+        else {
+            printk("%s:%d, ACHEUL, panel node found", __FUNCTION__, __LINE__);
+
+            of_property_read_string(panel_node, "qcom,mdss-dsi-panel-name", &panel_name);
+            printk("%s:%d, ACHEUL, default_panel: %s", __FUNCTION__, __LINE__, panel_name);
+        }
 
 		if (IS_ENABLED(CONFIG_DSI_PARSER))
 			firm_req = !request_firmware_nowait(
@@ -5434,8 +5578,10 @@
 	/* initialize display in firmware callback */
 	if (!firm_req) {
 		rc = dsi_display_init(display);
-		if (rc)
+		if (rc){
+            printk("%s:%d, ACHEUL, display init failed", __FUNCTION__, __LINE__);
 			goto end;
+        }
 	}
 
 	return 0;
@@ -5443,6 +5589,8 @@
 	if (display)
 		devm_kfree(&pdev->dev, display);
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
+	mutex_init(&display->display_lock);
 	return rc;
 }
 
@@ -5452,8 +5600,9 @@
 	struct dsi_display *display;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!pdev) {
-		DSI_ERR("Invalid device\n");
+		printk("Invalid device\n");
 		return -EINVAL;
 	}
 
@@ -5485,6 +5634,7 @@
 {
 	int i, count = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	for (i = 0; i < MAX_DSI_ACTIVE_DISPLAY; i++) {
 		struct dsi_display *display = boot_displays[i].disp;
 
@@ -5492,6 +5642,7 @@
 			count++;
 	}
 
+    printk("%s:%d, ACHEUL, count: %d", __FUNCTION__, __LINE__, count);
 	return count;
 }
 
@@ -5499,8 +5650,9 @@
 {
 	int index = 0, count = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display_array || !max_display_count) {
-		DSI_ERR("invalid params\n");
+		printk("invalid params\n");
 		return 0;
 	}
 
@@ -5521,8 +5673,9 @@
 	struct dsi_bridge *bridge;
 	struct msm_drm_private *priv = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->drm_dev || !enc) {
-		DSI_ERR("invalid param(s)\n");
+		printk("invalid param(s)\n");
 		return -EINVAL;
 	}
 
@@ -5530,20 +5683,20 @@
 	priv = display->drm_dev->dev_private;
 
 	if (!priv) {
-		DSI_ERR("Private data is not present\n");
+		printk("Private data is not present\n");
 		rc = -EINVAL;
 		goto error;
 	}
 
 	if (display->bridge) {
-		DSI_ERR("display is already initialize\n");
+		printk("display is already initialize\n");
 		goto error;
 	}
 
 	bridge = dsi_drm_bridge_init(display, display->drm_dev, enc);
 	if (IS_ERR_OR_NULL(bridge)) {
 		rc = PTR_ERR(bridge);
-		DSI_ERR("[%s] brige init failed, %d\n", display->name, rc);
+		printk("[%s] brige init failed, %d\n", display->name, rc);
 		goto error;
 	}
 
@@ -5559,8 +5712,9 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -5594,6 +5748,7 @@
 	struct drm_display_mode *pmode, *pt;
 	int count;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* if there are modes defined in panel, ignore external modes */
 	if (display->panel->num_timing_nodes)
 		return dsi_connector_get_modes(connector, disp, avail_res);
@@ -5619,6 +5774,7 @@
 	struct dsi_display *display = disp;
 	enum drm_mode_status status;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* always do internal mode_valid check */
 	status = dsi_conn_mode_valid(connector, mode, disp, avail_res);
 	if (status != MODE_OK)
@@ -5644,14 +5800,15 @@
 	struct dsi_display *display;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!info || !disp) {
-		DSI_ERR("invalid params\n");
+		printk("invalid params\n");
 		return -EINVAL;
 	}
 
 	display = disp;
 	if (!display->panel) {
-		DSI_ERR("invalid display panel\n");
+		printk("invalid display panel\n");
 		return -EINVAL;
 	}
 
@@ -5690,6 +5847,7 @@
 	struct msm_display_topology *topology;
 	struct dsi_display *ext_display = (struct dsi_display *)display;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!drm_mode || !mode_info ||
 			!avail_res || !avail_res->max_mixer_width)
 		return -EINVAL;
@@ -5724,7 +5882,7 @@
 		}
 	}
 
-	DSI_DEBUG("%dx%d@%d : %d %d %d\n",
+	printk("%dx%d@%d : %d %d %d\n",
 		drm_mode->hdisplay, drm_mode->vdisplay, drm_mode->vrefresh,
 		topology->num_lm, topology->num_enc, topology->num_intf);
 
@@ -5742,6 +5900,7 @@
 	struct dsi_display *display;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!bridge || !bridge->encoder) {
 		SDE_ERROR("invalid argument\n");
 		return NULL;
@@ -5784,6 +5943,7 @@
 	struct dsi_display_ext_bridge *ext_bridge;
 	struct drm_display_mode tmp;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	ext_bridge = dsi_display_ext_get_bridge(bridge);
 	if (!ext_bridge)
 		return MODE_ERROR;
@@ -5818,6 +5978,7 @@
 	struct dsi_display_ext_bridge *ext_bridge;
 	struct drm_display_mode tmp;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	ext_bridge = dsi_display_ext_get_bridge(bridge);
 	if (!ext_bridge)
 		return;
@@ -5834,11 +5995,12 @@
 	struct dsi_panel *panel;
 
 	if (!host || !dsi || !display->panel) {
-		DSI_ERR("Invalid param\n");
+		printk("Invalid param\n");
 		return -EINVAL;
 	}
 
-	DSI_DEBUG("DSI[%s]: channel=%d, lanes=%d, format=%d, mode_flags=%lx\n",
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	printk("DSI[%s]: channel=%d, lanes=%d, format=%d, mode_flags=%lx\n",
 		dsi->name, dsi->channel, dsi->lanes,
 		dsi->format, dsi->mode_flags);
 
@@ -5896,7 +6058,7 @@
 			dsi->mode_flags & MIPI_DSI_MODE_VIDEO_EOF_BLLP;
 	} else {
 		panel->panel_mode = DSI_OP_CMD_MODE;
-		DSI_ERR("command mode not supported by ext bridge\n");
+		printk("command mode not supported by ext bridge\n");
 		return -ENOTSUPP;
 	}
 
@@ -5932,6 +6094,7 @@
 	struct drm_bridge *prev_bridge;
 	int rc = 0, i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !encoder || !connector)
 		return -EINVAL;
 
@@ -5954,7 +6117,7 @@
 		ext_bridge = of_drm_find_bridge(ext_bridge_info->node_of);
 		if (IS_ERR_OR_NULL(ext_bridge)) {
 			rc = PTR_ERR(ext_bridge);
-			DSI_ERR("failed to find ext bridge\n");
+			printk("failed to find ext bridge\n");
 			goto error;
 		}
 
@@ -5976,7 +6139,7 @@
 
 		rc = drm_bridge_attach(encoder, ext_bridge, prev_bridge);
 		if (rc) {
-			DSI_ERR("[%s] ext brige attach failed, %d\n",
+			printk("[%s] ext brige attach failed, %d\n",
 				display->name, rc);
 			goto error;
 		}
@@ -6047,21 +6210,22 @@
 	struct dsi_host_common_cfg *host;
 	int i, rc;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!info || !disp) {
-		DSI_ERR("invalid params\n");
+		printk("invalid params\n");
 		return -EINVAL;
 	}
 
 	display = disp;
 	if (!display->panel) {
-		DSI_ERR("invalid display panel\n");
+		printk("invalid display panel\n");
 		return -EINVAL;
 	}
 
 	mutex_lock(&display->display_lock);
 	rc = dsi_panel_get_phy_props(display->panel, &phy_props);
 	if (rc) {
-		DSI_ERR("[%s] failed to get panel phy props, rc=%d\n",
+		printk("[%s] failed to get panel phy props, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -6103,7 +6267,7 @@
 			display->sw_te_using_wd;
 		break;
 	default:
-		DSI_ERR("unknwown dsi panel mode %d\n",
+		printk("unknwown dsi panel mode %d\n",
 				display->panel->panel_mode);
 		break;
 	}
@@ -6125,11 +6289,12 @@
 			u32 *count)
 {
 	if (!display || !display->panel) {
-		DSI_ERR("invalid display:%d panel:%d\n", display != NULL,
+		printk("invalid display:%d panel:%d\n", display != NULL,
 			display ? display->panel != NULL : 0);
 		return -EINVAL;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	mutex_lock(&display->display_lock);
 	*count = display->panel->num_display_modes;
 	mutex_unlock(&display->display_lock);
@@ -6205,6 +6370,7 @@
 	struct dsi_host_common_cfg *cfg;
 	int i, j, total_modes, bpp, lanes = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !mode_idx)
 		return;
 
@@ -6253,7 +6419,7 @@
 			dst = &display->modes[*mode_idx];
 
 			if (!src || !dst) {
-				DSI_ERR("invalid mode index\n");
+				printk("invalid mode index\n");
 				return;
 			}
 			memcpy(dst, src, sizeof(struct dsi_display_mode));
@@ -6289,8 +6455,9 @@
 	struct dsi_dyn_clk_caps *dyn_clk_caps;
 	int i, start, end, rc = -EINVAL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !out_modes) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -6313,7 +6480,7 @@
 
 	rc = dsi_panel_get_dfps_caps(display->panel, &dfps_caps);
 	if (rc) {
-		DSI_ERR("[%s] failed to get dfps caps from panel\n",
+		printk("[%s] failed to get dfps caps from panel\n",
 				display->name);
 		goto error;
 	}
@@ -6338,7 +6505,7 @@
 						&display_mode,
 						topology_override);
 		if (rc) {
-			DSI_ERR("[%s] failed to get mode idx %d from panel\n",
+			printk("[%s] failed to get mode idx %d from panel\n",
 				   display->name, mode_idx);
 			goto error;
 		}
@@ -6387,7 +6554,7 @@
 			u32 curr_refresh_rate;
 
 			if (!sub_mode) {
-				DSI_ERR("invalid mode data\n");
+				printk("invalid mode data\n");
 				rc = -EFAULT;
 				goto error;
 			}
@@ -6421,6 +6588,7 @@
 		kfree(display->modes);
 
 	mutex_unlock(&display->display_lock);
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -6433,6 +6601,7 @@
 	struct dsi_display *display = (struct dsi_display *)dsi_display;
 	struct dsi_host_common_cfg *host;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->panel)
 		return -EINVAL;
 
@@ -6441,7 +6610,7 @@
 	count = display->panel->num_display_modes;
 	if (!count && display->ext_conn) {
 		mutex_unlock(&display->display_lock);
-		DSI_DEBUG("external bridge did not have timing node\n");
+		printk("external bridge did not have timing node\n");
 		return -EPERM;
 	}
 
@@ -6454,7 +6623,7 @@
 
 	if (!refresh_rate) {
 		mutex_unlock(&display->display_lock);
-		DSI_ERR("Null Refresh Rate\n");
+		printk("Null Refresh Rate\n");
 		return -EINVAL;
 	}
 
@@ -6487,6 +6656,7 @@
 
 	*num_lm = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	mutex_lock(&display->display_lock);
 	count = display->panel->num_display_modes;
 	mutex_unlock(&display->display_lock);
@@ -6517,6 +6687,7 @@
 	u32 count, i;
 	int rc;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !out_mode)
 		return -EINVAL;
 
@@ -6551,7 +6722,7 @@
 	mutex_unlock(&display->display_lock);
 
 	if (!*out_mode) {
-		DSI_ERR("[%s] failed to find mode for v_active %u h_active %u fps %u pclk %u\n",
+		printk("[%s] failed to find mode for v_active %u h_active %u fps %u pclk %u\n",
 				display->name, cmp->timing.v_active,
 				cmp->timing.h_active, cmp->timing.refresh_rate,
 				cmp->pixel_clk_khz);
@@ -6596,12 +6767,12 @@
 	struct dsi_dyn_clk_caps *dyn_clk_caps;
 
 	if (!display || !adj_mode) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!display->panel || !display->panel->cur_mode) {
-		DSI_DEBUG("Current panel mode not set\n");
+		printk("Current panel mode not set\n");
 		return rc;
 	}
 
@@ -6615,7 +6786,7 @@
 			dsi_panel_get_dfps_caps(display->panel, &dfps_caps);
 			if (dfps_caps.dfps_support ||
 				dyn_clk_caps->maintain_const_fps) {
-				DSI_DEBUG("Mode switch is seamless variable refresh\n");
+				printk("Mode switch is seamless variable refresh\n");
 				adj_mode->dsi_mode_flags |= DSI_MODE_FLAG_VRR;
 				SDE_EVT32(SDE_EVTLOG_FUNC_CASE1,
 					cur_mode->timing.refresh_rate,
@@ -6630,11 +6801,11 @@
 		/* dynamic clk change use case */
 		if (cur_mode->pixel_clk_khz != adj_mode->pixel_clk_khz) {
 			if (dyn_clk_caps->dyn_clk_support) {
-				DSI_DEBUG("dynamic clk change detected\n");
+				printk("dynamic clk change detected\n");
 				if ((adj_mode->dsi_mode_flags &
 					DSI_MODE_FLAG_VRR) &&
 					(!dyn_clk_caps->maintain_const_fps)) {
-					DSI_ERR("dfps and dyn clk not supported in same commit\n");
+					printk("dfps and dyn clk not supported in same commit\n");
 					rc = -ENOTSUPP;
 					goto error;
 				}
@@ -6662,8 +6833,9 @@
 	struct dsi_display_ctrl *ctrl;
 	struct dsi_display_mode adj_mode;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !mode) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -6674,7 +6846,7 @@
 
 	rc = dsi_panel_validate_mode(display->panel, &adj_mode);
 	if (rc) {
-		DSI_ERR("[%s] panel mode validation failed, rc=%d\n",
+		printk("[%s] panel mode validation failed, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -6683,14 +6855,14 @@
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_validate_timing(ctrl->ctrl, &adj_mode.timing);
 		if (rc) {
-			DSI_ERR("[%s] ctrl mode validation failed, rc=%d\n",
+			printk("[%s] ctrl mode validation failed, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
 
 		rc = dsi_phy_validate_mode(ctrl->phy, &adj_mode.timing);
 		if (rc) {
-			DSI_ERR("[%s] phy mode validation failed, rc=%d\n",
+			printk("[%s] phy mode validation failed, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
@@ -6700,7 +6872,7 @@
 			(mode->dsi_mode_flags & DSI_MODE_FLAG_SEAMLESS)) {
 		rc = dsi_display_validate_mode_seamless(display, mode);
 		if (rc) {
-			DSI_ERR("[%s] seamless not possible rc=%d\n",
+			printk("[%s] seamless not possible rc=%d\n",
 				display->name, rc);
 			goto error;
 		}
@@ -6719,8 +6891,9 @@
 	struct dsi_display_mode adj_mode;
 	struct dsi_mode_info timing;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !mode || !display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -6745,13 +6918,13 @@
 
 	rc = dsi_display_validate_mode_set(display, &adj_mode, flags);
 	if (rc) {
-		DSI_ERR("[%s] mode cannot be set\n", display->name);
+		printk("[%s] mode cannot be set\n", display->name);
 		goto error;
 	}
 
 	rc = dsi_display_set_mode_sub(display, &adj_mode, flags);
 	if (rc) {
-		DSI_ERR("[%s] failed to set mode\n", display->name);
+		printk("[%s] failed to set mode\n", display->name);
 		goto error;
 	}
 
@@ -6773,8 +6946,9 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -6782,7 +6956,7 @@
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_set_tpg_state(ctrl->ctrl, enable);
 		if (rc) {
-			DSI_ERR("[%s] failed to set tpg state for host_%d\n",
+			printk("[%s] failed to set tpg state for host_%d\n",
 			       display->name, i);
 			goto error;
 		}
@@ -6797,24 +6971,25 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
 
 	rc = dsi_display_ctrl_update(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to update DSI controller, rc=%d\n",
+		printk("[%s] failed to update DSI controller, rc=%d\n",
 			   display->name, rc);
 		goto error_ctrl_clk_off;
 	}
 
 	rc = dsi_display_set_clk_src(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to set DSI link clock source, rc=%d\n",
+		printk("[%s] failed to set DSI link clock source, rc=%d\n",
 			display->name, rc);
 		goto error_ctrl_deinit;
 	}
@@ -6822,7 +6997,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_LINK_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI link clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI link clocks, rc=%d\n",
 			   display->name, rc);
 		goto error_ctrl_deinit;
 	}
@@ -6861,7 +7036,7 @@
 	display = container_of(work, struct dsi_display, fifo_underflow_work);
 	if (!display || !display->panel ||
 	    atomic_read(&display->panel->esd_recovery_pending)) {
-		DSI_DEBUG("Invalid recovery use case\n");
+		printk("Invalid recovery use case\n");
 		return;
 	}
 
@@ -6872,7 +7047,7 @@
 		return;
 	}
 
-	DSI_DEBUG("handle DSI FIFO underflow error\n");
+	printk("handle DSI FIFO underflow error\n");
 
 	dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_ON);
@@ -6900,7 +7075,7 @@
 	if (!display || !display->panel ||
 	    (display->panel->panel_mode != DSI_OP_VIDEO_MODE) ||
 	    atomic_read(&display->panel->esd_recovery_pending)) {
-		DSI_DEBUG("Invalid recovery use case\n");
+		printk("Invalid recovery use case\n");
 		return;
 	}
 
@@ -6911,7 +7086,7 @@
 		return;
 	}
 
-	DSI_DEBUG("handle DSI FIFO overflow error\n");
+	printk("handle DSI FIFO overflow error\n");
 	dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_ON);
 
@@ -6939,7 +7114,7 @@
 		rc = cb_func(data, SDE_CONN_EVENT_VID_FIFO_OVERFLOW,
 				display->clk_master_idx, 0, 0, 0, 0);
 		if (rc < 0) {
-			DSI_DEBUG("sde callback failed\n");
+			printk("sde callback failed\n");
 			goto end;
 		}
 	}
@@ -6977,7 +7152,7 @@
 	if (!display || !display->panel ||
 	    (display->panel->panel_mode != DSI_OP_VIDEO_MODE) ||
 	    atomic_read(&display->panel->esd_recovery_pending)) {
-		DSI_DEBUG("Invalid recovery use case\n");
+		printk("Invalid recovery use case\n");
 		return;
 	}
 
@@ -6988,7 +7163,7 @@
 		return;
 	}
 
-	DSI_DEBUG("handle DSI LP RX Timeout error\n");
+	printk("handle DSI LP RX Timeout error\n");
 
 	dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_ON);
@@ -7016,7 +7191,7 @@
 		rc = cb_func(data, SDE_CONN_EVENT_VID_FIFO_OVERFLOW,
 				display->clk_master_idx, 0, 0, 0, 0);
 		if (rc < 0) {
-			DSI_DEBUG("Target is in suspend/shutdown\n");
+			printk("Target is in suspend/shutdown\n");
 			goto end;
 		}
 	}
@@ -7077,7 +7252,7 @@
 
 	display->err_workq = create_singlethread_workqueue("dsi_err_workq");
 	if (!display->err_workq) {
-		DSI_ERR("failed to create dsi workq!\n");
+		printk("failed to create dsi workq!\n");
 		return;
 	}
 
@@ -7124,13 +7299,14 @@
 	int rc = 0;
 	struct dsi_display_mode *mode;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!display->panel->cur_mode) {
-		DSI_ERR("no valid mode set for the display\n");
+		printk("no valid mode set for the display\n");
 		return -EINVAL;
 	}
 
@@ -7147,7 +7323,7 @@
 	if (mode->dsi_mode_flags & DSI_MODE_FLAG_DMS) {
 		if (display->is_cont_splash_enabled &&
 		    display->config.panel_mode == DSI_OP_VIDEO_MODE) {
-			DSI_ERR("DMS not supported on first frame\n");
+			printk("DMS not supported on first frame\n");
 			rc = -EINVAL;
 			goto error;
 		}
@@ -7156,7 +7332,7 @@
 			/* update dsi ctrl for new mode */
 			rc = dsi_display_pre_switch(display);
 			if (rc)
-				DSI_ERR("[%s] panel pre-switch failed, rc=%d\n",
+				printk("[%s] panel pre-switch failed, rc=%d\n",
 					display->name, rc);
 			goto error;
 		}
@@ -7171,7 +7347,7 @@
 		 */
 		rc = dsi_panel_pre_prepare(display->panel);
 		if (rc) {
-			DSI_ERR("[%s] panel pre-prepare failed, rc=%d\n",
+			printk("[%s] panel pre-prepare failed, rc=%d\n",
 					display->name, rc);
 			goto error;
 		}
@@ -7180,7 +7356,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto error_panel_post_unprep;
 	}
@@ -7195,14 +7371,14 @@
 	if (!display->panel->ulps_suspend_enabled || !display->ulps_enabled) {
 		rc = dsi_display_phy_sw_reset(display);
 		if (rc) {
-			DSI_ERR("[%s] failed to reset phy, rc=%d\n",
+			printk("[%s] failed to reset phy, rc=%d\n",
 				display->name, rc);
 			goto error_ctrl_clk_off;
 		}
 
 		rc = dsi_display_phy_enable(display);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable DSI PHY, rc=%d\n",
+			printk("[%s] failed to enable DSI PHY, rc=%d\n",
 			       display->name, rc);
 			goto error_ctrl_clk_off;
 		}
@@ -7210,14 +7386,14 @@
 
 	rc = dsi_display_set_clk_src(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to set DSI link clock source, rc=%d\n",
+		printk("[%s] failed to set DSI link clock source, rc=%d\n",
 			display->name, rc);
 		goto error_phy_disable;
 	}
 
 	rc = dsi_display_ctrl_init(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to setup DSI controller, rc=%d\n",
+		printk("[%s] failed to setup DSI controller, rc=%d\n",
 		       display->name, rc);
 		goto error_phy_disable;
 	}
@@ -7226,7 +7402,7 @@
 
 	rc = dsi_display_ctrl_host_enable(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI host, rc=%d\n",
+		printk("[%s] failed to enable DSI host, rc=%d\n",
 		       display->name, rc);
 		goto error_ctrl_deinit;
 	}
@@ -7234,7 +7410,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_LINK_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI link clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI link clocks, rc=%d\n",
 		       display->name, rc);
 		goto error_host_engine_off;
 	}
@@ -7247,7 +7423,7 @@
 		 */
 		rc = dsi_display_soft_reset(display);
 		if (rc) {
-			DSI_ERR("[%s] failed soft reset, rc=%d\n",
+			printk("[%s] failed soft reset, rc=%d\n",
 					display->name, rc);
 			goto error_ctrl_link_off;
 		}
@@ -7255,7 +7431,7 @@
 		if (!(mode->dsi_mode_flags & DSI_MODE_FLAG_POMS)) {
 			rc = dsi_panel_prepare(display->panel);
 			if (rc) {
-				DSI_ERR("[%s] panel prepare failed, rc=%d\n",
+				printk("[%s] panel prepare failed, rc=%d\n",
 						display->name, rc);
 				goto error_ctrl_link_off;
 			}
@@ -7280,6 +7456,7 @@
 error:
 	mutex_unlock(&display->display_lock);
 	SDE_EVT32(SDE_EVTLOG_FUNC_EXIT);
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -7294,13 +7471,14 @@
 	struct dsi_rect req_roi = { 0 };
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	cur_mode = display->panel->cur_mode;
 	if (!cur_mode)
 		return 0;
 
 	roi_caps = &cur_mode->priv_info->roi_caps;
 	if (req_rois->num_rects > roi_caps->num_roi) {
-		DSI_ERR("request for %d rois greater than max %d\n",
+		printk("request for %d rois greater than max %d\n",
 				req_rois->num_rects,
 				roi_caps->num_roi);
 		rc = -EINVAL;
@@ -7327,7 +7505,7 @@
 	/* adjust the ctrl origin to be top left within the ctrl */
 	out_roi->x = out_roi->x - bounds->x;
 
-	DSI_DEBUG("ctrl%d:%d: req (%d,%d,%d,%d) bnd (%d,%d,%d,%d) out (%d,%d,%d,%d)\n",
+	printk("ctrl%d:%d: req (%d,%d,%d,%d) bnd (%d,%d,%d,%d) out (%d,%d,%d,%d)\n",
 			ctrl->dsi_ctrl_idx, ctrl->ctrl->cell_index,
 			req_roi.x, req_roi.y, req_roi.w, req_roi.h,
 			bounds->x, bounds->y, bounds->w, bounds->h,
@@ -7342,10 +7520,11 @@
 	int rc = 0;
 
 	if (!display->panel->qsync_min_fps) {
-		DSI_ERR("%s:ERROR: qsync set, but no fps\n", __func__);
+		printk("%s:ERROR: qsync set, but no fps\n", __func__);
 		return 0;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	mutex_lock(&display->display_lock);
 
 	display_for_each_ctrl(i, display) {
@@ -7353,14 +7532,14 @@
 			/* send the commands to enable qsync */
 			rc = dsi_panel_send_qsync_on_dcs(display->panel, i);
 			if (rc) {
-				DSI_ERR("fail qsync ON cmds rc:%d\n", rc);
+				printk("fail qsync ON cmds rc:%d\n", rc);
 				goto exit;
 			}
 		} else {
 			/* send the commands to enable qsync */
 			rc = dsi_panel_send_qsync_off_dcs(display->panel, i);
 			if (rc) {
-				DSI_ERR("fail qsync OFF cmds rc:%d\n", rc);
+				printk("fail qsync OFF cmds rc:%d\n", rc);
 				goto exit;
 			}
 		}
@@ -7382,6 +7561,7 @@
 	int rc = 0;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !rois || !display->panel)
 		return -EINVAL;
 
@@ -7400,13 +7580,13 @@
 
 		rc = dsi_display_calc_ctrl_roi(display, ctrl, rois, &ctrl_roi);
 		if (rc) {
-			DSI_ERR("dsi_display_calc_ctrl_roi failed rc %d\n", rc);
+			printk("dsi_display_calc_ctrl_roi failed rc %d\n", rc);
 			return rc;
 		}
 
 		rc = dsi_ctrl_set_roi(ctrl->ctrl, &ctrl_roi, &changed);
 		if (rc) {
-			DSI_ERR("dsi_ctrl_set_roi failed rc %d\n", rc);
+			printk("dsi_ctrl_set_roi failed rc %d\n", rc);
 			return rc;
 		}
 
@@ -7416,14 +7596,14 @@
 		/* send the new roi to the panel via dcs commands */
 		rc = dsi_panel_send_roi_dcs(display->panel, i, &ctrl_roi);
 		if (rc) {
-			DSI_ERR("dsi_panel_set_roi failed rc %d\n", rc);
+			printk("dsi_panel_set_roi failed rc %d\n", rc);
 			return rc;
 		}
 
 		/* re-program the ctrl with the timing based on the new roi */
 		rc = dsi_ctrl_timing_setup(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("dsi_ctrl_setup failed rc %d\n", rc);
+			printk("dsi_ctrl_setup failed rc %d\n", rc);
 			return rc;
 		}
 	}
@@ -7438,6 +7618,7 @@
 	int rc = 0;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* check and setup MISR */
 	if (display->misr_enable)
 		_dsi_display_setup_misr(display);
@@ -7486,13 +7667,14 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!display->panel->cur_mode) {
-		DSI_ERR("no valid mode set for the display\n");
+		printk("no valid mode set for the display\n");
 		return -EINVAL;
 	}
 
@@ -7502,19 +7684,19 @@
 	if (display->config.panel_mode == DSI_OP_VIDEO_MODE) {
 		rc = dsi_display_vid_engine_enable(display);
 		if (rc) {
-			DSI_ERR("[%s]failed to enable DSI video engine, rc=%d\n",
+			printk("[%s]failed to enable DSI video engine, rc=%d\n",
 			       display->name, rc);
 			goto error_out;
 		}
 	} else if (display->config.panel_mode == DSI_OP_CMD_MODE) {
 		rc = dsi_display_cmd_engine_enable(display);
 		if (rc) {
-			DSI_ERR("[%s]failed to enable DSI cmd engine, rc=%d\n",
+			printk("[%s]failed to enable DSI cmd engine, rc=%d\n",
 			       display->name, rc);
 			goto error_out;
 		}
 	} else {
-		DSI_ERR("[%s] Invalid configuration\n", display->name);
+		printk("[%s] Invalid configuration\n", display->name);
 		rc = -EINVAL;
 	}
 
@@ -7550,13 +7732,14 @@
 	int rc = 0;
 	struct dsi_display_mode *mode;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!display->panel->cur_mode) {
-		DSI_ERR("no valid mode set for the display\n");
+		printk("no valid mode set for the display\n");
 		return -EINVAL;
 	}
 	SDE_EVT32(SDE_EVTLOG_FUNC_ENTRY);
@@ -7570,13 +7753,13 @@
 
 		rc = dsi_display_splash_res_cleanup(display);
 		if (rc) {
-			DSI_ERR("Continuous splash res cleanup failed, rc=%d\n",
+			printk("Continuous splash res cleanup failed, rc=%d\n",
 				rc);
 			return -EINVAL;
 		}
 
 		display->panel->panel_initialized = true;
-		DSI_DEBUG("cont splash enabled, display enable not required\n");
+		printk("cont splash enabled, display enable not required\n");
 		return 0;
 	}
 
@@ -7587,7 +7770,7 @@
 	if (mode->dsi_mode_flags & DSI_MODE_FLAG_DMS) {
 		rc = dsi_panel_post_switch(display->panel);
 		if (rc) {
-			DSI_ERR("[%s] failed to switch DSI panel mode, rc=%d\n",
+			printk("[%s] failed to switch DSI panel mode, rc=%d\n",
 				   display->name, rc);
 			goto error;
 		}
@@ -7595,7 +7778,7 @@
 			DSI_MODE_FLAG_POMS)){
 		rc = dsi_panel_enable(display->panel);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable DSI panel, rc=%d\n",
+			printk("[%s] failed to enable DSI panel, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
@@ -7607,7 +7790,7 @@
 		mode->priv_info->dsc.pic_width *= display->ctrl_count;
 		rc = dsi_panel_update_pps(display->panel);
 		if (rc) {
-			DSI_ERR("[%s] panel pps cmd update failed, rc=%d\n",
+			printk("[%s] panel pps cmd update failed, rc=%d\n",
 				display->name, rc);
 			goto error;
 		}
@@ -7616,30 +7799,30 @@
 	if (mode->dsi_mode_flags & DSI_MODE_FLAG_DMS) {
 		rc = dsi_panel_switch(display->panel);
 		if (rc)
-			DSI_ERR("[%s] failed to switch DSI panel mode, rc=%d\n",
+			printk("[%s] failed to switch DSI panel mode, rc=%d\n",
 				   display->name, rc);
 
 		goto error;
 	}
 
 	if (display->config.panel_mode == DSI_OP_VIDEO_MODE) {
-		DSI_DEBUG("%s:enable video timing eng\n", __func__);
+		printk("%s:enable video timing eng\n", __func__);
 		rc = dsi_display_vid_engine_enable(display);
 		if (rc) {
-			DSI_ERR("[%s]failed to enable DSI video engine, rc=%d\n",
+			printk("[%s]failed to enable DSI video engine, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_panel;
 		}
 	} else if (display->config.panel_mode == DSI_OP_CMD_MODE) {
-		DSI_DEBUG("%s:enable command timing eng\n", __func__);
+		printk("%s:enable command timing eng\n", __func__);
 		rc = dsi_display_cmd_engine_enable(display);
 		if (rc) {
-			DSI_ERR("[%s]failed to enable DSI cmd engine, rc=%d\n",
+			printk("[%s]failed to enable DSI cmd engine, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_panel;
 		}
 	} else {
-		DSI_ERR("[%s] Invalid configuration\n", display->name);
+		printk("[%s] Invalid configuration\n", display->name);
 		rc = -EINVAL;
 		goto error_disable_panel;
 	}
@@ -7651,6 +7834,7 @@
 error:
 	mutex_unlock(&display->display_lock);
 	SDE_EVT32(SDE_EVTLOG_FUNC_EXIT);
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	return rc;
 }
 
@@ -7658,8 +7842,10 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -7674,7 +7860,7 @@
 	} else {
 		rc = dsi_panel_post_enable(display->panel);
 		if (rc)
-			DSI_ERR("[%s] panel post-enable failed, rc=%d\n",
+			printk("[%s] panel post-enable failed, rc=%d\n",
 				display->name, rc);
 	}
 
@@ -7691,8 +7877,9 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -7714,14 +7901,14 @@
 			rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 					DSI_ALL_CLKS, DSI_CLK_ON);
 			if (rc) {
-				DSI_ERR("[%s]failed to enable all clocks,rc=%d",
+				printk("[%s]failed to enable all clocks,rc=%d",
 						display->name, rc);
 				goto exit;
 			}
 
 			rc = dsi_display_cmd_engine_enable(display);
 			if (rc) {
-				DSI_ERR("[%s]failed to enable cmd engine,rc=%d",
+				printk("[%s]failed to enable cmd engine,rc=%d",
 						display->name, rc);
 				goto error_disable_clks;
 			}
@@ -7731,7 +7918,7 @@
 	} else {
 		rc = dsi_panel_pre_disable(display->panel);
 		if (rc)
-			DSI_ERR("[%s] panel pre-disable failed, rc=%d\n",
+			printk("[%s] panel pre-disable failed, rc=%d\n",
 				display->name, rc);
 	}
 	goto exit;
@@ -7740,7 +7927,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_OFF);
 	if (rc)
-		DSI_ERR("[%s] failed to disable all DSI clocks, rc=%d\n",
+		printk("[%s] failed to disable all DSI clocks, rc=%d\n",
 		       display->name, rc);
 
 exit:
@@ -7752,8 +7939,9 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -7762,28 +7950,28 @@
 
 	rc = dsi_display_wake_up(display);
 	if (rc)
-		DSI_ERR("[%s] display wake up failed, rc=%d\n",
+		printk("[%s] display wake up failed, rc=%d\n",
 		       display->name, rc);
 
 	if (display->config.panel_mode == DSI_OP_VIDEO_MODE) {
 		rc = dsi_display_vid_engine_disable(display);
 		if (rc)
-			DSI_ERR("[%s]failed to disable DSI vid engine, rc=%d\n",
+			printk("[%s]failed to disable DSI vid engine, rc=%d\n",
 			       display->name, rc);
 	} else if (display->config.panel_mode == DSI_OP_CMD_MODE) {
 		rc = dsi_display_cmd_engine_disable(display);
 		if (rc)
-			DSI_ERR("[%s]failed to disable DSI cmd engine, rc=%d\n",
+			printk("[%s]failed to disable DSI cmd engine, rc=%d\n",
 			       display->name, rc);
 	} else {
-		DSI_ERR("[%s] Invalid configuration\n", display->name);
+		printk("[%s] Invalid configuration\n", display->name);
 		rc = -EINVAL;
 	}
 
 	if (!display->poms_pending) {
 		rc = dsi_panel_disable(display->panel);
 		if (rc)
-			DSI_ERR("[%s] failed to disable DSI panel, rc=%d\n",
+			printk("[%s] failed to disable DSI panel, rc=%d\n",
 				display->name, rc);
 	}
 	mutex_unlock(&display->display_lock);
@@ -7796,7 +7984,7 @@
 	struct dsi_display *display;
 
 	if (pps_cmd == NULL || disp == NULL) {
-		DSI_ERR("Invalid parameter\n");
+		printk("Invalid parameter\n");
 		return -EINVAL;
 	}
 
@@ -7813,8 +8001,9 @@
 	int rc = 0, i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -7823,12 +8012,12 @@
 
 	rc = dsi_display_wake_up(display);
 	if (rc)
-		DSI_ERR("[%s] display wake up failed, rc=%d\n",
+		printk("[%s] display wake up failed, rc=%d\n",
 		       display->name, rc);
 	if (!display->poms_pending) {
 		rc = dsi_panel_unprepare(display->panel);
 		if (rc)
-			DSI_ERR("[%s] panel unprepare failed, rc=%d\n",
+			printk("[%s] panel unprepare failed, rc=%d\n",
 			       display->name, rc);
 	}
 
@@ -7851,31 +8040,31 @@
 
 	rc = dsi_display_ctrl_host_disable(display);
 	if (rc)
-		DSI_ERR("[%s] failed to disable DSI host, rc=%d\n",
+		printk("[%s] failed to disable DSI host, rc=%d\n",
 		       display->name, rc);
 
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_LINK_CLK, DSI_CLK_OFF);
 	if (rc)
-		DSI_ERR("[%s] failed to disable Link clocks, rc=%d\n",
+		printk("[%s] failed to disable Link clocks, rc=%d\n",
 		       display->name, rc);
 
 	rc = dsi_display_ctrl_deinit(display);
 	if (rc)
-		DSI_ERR("[%s] failed to deinit controller, rc=%d\n",
+		printk("[%s] failed to deinit controller, rc=%d\n",
 		       display->name, rc);
 
 	if (!display->panel->ulps_suspend_enabled) {
 		rc = dsi_display_phy_disable(display);
 		if (rc)
-			DSI_ERR("[%s] failed to disable DSI PHY, rc=%d\n",
+			printk("[%s] failed to disable DSI PHY, rc=%d\n",
 			       display->name, rc);
 	}
 
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_OFF);
 	if (rc)
-		DSI_ERR("[%s] failed to disable DSI clocks, rc=%d\n",
+		printk("[%s] failed to disable DSI clocks, rc=%d\n",
 		       display->name, rc);
 
 	/* destrory dsi isr set up */
@@ -7884,7 +8073,7 @@
 	if (!display->poms_pending) {
 		rc = dsi_panel_post_unprepare(display->panel);
 		if (rc)
-			DSI_ERR("[%s] panel post-unprepare failed, rc=%d\n",
+			printk("[%s] panel post-unprepare failed, rc=%d\n",
 			       display->name, rc);
 	}
 
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_display.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_display_test.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_display_test.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_drm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_drm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_hw.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_panel.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_panel.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_parser.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_parser.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_hw.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_hw_v2_0.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_hw_v3_0.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_hw_v4_0.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_timing_calc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_timing_calc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_timing_v2_0.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_timing_v3_0.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_timing_v4_0.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_pwr.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_pwr.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_atomic.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_drv.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_drv.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_fb.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_gem.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_gem.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_gem_prime.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_gem_vma.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_iommu.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_kms.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_mmu.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_notifier.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_prop.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_prop.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_smmu.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_ad4.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_color_processing.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_color_processing.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_connector.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_connector.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_core_irq.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_core_irq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_core_perf.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_core_perf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_crtc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_crtc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder_phys.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder_phys_cmd.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder_phys_vid.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder_phys_wb.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_fence.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_fence.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_formats.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_formats.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_ad4.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_blk.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_blk.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_catalog.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_catalog.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_catalog_format.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_cdm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_cdm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_proc_common_v4.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_proc_v4.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_proc_v4.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_processing.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_processing_v1_7.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_processing_v1_7.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_ctl.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_ctl.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_ds.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_ds.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_dsc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_dsc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_dspp.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_dspp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_interrupts.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_interrupts.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_intf.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_intf.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_lm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_lm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_mdss.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_pingpong.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_pingpong.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_qdss.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_qdss.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_reg_dma_v1.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_reg_dma_v1.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_reg_dma_v1_color_proc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_reg_dma_v1_color_proc.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_sspp.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_sspp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_top.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_top.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_uidle.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_uidle.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_util.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_util.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_vbif.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_vbif.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_wb.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_wb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hwio.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_irq.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_irq.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_kms.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_kms.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_kms_utils.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_plane.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_plane.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_reg_dma.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_reg_dma.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_rm.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_rm.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_trace.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_vbif.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_vbif.h
diff -ru --unidirectional-new-file /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde/sde_wb.c msm-4.19/techpack/display/msm/sde/sde_wb.c
--- /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde/sde_wb.c	2024-04-16 19:15:06.860039476 +0000
+++ msm-4.19/techpack/display/msm/sde/sde_wb.c	2024-04-20 18:36:20.830499291 +0000
@@ -35,6 +35,8 @@
 	const struct sde_format_extended *fmts = wb_dev->wb_cfg->format_list;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!fmts)
 		return false;
 
@@ -53,7 +55,8 @@
 {
 	enum drm_connector_status rc = connector_status_unknown;
 
-	SDE_DEBUG("\n");
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	printk("\n");
 
 	if (display)
 		rc = ((struct sde_wb_device *)display)->detect_status;
@@ -67,12 +70,13 @@
 	struct sde_wb_device *wb_dev;
 	int num_modes = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!connector || !display)
 		return 0;
 
 	wb_dev = display;
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 	if (wb_dev->count_modes && wb_dev->modes) {
@@ -110,6 +114,7 @@
 struct drm_framebuffer *
 sde_wb_connector_state_get_output_fb(struct drm_connector_state *state)
 {
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!state || !state->connector ||
 		(state->connector->connector_type !=
 				DRM_MODE_CONNECTOR_VIRTUAL)) {
@@ -117,7 +122,7 @@
 		return NULL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	return sde_connector_get_out_fb(state);
 }
@@ -125,6 +130,7 @@
 int sde_wb_connector_state_get_output_roi(struct drm_connector_state *state,
 		struct sde_rect *roi)
 {
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!state || !roi || !state->connector ||
 		(state->connector->connector_type !=
 				DRM_MODE_CONNECTOR_VIRTUAL)) {
@@ -132,7 +138,7 @@
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	roi->x = sde_connector_get_property(state, CONNECTOR_PROP_DST_X);
 	roi->y = sde_connector_get_property(state, CONNECTOR_PROP_DST_Y);
@@ -158,6 +164,7 @@
 	struct drm_mode_modeinfo *modeinfo = NULL;
 	int ret = 0;
 	int i;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev || !wb_dev->connector ||
 			(wb_dev->connector->connector_type !=
@@ -166,10 +173,10 @@
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	if (connected) {
-		SDE_DEBUG("connect\n");
+		printk("connect\n");
 
 		if (!count_modes || !modes) {
 			SDE_ERROR("invalid count_modes :%u and modes :%d\n",
@@ -236,7 +243,7 @@
 		wb_dev->modes = modeinfo;
 		wb_dev->detect_status = connector_status_connected;
 	} else {
-		SDE_DEBUG("disconnect\n");
+		printk("disconnect\n");
 
 		if (wb_dev->modes) {
 			wb_dev->count_modes = 0;
@@ -261,8 +268,9 @@
 	struct sde_wb_device *wb_dev = display;
 	struct drm_framebuffer *out_fb;
 	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	if (state && (property_index == CONNECTOR_PROP_OUT_FB)) {
 		const struct sde_format *sde_format;
@@ -297,6 +305,7 @@
 		struct msm_display_info *info, void *display)
 {
 	struct sde_wb_device *wb_dev = display;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!info || !wb_dev) {
 		pr_err("invalid params\n");
@@ -329,6 +338,7 @@
 	struct sde_wb_device *wb_dev = display;
 	u16 hdisplay;
 	int i;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!drm_mode || !mode_info || !avail_res ||
 			!avail_res->max_mixer_width || !display) {
@@ -360,6 +370,7 @@
 {
 	struct sde_wb_device *wb_dev = display;
 	const struct sde_format_extended *format_list;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!connector || !info || !display || !wb_dev->wb_cfg) {
 		SDE_ERROR("invalid params\n");
@@ -406,6 +417,7 @@
 		{SDE_DRM_FB_NON_SEC, "non_sec"},
 		{SDE_DRM_FB_SEC, "sec"},
 	};
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!connector || !display || !wb_dev->wb_cfg) {
 		SDE_ERROR("invalid params\n");
@@ -442,13 +454,14 @@
 struct drm_framebuffer *sde_wb_get_output_fb(struct sde_wb_device *wb_dev)
 {
 	struct drm_framebuffer *fb;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev || !wb_dev->connector) {
 		SDE_ERROR("invalid params\n");
 		return NULL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 	fb = sde_wb_connector_state_get_output_fb(wb_dev->connector->state);
@@ -465,8 +478,9 @@
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 	rc = sde_wb_connector_state_get_output_roi(
@@ -481,7 +495,7 @@
 	u32 count = 0;
 	struct sde_wb_device *wb_dev;
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&sde_wb_list_lock);
 	list_for_each_entry(wb_dev, &sde_wb_list, wb_list) {
@@ -496,8 +510,9 @@
 {
 	struct sde_wb_device *curr;
 	int i = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	if (!display_array || !max_display_count) {
 		if (!display_array)
@@ -534,8 +549,9 @@
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	flags = config->flags;
 	connector_id = config->connector_id;
@@ -585,14 +601,16 @@
 static int _sde_wb_dev_init(struct sde_wb_device *wb_dev)
 {
 	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev) {
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
+    printk("%s:%d, ACHEUL, out: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -603,13 +621,14 @@
 static int _sde_wb_dev_deinit(struct sde_wb_device *wb_dev)
 {
 	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev) {
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	return rc;
 }
@@ -624,6 +643,7 @@
 static int sde_wb_bind(struct device *dev, struct device *master, void *data)
 {
 	struct sde_wb_device *wb_dev;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!dev || !master) {
 		SDE_ERROR("invalid params\n");
@@ -636,7 +656,7 @@
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 	wb_dev->drm_dev = dev_get_drvdata(master);
@@ -655,6 +675,7 @@
 		struct device *master, void *data)
 {
 	struct sde_wb_device *wb_dev;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!dev) {
 		SDE_ERROR("invalid params\n");
@@ -667,7 +688,7 @@
 		return;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 	wb_dev->drm_dev = NULL;
@@ -687,13 +708,14 @@
 int sde_wb_drm_init(struct sde_wb_device *wb_dev, struct drm_encoder *encoder)
 {
 	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev || !wb_dev->drm_dev || !encoder) {
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 
@@ -716,13 +738,14 @@
 int sde_wb_drm_deinit(struct sde_wb_device *wb_dev)
 {
 	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev) {
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	return rc;
 }
@@ -735,23 +758,26 @@
 {
 	struct sde_wb_device *wb_dev;
 	int ret;
+    printk("%s:%d, ACHEUL, in", __FUNCTION__, __LINE__);
 
 	wb_dev = devm_kzalloc(&pdev->dev, sizeof(*wb_dev), GFP_KERNEL);
-	if (!wb_dev)
+	if (!wb_dev) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		return -ENOMEM;
+    }
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	ret = of_property_read_u32(pdev->dev.of_node, "cell-index",
 			&wb_dev->index);
 	if (ret) {
-		SDE_DEBUG("cell index not set, default to 0\n");
+		printk("cell index not set, default to 0\n");
 		wb_dev->index = 0;
 	}
 
 	wb_dev->name = of_get_property(pdev->dev.of_node, "label", NULL);
 	if (!wb_dev->name) {
-		SDE_DEBUG("label not set, default to unknown\n");
+		printk("label not set, default to unknown\n");
 		wb_dev->name = "unknown";
 	}
 
@@ -766,10 +792,13 @@
 
 	if (!_sde_wb_dev_init(wb_dev)) {
 		ret = component_add(&pdev->dev, &sde_wb_comp_ops);
-		if (ret)
+		if (ret) {
+            printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 			pr_err("component add failed\n");
+        }
 	}
 
+    printk("%s:%d, ACHEUL, out: %d", __FUNCTION__, __LINE__, ret);
 	return ret;
 }
 
@@ -781,12 +810,13 @@
 {
 	struct sde_wb_device *wb_dev;
 	struct sde_wb_device *curr, *next;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	wb_dev = platform_get_drvdata(pdev);
 	if (!wb_dev)
 		return 0;
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	(void)_sde_wb_dev_deinit(wb_dev);
 
@@ -825,11 +855,13 @@
 
 static int __init sde_wb_register(void)
 {
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	return platform_driver_register(&sde_wb_driver);
 }
 
 static void __exit sde_wb_unregister(void)
 {
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	platform_driver_unregister(&sde_wb_driver);
 }
 
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_wb.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_dbg.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_dbg.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_dbg_evtlog.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_edid_parser.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_edid_parser.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_hdcp.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_hdcp_1x.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_hdcp_2x.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_hdcp_2x.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_io_util.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_power_handle.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_power_handle.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_rsc.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_rsc_hw.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_rsc_hw.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_rsc_hw_v3.c
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_rsc_priv.h
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display: pll
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack/display: rotator
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack: stub
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/techpack: video
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: tools
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: usr
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: verity_dev_keys.x509
Only in /media/mnt/T7-1/daburk/devkit-1.1-FC/LINUX/android/kernel/msm-4.19/: virt
