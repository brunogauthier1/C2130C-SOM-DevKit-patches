Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel: Android.mk
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel: configs
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: Android.bp
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: AndroidKernel.mk
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: alpha
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: arc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: arm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: boot
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64/configs: cuttlefish_defconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64/configs: defconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64/configs: ranchu64_defconfig
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64/configs/vendor/kona_defconfig kernel/msm-4.19/arch/arm64/configs/vendor/kona_defconfig
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64/configs/vendor/kona_defconfig	2024-05-28 20:40:21.283272129 -0400
+++ kernel/msm-4.19/arch/arm64/configs/vendor/kona_defconfig	2024-05-29 22:10:12.825804877 -0400
@@ -90,12 +90,24 @@
 CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
 CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
 CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
-CONFIG_KPROBES=y
-CONFIG_PANIC_ON_REFCOUNT_ERROR=y
+CONFIG_KyPROBES=y
+## ACHEUL
+CONFIG_PANIC_ON_REFCOUNT_ERROR=n
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
 CONFIG_MODULE_FORCE_UNLOAD=y
 CONFIG_MODVERSIONS=y
+##############################
+## ACHEUL
+##############################
+CONFIG_INPUT=y
+CONFIG_VCNL4000=m
+CONFIG_VCNL3040=m
+CONFIG_INV_ICM42600=m
+CONFIG_INV_ICM42600_I2C=m
+CONFIG_SENSORS_AKM09911=m
+CONFIG_CH101_I2C=y
+##############################
 CONFIG_MODULE_SIG=y
 CONFIG_MODULE_SIG_FORCE=y
 CONFIG_MODULE_SIG_SHA512=y
@@ -742,8 +754,10 @@
 CONFIG_DEBUG_FORCE_WEAK_PER_CPU=y
 CONFIG_MAGIC_SYSRQ=y
 CONFIG_DEBUG_PAGEALLOC=y
-CONFIG_SLUB_DEBUG_PANIC_ON=y
-CONFIG_DEBUG_PANIC_ON_OOM=y
+# ACHEUL
+CONFIG_SLUB_DEBUG_PANIC_ON=n
+CONFIG_DEBUG_PANIC_ON_OOM=n
+
 CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT=y
 CONFIG_PAGE_POISONING=y
 CONFIG_PAGE_POISONING_ENABLE_DEFAULT=y
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64/configs/vendor: kona-perf_defconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64/configs/vendor: lito_defconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64/configs/vendor: lito-perf_defconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: crypto
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: include
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: Kconfig.debug
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: Kconfig.platforms
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: kernel
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: kvm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: lib
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: mm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: net
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch/arm64: xen
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: c6x
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: .gitignore
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: h8300
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: hexagon
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: ia64
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: m68k
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: microblaze
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: mips
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: nds32
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: nios2
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: openrisc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: parisc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: powerpc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: riscv
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: s390
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: sh
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: sparc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: um
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: unicore32
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: x86
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/arch: xtensa
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: block
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.aarch64
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.common
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.cuttlefish.aarch64
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.cuttlefish.x86_64
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.goldfish.arm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.goldfish.arm64
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.goldfish.mips
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.goldfish.mips64
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.goldfish.x86
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.goldfish.x86_64
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: build.config.x86_64
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: certs
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: .clang-format
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: .cocciconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: COPYING
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: CREDITS
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: crypto
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: Documentation
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: accessibility
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: acpi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: amba
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: android
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: ata
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: atm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: auxdisplay
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: base
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: bcma
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: block
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: bluetooth
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: bus
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: cdrom
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: char
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: clk
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: clocksource
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: connector
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: cpufreq
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: cpuidle
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: crypto
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: dax
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: dca
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: devfreq
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: dio
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: dma
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: dma-buf
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: edac
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: eisa
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: energy_model
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: esoc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: extcon
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: firewire
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: firmware
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: fmc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: fpga
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: fsi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: gnss
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: gpio
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: amd
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: arc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: arm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: armada
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: ast
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: ati_pcigart.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: atmel-hlcdc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: bochs
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: bridge
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: cirrus
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_agpsupport.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_atomic.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_atomic_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_auth.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_blend.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_bootsplash.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_bridge.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_bufs.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_cache.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_client.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_client_modeset.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_color_mgmt.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_connector.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_context.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_crtc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_crtc_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_crtc_helper_internal.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_crtc_internal.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_debugfs.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_debugfs_crc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dma.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dp_aux_dev.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dp_cec.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dp_dual_mode_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dp_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dp_mst_topology.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_drv.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_dumb_buffers.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_edid.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_edid_load.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_encoder.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_encoder_slave.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_fb_cma_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_fb_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_file.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_flip_work.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_fourcc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_framebuffer.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_gem.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_gem_cma_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_gem_framebuffer_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_global.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_hashtab.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_info.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_internal.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_ioc32.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_ioctl.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_irq.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_kms_helper_common.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_lease.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_legacy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_lock.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_memory.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_mipi_dsi.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_mm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_mode_config.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_mode_object.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_modes.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_modeset_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_modeset_lock.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_of.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_panel.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_panel_orientation_quirks.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_pci.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_plane.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_plane_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_prime.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/drm_print.c kernel/msm-4.19/drivers/gpu/drm/drm_print.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/drm_print.c	2024-05-28 20:42:50.512868667 -0400
+++ kernel/msm-4.19/drivers/gpu/drm/drm_print.c	2024-05-29 22:10:12.833804947 -0400
@@ -201,8 +201,11 @@
 	struct va_format vaf;
 	va_list args;
 
+// ACHEUL
+#if 0
 	if (!(drm_debug & category))
 		return;
+#endif // 0
 
 	va_start(args, format);
 	vaf.fmt = format;
@@ -224,8 +227,10 @@
 	struct va_format vaf;
 	va_list args;
 
+#if 0
 	if (!(drm_debug & category))
 		return;
+#endif // ACHEUL
 
 	va_start(args, format);
 	vaf.fmt = format;
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_probe_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_property.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_rect.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_scatter.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_scdc_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_simple_kms_helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_splash.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_syncobj.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_sysfs.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_trace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_trace_points.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_vblank.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_vma_manager.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_vm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: drm_writeback.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: etnaviv
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: exynos
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: fsl-dcu
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: gma500
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: hisilicon
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: i2c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: i810
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: i915
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: imx
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: lib
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: mediatek
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: meson
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: mga
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: mgag200
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: msm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: mxsfb
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: nouveau
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: displays
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: base.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: core.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dispc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dispc_coefs.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dispc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: display.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dpi.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss/dsi.c kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss/dsi.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss/dsi.c	2024-05-28 20:42:52.248887290 -0400
+++ kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss/dsi.c	2024-05-29 22:10:12.829804912 -0400
@@ -3828,9 +3828,13 @@
 		return -ENODEV;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	r = dsi_display_init_dispc(dsi);
-	if (r)
+	if (r){
+        printk("%s:%d, ACHEUL, FAILED", __FUNCTION__, __LINE__);
 		goto err_init_dispc;
+    }
 
 	if (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {
 		switch (dsi->pix_fmt) {
@@ -3847,6 +3851,7 @@
 			data_type = MIPI_DSI_PACKED_PIXEL_STREAM_16;
 			break;
 		default:
+            printk("%s:%d, ACHEUL, FAILED", __FUNCTION__, __LINE__);
 			r = -EINVAL;
 			goto err_pix_fmt;
 		}
@@ -3867,9 +3872,12 @@
 	}
 
 	r = dss_mgr_enable(&dsi->output);
-	if (r)
+	if (r){
+        printk("%s:%d, ACHEUL, FAILED", __FUNCTION__, __LINE__);
 		goto err_mgr_enable;
+    }
 
+    printk("%s:%d, ACHEUL, OK", __FUNCTION__, __LINE__);
 	return 0;
 
 err_mgr_enable:
@@ -3880,6 +3888,7 @@
 err_pix_fmt:
 	dsi_display_uninit_dispc(dsi);
 err_init_dispc:
+    printk("%s:%d, ACHEUL, out: %d", __FUNCTION__, __LINE__, r);
 	return r;
 }
 
@@ -5074,6 +5083,12 @@
 	int r, i;
 	struct device_node *ep;
 	struct omap_dsi_pin_config pin_cfg;
+    const char* compatible = NULL;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+    of_property_read_string(node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
 
 	ep = of_graph_get_endpoint_by_regs(node, 0, 0);
 	if (!ep)
@@ -5081,6 +5096,7 @@
 
 	prop = of_find_property(ep, "lanes", &len);
 	if (prop == NULL) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		dev_err(dsi->dev, "failed to find lane data\n");
 		r = -EINVAL;
 		goto err;
@@ -5091,12 +5107,14 @@
 	if (num_pins < 4 || num_pins % 2 != 0 ||
 		num_pins > dsi->num_lanes_supported * 2) {
 		dev_err(dsi->dev, "bad number of lanes\n");
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		r = -EINVAL;
 		goto err;
 	}
 
 	r = of_property_read_u32_array(ep, "lanes", lane_arr, num_pins);
 	if (r) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		dev_err(dsi->dev, "failed to read lane data\n");
 		goto err;
 	}
@@ -5107,12 +5125,14 @@
 
 	r = dsi_configure_pins(&dsi->output, &pin_cfg);
 	if (r) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		dev_err(dsi->dev, "failed to configure pins");
 		goto err;
 	}
 
 	of_node_put(ep);
 
+    printk("%s:%d, ACHEUL, OK", __FUNCTION__, __LINE__);
 	return 0;
 
 err:
@@ -5310,11 +5330,17 @@
 	struct dsi_data *dsi;
 	struct resource *dsi_mem;
 	struct resource *res;
+    const char* compatible = NULL;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
 	if (!dsi)
 		return -ENOMEM;
 
+    of_property_read_string(dev->of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
 	dsi->dss = dss;
 	dsi->dev = dev;
 	dev_set_drvdata(dev, dsi);
@@ -5467,6 +5493,7 @@
 							    &dsi);
 #endif
 
+    printk("%s:%d, ACHEUL, OK", __FUNCTION__, __LINE__);
 	return 0;
 
 err_probe_of:
@@ -5475,6 +5502,7 @@
 
 err_runtime_get:
 	pm_runtime_disable(dev);
+    printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, r);
 	return r;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dss.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dss.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: dss-of.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi4.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi4_cec.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi4_cec.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi4_core.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi4_core.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi5.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi5_core.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi5_core.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi_common.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi_phy.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi_pll.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: hdmi_wp.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: omapdss-boot-init.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: omapdss.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: output.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: pll.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: sdi.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: venc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm/dss: video-pll.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_connector.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_connector.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_crtc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_crtc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_debugfs.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_dmm_priv.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_dmm_tiler.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_dmm_tiler.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_drv.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_drv.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_encoder.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_encoder.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_fb.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_fbdev.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_fbdev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_fb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_gem.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_gem_dmabuf.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_gem.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_irq.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_irq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_plane.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: omap_plane.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: tcm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: tcm-sita.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: tcm-sita.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm/omapdrm: TODO
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: panel
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: pl111
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: qxl
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: r128
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: radeon
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: rcar-du
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: rockchip
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: savage
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: scheduler
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: selftests
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: shmobile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: sis
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: sti
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: stm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: sun4i
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: tdfx
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: tegra
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: tilcdc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: tinydrm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: ttm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: tve200
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: udl
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: v3d
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: vc4
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: vgem
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: via
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: virtio
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: vkms
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: vmwgfx
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: xen
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu/drm: zte
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu: host1x
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu: ipu-v3
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu: msm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/gpu: vga
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: hid
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: hsi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: hv
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: hwmon
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: hwspinlock
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: hwtracing
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: i2c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: i3c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: ide
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: idle
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: accel
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: adc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: afe
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: amplifiers
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: buffer
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: chemical
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: common
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: counter
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: dac
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: dummy
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: frequency
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: gyro
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: health
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: humidity
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: iio_core.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: iio_core_trigger.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis16400_buffer.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis16400_core.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis16400.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis16480.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis_buffer.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: adis_trigger.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: bmi160
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_accel.c kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_accel.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_accel.c	1969-12-31 19:00:00.000000000 -0500
+++ kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_accel.c	2024-05-29 22:10:12.845805052 -0400
@@ -0,0 +1,788 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/math64.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/kfifo_buf.h>
+
+#include "inv_icm42600.h"
+#include "inv_icm42600_temp.h"
+#include "inv_icm42600_buffer.h"
+#include "inv_icm42600_timestamp.h"
+
+#define INV_ICM42600_ACCEL_CHAN(_modifier, _index, _ext_info)		\
+	{								\
+		.type = IIO_ACCEL,					\
+		.modified = 1,						\
+		.channel2 = _modifier,					\
+		.info_mask_separate =					\
+			BIT(IIO_CHAN_INFO_RAW) |			\
+			BIT(IIO_CHAN_INFO_CALIBBIAS),			\
+		.info_mask_shared_by_type =				\
+			BIT(IIO_CHAN_INFO_SCALE),			\
+		.info_mask_shared_by_type_available =			\
+			BIT(IIO_CHAN_INFO_SCALE) |			\
+			BIT(IIO_CHAN_INFO_CALIBBIAS),			\
+		.info_mask_shared_by_all =				\
+			BIT(IIO_CHAN_INFO_SAMP_FREQ),			\
+		.info_mask_shared_by_all_available =			\
+			BIT(IIO_CHAN_INFO_SAMP_FREQ),			\
+		.scan_index = _index,					\
+		.scan_type = {						\
+			.sign = 's',					\
+			.realbits = 16,					\
+			.storagebits = 16,				\
+			.endianness = IIO_BE,				\
+		},							\
+		.ext_info = _ext_info,					\
+	}
+
+enum inv_icm42600_accel_scan {
+	INV_ICM42600_ACCEL_SCAN_X,
+	INV_ICM42600_ACCEL_SCAN_Y,
+	INV_ICM42600_ACCEL_SCAN_Z,
+	INV_ICM42600_ACCEL_SCAN_TEMP,
+	INV_ICM42600_ACCEL_SCAN_TIMESTAMP,
+};
+
+static const struct iio_chan_spec_ext_info inv_icm42600_accel_ext_infos[] = {
+	IIO_MOUNT_MATRIX(IIO_SHARED_BY_ALL, inv_icm42600_get_mount_matrix),
+	{},
+};
+
+static const struct iio_chan_spec inv_icm42600_accel_channels[] = {
+	INV_ICM42600_ACCEL_CHAN(IIO_MOD_X, INV_ICM42600_ACCEL_SCAN_X,
+				inv_icm42600_accel_ext_infos),
+	INV_ICM42600_ACCEL_CHAN(IIO_MOD_Y, INV_ICM42600_ACCEL_SCAN_Y,
+				inv_icm42600_accel_ext_infos),
+	INV_ICM42600_ACCEL_CHAN(IIO_MOD_Z, INV_ICM42600_ACCEL_SCAN_Z,
+				inv_icm42600_accel_ext_infos),
+	INV_ICM42600_TEMP_CHAN(INV_ICM42600_ACCEL_SCAN_TEMP),
+	IIO_CHAN_SOFT_TIMESTAMP(INV_ICM42600_ACCEL_SCAN_TIMESTAMP),
+};
+
+/*
+ * IIO buffer data: size must be a power of 2 and timestamp aligned
+ * 16 bytes: 6 bytes acceleration, 2 bytes temperature, 8 bytes timestamp
+ */
+struct inv_icm42600_accel_buffer {
+	struct inv_icm42600_fifo_sensor_data accel;
+	int16_t temp;
+	int64_t timestamp __aligned(8);
+};
+
+#define INV_ICM42600_SCAN_MASK_ACCEL_3AXIS				\
+	(BIT(INV_ICM42600_ACCEL_SCAN_X) |				\
+	BIT(INV_ICM42600_ACCEL_SCAN_Y) |				\
+	BIT(INV_ICM42600_ACCEL_SCAN_Z))
+
+#define INV_ICM42600_SCAN_MASK_TEMP	BIT(INV_ICM42600_ACCEL_SCAN_TEMP)
+
+static const unsigned long inv_icm42600_accel_scan_masks[] = {
+	/* 3-axis accel + temperature */
+	INV_ICM42600_SCAN_MASK_ACCEL_3AXIS | INV_ICM42600_SCAN_MASK_TEMP,
+	0,
+};
+
+/* enable accelerometer sensor and FIFO write */
+static int inv_icm42600_accel_update_scan_mode(struct iio_dev *indio_dev,
+					       const unsigned long *scan_mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	unsigned int fifo_en = 0;
+	unsigned int sleep_temp = 0;
+	unsigned int sleep_accel = 0;
+	unsigned int sleep;
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	if (*scan_mask & INV_ICM42600_SCAN_MASK_TEMP) {
+		/* enable temp sensor */
+		ret = inv_icm42600_set_temp_conf(st, true, &sleep_temp);
+		if (ret)
+			goto out_unlock;
+		fifo_en |= INV_ICM42600_SENSOR_TEMP;
+	}
+
+	if (*scan_mask & INV_ICM42600_SCAN_MASK_ACCEL_3AXIS) {
+		/* enable accel sensor */
+		conf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;
+		ret = inv_icm42600_set_accel_conf(st, &conf, &sleep_accel);
+		if (ret)
+			goto out_unlock;
+		fifo_en |= INV_ICM42600_SENSOR_ACCEL;
+	}
+
+	/* update data FIFO write */
+	inv_icm42600_timestamp_apply_odr(ts, 0, 0, 0);
+	ret = inv_icm42600_buffer_set_fifo_en(st, fifo_en | st->fifo.en);
+	if (ret)
+		goto out_unlock;
+
+	ret = inv_icm42600_buffer_update_watermark(st);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	/* sleep maximum required time */
+	if (sleep_accel > sleep_temp)
+		sleep = sleep_accel;
+	else
+		sleep = sleep_temp;
+	if (sleep)
+		msleep(sleep);
+	return ret;
+}
+
+static int inv_icm42600_accel_read_sensor(struct inv_icm42600_state *st,
+					  struct iio_chan_spec const *chan,
+					  int16_t *val)
+{
+	struct device *dev = regmap_get_device(st->map);
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	unsigned int reg;
+	__be16 *data;
+	int ret;
+
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_ACCEL_DATA_X;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_ACCEL_DATA_Y;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_ACCEL_DATA_Z;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	/* enable accel sensor */
+	conf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;
+	ret = inv_icm42600_set_accel_conf(st, &conf, NULL);
+	if (ret)
+		goto exit;
+
+	/* read accel register data */
+	data = (__be16 *)&st->buffer[0];
+	ret = regmap_bulk_read(st->map, reg, data, sizeof(*data));
+	if (ret)
+		goto exit;
+
+	*val = (int16_t)be16_to_cpup(data);
+	if (*val == INV_ICM42600_DATA_INVALID)
+		ret = -EINVAL;
+exit:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	return ret;
+}
+
+/* IIO format int + nano */
+static const int inv_icm42600_accel_scale[] = {
+	/* +/- 16G => 0.004788403 m/s-2 */
+	[2 * INV_ICM42600_ACCEL_FS_16G] = 0,
+	[2 * INV_ICM42600_ACCEL_FS_16G + 1] = 4788403,
+	/* +/- 8G => 0.002394202 m/s-2 */
+	[2 * INV_ICM42600_ACCEL_FS_8G] = 0,
+	[2 * INV_ICM42600_ACCEL_FS_8G + 1] = 2394202,
+	/* +/- 4G => 0.001197101 m/s-2 */
+	[2 * INV_ICM42600_ACCEL_FS_4G] = 0,
+	[2 * INV_ICM42600_ACCEL_FS_4G + 1] = 1197101,
+	/* +/- 2G => 0.000598550 m/s-2 */
+	[2 * INV_ICM42600_ACCEL_FS_2G] = 0,
+	[2 * INV_ICM42600_ACCEL_FS_2G + 1] = 598550,
+};
+
+static int inv_icm42600_accel_read_scale(struct inv_icm42600_state *st,
+					 int *val, int *val2)
+{
+	unsigned int idx;
+
+	idx = st->conf.accel.fs;
+
+	*val = inv_icm42600_accel_scale[2 * idx];
+	*val2 = inv_icm42600_accel_scale[2 * idx + 1];
+	return IIO_VAL_INT_PLUS_NANO;
+}
+
+static int inv_icm42600_accel_write_scale(struct inv_icm42600_state *st,
+					  int val, int val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int idx;
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	int ret;
+
+	for (idx = 0; idx < ARRAY_SIZE(inv_icm42600_accel_scale); idx += 2) {
+		if (val == inv_icm42600_accel_scale[idx] &&
+		    val2 == inv_icm42600_accel_scale[idx + 1])
+			break;
+	}
+	if (idx >= ARRAY_SIZE(inv_icm42600_accel_scale))
+		return -EINVAL;
+
+	conf.fs = idx / 2;
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_set_accel_conf(st, &conf, NULL);
+
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+/* IIO format int + micro */
+static const int inv_icm42600_accel_odr[] = {
+	/* 12.5Hz */
+	12, 500000,
+	/* 25Hz */
+	25, 0,
+	/* 50Hz */
+	50, 0,
+	/* 100Hz */
+	100, 0,
+	/* 200Hz */
+	200, 0,
+	/* 1kHz */
+	1000, 0,
+	/* 2kHz */
+	2000, 0,
+	/* 4kHz */
+	4000, 0,
+};
+
+static const int inv_icm42600_accel_odr_conv[] = {
+	INV_ICM42600_ODR_12_5HZ,
+	INV_ICM42600_ODR_25HZ,
+	INV_ICM42600_ODR_50HZ,
+	INV_ICM42600_ODR_100HZ,
+	INV_ICM42600_ODR_200HZ,
+	INV_ICM42600_ODR_1KHZ_LN,
+	INV_ICM42600_ODR_2KHZ_LN,
+	INV_ICM42600_ODR_4KHZ_LN,
+};
+
+static int inv_icm42600_accel_read_odr(struct inv_icm42600_state *st,
+				       int *val, int *val2)
+{
+	unsigned int odr;
+	unsigned int i;
+
+	odr = st->conf.accel.odr;
+
+	for (i = 0; i < ARRAY_SIZE(inv_icm42600_accel_odr_conv); ++i) {
+		if (inv_icm42600_accel_odr_conv[i] == odr)
+			break;
+	}
+	if (i >= ARRAY_SIZE(inv_icm42600_accel_odr_conv))
+		return -EINVAL;
+
+	*val = inv_icm42600_accel_odr[2 * i];
+	*val2 = inv_icm42600_accel_odr[2 * i + 1];
+
+	return IIO_VAL_INT_PLUS_MICRO;
+}
+
+static int inv_icm42600_accel_write_odr(struct iio_dev *indio_dev,
+					int val, int val2)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int idx;
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	int ret;
+
+	for (idx = 0; idx < ARRAY_SIZE(inv_icm42600_accel_odr); idx += 2) {
+		if (val == inv_icm42600_accel_odr[idx] &&
+		    val2 == inv_icm42600_accel_odr[idx + 1])
+			break;
+	}
+	if (idx >= ARRAY_SIZE(inv_icm42600_accel_odr))
+		return -EINVAL;
+
+	conf.odr = inv_icm42600_accel_odr_conv[idx / 2];
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_timestamp_update_odr(ts, inv_icm42600_odr_to_period(conf.odr),
+						iio_buffer_enabled(indio_dev));
+	if (ret)
+		goto out_unlock;
+
+	ret = inv_icm42600_set_accel_conf(st, &conf, NULL);
+	if (ret)
+		goto out_unlock;
+	inv_icm42600_buffer_update_fifo_period(st);
+	inv_icm42600_buffer_update_watermark(st);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+/*
+ * Calibration bias values, IIO range format int + micro.
+ * Value is limited to +/-1g coded on 12 bits signed. Step is 0.5mg.
+ */
+static int inv_icm42600_accel_calibbias[] = {
+	-10, 42010,		/* min: -10.042010 m/s² */
+	0, 4903,		/* step: 0.004903 m/s² */
+	10, 37106,		/* max: 10.037106 m/s² */
+};
+
+static int inv_icm42600_accel_read_offset(struct inv_icm42600_state *st,
+					  struct iio_chan_spec const *chan,
+					  int *val, int *val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	int64_t val64;
+	int32_t bias;
+	unsigned int reg;
+	int16_t offset;
+	uint8_t data[2];
+	int ret;
+
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_OFFSET_USER4;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_OFFSET_USER6;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_OFFSET_USER7;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = regmap_bulk_read(st->map, reg, st->buffer, sizeof(data));
+	memcpy(data, st->buffer, sizeof(data));
+
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	if (ret)
+		return ret;
+
+	/* 12 bits signed value */
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		offset = sign_extend32(((data[0] & 0xF0) << 4) | data[1], 11);
+		break;
+	case IIO_MOD_Y:
+		offset = sign_extend32(((data[1] & 0x0F) << 8) | data[0], 11);
+		break;
+	case IIO_MOD_Z:
+		offset = sign_extend32(((data[0] & 0xF0) << 4) | data[1], 11);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+	 * convert raw offset to g then to m/s²
+	 * 12 bits signed raw step 0.5mg to g: 5 / 10000
+	 * g to m/s²: 9.806650
+	 * result in micro (1000000)
+	 * (offset * 5 * 9.806650 * 1000000) / 10000
+	 */
+	val64 = (int64_t)offset * 5LL * 9806650LL;
+	/* for rounding, add + or - divisor (10000) divided by 2 */
+	if (val64 >= 0)
+		val64 += 10000LL / 2LL;
+	else
+		val64 -= 10000LL / 2LL;
+	bias = div_s64(val64, 10000L);
+	*val = bias / 1000000L;
+	*val2 = bias % 1000000L;
+
+	return IIO_VAL_INT_PLUS_MICRO;
+}
+
+static int inv_icm42600_accel_write_offset(struct inv_icm42600_state *st,
+					   struct iio_chan_spec const *chan,
+					   int val, int val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	int64_t val64;
+	int32_t min, max;
+	unsigned int reg, regval;
+	int16_t offset;
+	int ret;
+
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_OFFSET_USER4;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_OFFSET_USER6;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_OFFSET_USER7;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* inv_icm42600_accel_calibbias: min - step - max in micro */
+	min = inv_icm42600_accel_calibbias[0] * 1000000L +
+	      inv_icm42600_accel_calibbias[1];
+	max = inv_icm42600_accel_calibbias[4] * 1000000L +
+	      inv_icm42600_accel_calibbias[5];
+	val64 = (int64_t)val * 1000000LL + (int64_t)val2;
+	if (val64 < min || val64 > max)
+		return -EINVAL;
+
+	/*
+	 * convert m/s² to g then to raw value
+	 * m/s² to g: 1 / 9.806650
+	 * g to raw 12 bits signed, step 0.5mg: 10000 / 5
+	 * val in micro (1000000)
+	 * val * 10000 / (9.806650 * 1000000 * 5)
+	 */
+	val64 = val64 * 10000LL;
+	/* for rounding, add + or - divisor (9806650 * 5) divided by 2 */
+	if (val64 >= 0)
+		val64 += 9806650 * 5 / 2;
+	else
+		val64 -= 9806650 * 5 / 2;
+	offset = div_s64(val64, 9806650 * 5);
+
+	/* clamp value limited to 12 bits signed */
+	if (offset < -2048)
+		offset = -2048;
+	else if (offset > 2047)
+		offset = 2047;
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		/* OFFSET_USER4 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER4,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = ((offset & 0xF00) >> 4) | (regval & 0x0F);
+		st->buffer[1] = offset & 0xFF;
+		break;
+	case IIO_MOD_Y:
+		/* OFFSET_USER7 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER7,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = offset & 0xFF;
+		st->buffer[1] = ((offset & 0xF00) >> 8) | (regval & 0xF0);
+		break;
+	case IIO_MOD_Z:
+		/* OFFSET_USER7 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER7,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = ((offset & 0xF00) >> 4) | (regval & 0x0F);
+		st->buffer[1] = offset & 0xFF;
+		break;
+	default:
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	ret = regmap_bulk_write(st->map, reg, st->buffer, 2);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	return ret;
+}
+
+static int inv_icm42600_accel_read_raw(struct iio_dev *indio_dev,
+				       struct iio_chan_spec const *chan,
+				       int *val, int *val2, long mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int16_t data;
+	int ret;
+
+	switch (chan->type) {
+	case IIO_ACCEL:
+		break;
+	case IIO_TEMP:
+		return inv_icm42600_temp_read_raw(indio_dev, chan, val, val2, mask);
+	default:
+		return -EINVAL;
+	}
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_accel_read_sensor(st, chan, &data);
+		iio_device_release_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		*val = data;
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		return inv_icm42600_accel_read_scale(st, val, val2);
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return inv_icm42600_accel_read_odr(st, val, val2);
+	case IIO_CHAN_INFO_CALIBBIAS:
+		return inv_icm42600_accel_read_offset(st, chan, val, val2);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_accel_read_avail(struct iio_dev *indio_dev,
+					 struct iio_chan_spec const *chan,
+					 const int **vals,
+					 int *type, int *length, long mask)
+{
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		*vals = inv_icm42600_accel_scale;
+		*type = IIO_VAL_INT_PLUS_NANO;
+		*length = ARRAY_SIZE(inv_icm42600_accel_scale);
+		return IIO_AVAIL_LIST;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*vals = inv_icm42600_accel_odr;
+		*type = IIO_VAL_INT_PLUS_MICRO;
+		*length = ARRAY_SIZE(inv_icm42600_accel_odr);
+		return IIO_AVAIL_LIST;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		*vals = inv_icm42600_accel_calibbias;
+		*type = IIO_VAL_INT_PLUS_MICRO;
+		return IIO_AVAIL_RANGE;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_accel_write_raw(struct iio_dev *indio_dev,
+					struct iio_chan_spec const *chan,
+					int val, int val2, long mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_accel_write_scale(st, val, val2);
+		iio_device_release_direct_mode(indio_dev);
+		return ret;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return inv_icm42600_accel_write_odr(indio_dev, val, val2);
+	case IIO_CHAN_INFO_CALIBBIAS:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_accel_write_offset(st, chan, val, val2);
+		iio_device_release_direct_mode(indio_dev);
+		return ret;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_accel_write_raw_get_fmt(struct iio_dev *indio_dev,
+						struct iio_chan_spec const *chan,
+						long mask)
+{
+	if (chan->type != IIO_ACCEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		return IIO_VAL_INT_PLUS_NANO;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		return IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_accel_hwfifo_set_watermark(struct iio_dev *indio_dev,
+						   unsigned int val)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	st->fifo.watermark.accel = val;
+	ret = inv_icm42600_buffer_update_watermark(st);
+
+	mutex_unlock(&st->lock);
+
+	return ret;
+}
+
+static int inv_icm42600_accel_hwfifo_flush(struct iio_dev *indio_dev,
+					   unsigned int count)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	if (count == 0)
+		return 0;
+
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_buffer_hwfifo_flush(st, count);
+	if (!ret)
+		ret = st->fifo.nb.accel;
+
+	mutex_unlock(&st->lock);
+
+	return ret;
+}
+
+static const struct iio_info inv_icm42600_accel_info = {
+	.read_raw = inv_icm42600_accel_read_raw,
+	.read_avail = inv_icm42600_accel_read_avail,
+	.write_raw = inv_icm42600_accel_write_raw,
+	.write_raw_get_fmt = inv_icm42600_accel_write_raw_get_fmt,
+	.debugfs_reg_access = inv_icm42600_debugfs_reg,
+	.update_scan_mode = inv_icm42600_accel_update_scan_mode,
+	.hwfifo_set_watermark = inv_icm42600_accel_hwfifo_set_watermark,
+	.hwfifo_flush_to_buffer = inv_icm42600_accel_hwfifo_flush,
+};
+
+struct iio_dev *inv_icm42600_accel_init(struct inv_icm42600_state *st)
+{
+	struct device *dev = regmap_get_device(st->map);
+	const char *name;
+	struct inv_icm42600_timestamp *ts;
+	struct iio_dev *indio_dev;
+	int ret;
+
+	name = devm_kasprintf(dev, GFP_KERNEL, "%s-accel", st->name);
+	if (!name)
+		return ERR_PTR(-ENOMEM);
+
+	indio_dev = devm_iio_device_alloc(dev, sizeof(*ts));
+	if (!indio_dev)
+		return ERR_PTR(-ENOMEM);
+
+	ts = iio_priv(indio_dev);
+	inv_icm42600_timestamp_init(ts, inv_icm42600_odr_to_period(st->conf.accel.odr));
+
+	iio_device_set_drvdata(indio_dev, st);
+	indio_dev->name = name;
+	indio_dev->info = &inv_icm42600_accel_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = inv_icm42600_accel_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_icm42600_accel_channels);
+	indio_dev->available_scan_masks = inv_icm42600_accel_scan_masks;
+
+// FIXME! ACHEUL
+#if 0	
+	ret = devm_iio_kfifo_buffer_setup(dev, indio_dev,
+					  INDIO_BUFFER_SOFTWARE,
+					  &inv_icm42600_buffer_ops);
+	if (ret)
+		return ERR_PTR(ret);
+
+#endif // 0
+	ret = devm_iio_device_register(dev, indio_dev);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return indio_dev;
+}
+
+int inv_icm42600_accel_parse_fifo(struct iio_dev *indio_dev)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	ssize_t i, size;
+	unsigned int no;
+	const void *accel, *gyro, *timestamp;
+	const int8_t *temp;
+	unsigned int odr;
+	int64_t ts_val;
+	struct inv_icm42600_accel_buffer buffer;
+
+	/* parse all fifo packets */
+	for (i = 0, no = 0; i < st->fifo.count; i += size, ++no) {
+		size = inv_icm42600_fifo_decode_packet(&st->fifo.data[i],
+				&accel, &gyro, &temp, &timestamp, &odr);
+		/* quit if error or FIFO is empty */
+		if (size <= 0)
+			return size;
+
+		/* skip packet if no accel data or data is invalid */
+		if (accel == NULL || !inv_icm42600_fifo_is_data_valid(accel))
+			continue;
+
+		/* update odr */
+		if (odr & INV_ICM42600_SENSOR_ACCEL)
+			inv_icm42600_timestamp_apply_odr(ts, st->fifo.period,
+							 st->fifo.nb.total, no);
+
+		/* buffer is copied to userspace, zeroing it to avoid any data leak */
+		memset(&buffer, 0, sizeof(buffer));
+		memcpy(&buffer.accel, accel, sizeof(buffer.accel));
+		/* convert 8 bits FIFO temperature in high resolution format */
+		buffer.temp = temp ? (*temp * 64) : 0;
+		ts_val = inv_icm42600_timestamp_pop(ts);
+		iio_push_to_buffers_with_timestamp(indio_dev, &buffer, ts_val);
+	}
+
+	return 0;
+}
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c	1969-12-31 19:00:00.000000000 -0500
+++ kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_core.c	2024-05-29 22:10:12.857805157 -0400
@@ -0,0 +1,904 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pm_runtime.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+#include <linux/iio/iio.h>
+
+#include "inv_icm42600.h"
+#include "inv_icm42600_buffer.h"
+#include "inv_icm42600_timestamp.h"
+
+#define USE_VDD 0
+
+static const struct regmap_range_cfg inv_icm42600_regmap_ranges[] = {
+	{
+		.name = "user banks",
+		.range_min = 0x0000,
+		.range_max = 0x4FFF,
+		.selector_reg = INV_ICM42600_REG_BANK_SEL,
+		.selector_mask = INV_ICM42600_BANK_SEL_MASK,
+		.selector_shift = 0,
+		.window_start = 0,
+		.window_len = 0x1000,
+	},
+};
+
+const struct regmap_config inv_icm42600_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0x4FFF,
+	.ranges = inv_icm42600_regmap_ranges,
+	.num_ranges = ARRAY_SIZE(inv_icm42600_regmap_ranges),
+};
+EXPORT_SYMBOL_GPL(inv_icm42600_regmap_config);
+
+struct inv_icm42600_hw {
+	uint8_t whoami;
+	const char *name;
+	const struct inv_icm42600_conf *conf;
+};
+
+/* chip initial default configuration */
+static const struct inv_icm42600_conf inv_icm42600_default_conf = {
+	.gyro = {
+		.mode = INV_ICM42600_SENSOR_MODE_OFF,
+		.fs = INV_ICM42600_GYRO_FS_2000DPS,
+		.odr = INV_ICM42600_ODR_50HZ,
+		.filter = INV_ICM42600_FILTER_BW_ODR_DIV_2,
+	},
+	.accel = {
+		.mode = INV_ICM42600_SENSOR_MODE_OFF,
+		.fs = INV_ICM42600_ACCEL_FS_16G,
+		.odr = INV_ICM42600_ODR_50HZ,
+		.filter = INV_ICM42600_FILTER_BW_ODR_DIV_2,
+	},
+	.temp_en = false,
+};
+
+static const struct inv_icm42600_hw inv_icm42600_hw[INV_CHIP_NB] = {
+	[INV_CHIP_ICM42600] = {
+		.whoami = INV_ICM42600_WHOAMI_ICM42600,
+		.name = "icm42600",
+		.conf = &inv_icm42600_default_conf,
+	},
+	[INV_CHIP_ICM42602] = {
+		.whoami = INV_ICM42600_WHOAMI_ICM42602,
+		.name = "icm42602",
+		.conf = &inv_icm42600_default_conf,
+	},
+	[INV_CHIP_ICM42605] = {
+		.whoami = INV_ICM42600_WHOAMI_ICM42605,
+		.name = "icm42605",
+		.conf = &inv_icm42600_default_conf,
+	},
+	[INV_CHIP_ICM42622] = {
+		.whoami = INV_ICM42600_WHOAMI_ICM42622,
+		.name = "icm42622",
+		.conf = &inv_icm42600_default_conf,
+	},
+};
+
+const struct iio_mount_matrix *
+inv_icm42600_get_mount_matrix(const struct iio_dev *indio_dev,
+			      const struct iio_chan_spec *chan)
+{
+	const struct inv_icm42600_state *st = iio_device_get_drvdata((struct iio_dev *) indio_dev);
+
+	return &st->orientation;
+}
+
+uint32_t inv_icm42600_odr_to_period(enum inv_icm42600_odr odr)
+{
+	static uint32_t odr_periods[INV_ICM42600_ODR_NB] = {
+		/* reserved values */
+		0, 0, 0,
+		/* 8kHz */
+		125000,
+		/* 4kHz */
+		250000,
+		/* 2kHz */
+		500000,
+		/* 1kHz */
+		1000000,
+		/* 200Hz */
+		5000000,
+		/* 100Hz */
+		10000000,
+		/* 50Hz */
+		20000000,
+		/* 25Hz */
+		40000000,
+		/* 12.5Hz */
+		80000000,
+		/* 6.25Hz */
+		160000000,
+		/* 3.125Hz */
+		320000000,
+		/* 1.5625Hz */
+		640000000,
+		/* 500Hz */
+		2000000,
+	};
+
+	return odr_periods[odr];
+}
+
+static int inv_icm42600_set_pwr_mgmt0(struct inv_icm42600_state *st,
+				      enum inv_icm42600_sensor_mode gyro,
+				      enum inv_icm42600_sensor_mode accel,
+				      bool temp, unsigned int *sleep_ms)
+{
+	enum inv_icm42600_sensor_mode oldgyro = st->conf.gyro.mode;
+	enum inv_icm42600_sensor_mode oldaccel = st->conf.accel.mode;
+	bool oldtemp = st->conf.temp_en;
+	unsigned int sleepval;
+	unsigned int val;
+	int ret;
+
+    printk("%s:%d ACHEUL, in", __FUNCTION__, __LINE__);
+
+	/* if nothing changed, exit */
+	if (gyro == oldgyro && accel == oldaccel && temp == oldtemp){
+        printk("%s:%d ACHEUL, out", __FUNCTION__, __LINE__);
+		return 0;
+    }
+
+	val = INV_ICM42600_PWR_MGMT0_GYRO(gyro) |
+	      INV_ICM42600_PWR_MGMT0_ACCEL(accel);
+	if (!temp)
+		val |= INV_ICM42600_PWR_MGMT0_TEMP_DIS;
+	ret = regmap_write(st->map, INV_ICM42600_REG_PWR_MGMT0, val);
+	if (ret)
+		return ret;
+
+	st->conf.gyro.mode = gyro;
+	st->conf.accel.mode = accel;
+	st->conf.temp_en = temp;
+
+	/* compute required wait time for sensors to stabilize */
+	sleepval = 0;
+	/* temperature stabilization time */
+	if (temp && !oldtemp) {
+		if (sleepval < INV_ICM42600_TEMP_STARTUP_TIME_MS)
+			sleepval = INV_ICM42600_TEMP_STARTUP_TIME_MS;
+	}
+	/* accel startup time */
+	if (accel != oldaccel && oldaccel == INV_ICM42600_SENSOR_MODE_OFF) {
+		/* block any register write for at least 200 µs */
+		usleep_range(200, 300);
+		if (sleepval < INV_ICM42600_ACCEL_STARTUP_TIME_MS)
+			sleepval = INV_ICM42600_ACCEL_STARTUP_TIME_MS;
+	}
+	if (gyro != oldgyro) {
+		/* gyro startup time */
+		if (oldgyro == INV_ICM42600_SENSOR_MODE_OFF) {
+			/* block any register write for at least 200 µs */
+			usleep_range(200, 300);
+			if (sleepval < INV_ICM42600_GYRO_STARTUP_TIME_MS)
+				sleepval = INV_ICM42600_GYRO_STARTUP_TIME_MS;
+		/* gyro stop time */
+		} else if (gyro == INV_ICM42600_SENSOR_MODE_OFF) {
+			if (sleepval < INV_ICM42600_GYRO_STOP_TIME_MS)
+				sleepval =  INV_ICM42600_GYRO_STOP_TIME_MS;
+		}
+	}
+
+	/* deferred sleep value if sleep pointer is provided or direct sleep */
+	if (sleep_ms)
+		*sleep_ms = sleepval;
+	else if (sleepval)
+		msleep(sleepval);
+
+    printk("%s:%d ACHEUL, out", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+int inv_icm42600_set_accel_conf(struct inv_icm42600_state *st,
+				struct inv_icm42600_sensor_conf *conf,
+				unsigned int *sleep_ms)
+{
+	struct inv_icm42600_sensor_conf *oldconf = &st->conf.accel;
+	unsigned int val;
+	int ret;
+
+	/* Sanitize missing values with current values */
+	if (conf->mode < 0)
+		conf->mode = oldconf->mode;
+	if (conf->fs < 0)
+		conf->fs = oldconf->fs;
+	if (conf->odr < 0)
+		conf->odr = oldconf->odr;
+	if (conf->filter < 0)
+		conf->filter = oldconf->filter;
+
+	/* set ACCEL_CONFIG0 register (accel fullscale & odr) */
+	if (conf->fs != oldconf->fs || conf->odr != oldconf->odr) {
+		val = INV_ICM42600_ACCEL_CONFIG0_FS(conf->fs) |
+		      INV_ICM42600_ACCEL_CONFIG0_ODR(conf->odr);
+		ret = regmap_write(st->map, INV_ICM42600_REG_ACCEL_CONFIG0, val);
+		if (ret)
+			return ret;
+		oldconf->fs = conf->fs;
+		oldconf->odr = conf->odr;
+	}
+
+	/* set GYRO_ACCEL_CONFIG0 register (accel filter) */
+	if (conf->filter != oldconf->filter) {
+		val = INV_ICM42600_GYRO_ACCEL_CONFIG0_ACCEL_FILT(conf->filter) |
+		      INV_ICM42600_GYRO_ACCEL_CONFIG0_GYRO_FILT(st->conf.gyro.filter);
+		ret = regmap_write(st->map, INV_ICM42600_REG_GYRO_ACCEL_CONFIG0, val);
+		if (ret)
+			return ret;
+		oldconf->filter = conf->filter;
+	}
+
+	/* set PWR_MGMT0 register (accel sensor mode) */
+	return inv_icm42600_set_pwr_mgmt0(st, st->conf.gyro.mode, conf->mode,
+					  st->conf.temp_en, sleep_ms);
+}
+
+int inv_icm42600_set_gyro_conf(struct inv_icm42600_state *st,
+			       struct inv_icm42600_sensor_conf *conf,
+			       unsigned int *sleep_ms)
+{
+	struct inv_icm42600_sensor_conf *oldconf = &st->conf.gyro;
+	unsigned int val;
+	int ret;
+
+	/* sanitize missing values with current values */
+	if (conf->mode < 0)
+		conf->mode = oldconf->mode;
+	if (conf->fs < 0)
+		conf->fs = oldconf->fs;
+	if (conf->odr < 0)
+		conf->odr = oldconf->odr;
+	if (conf->filter < 0)
+		conf->filter = oldconf->filter;
+
+	/* set GYRO_CONFIG0 register (gyro fullscale & odr) */
+	if (conf->fs != oldconf->fs || conf->odr != oldconf->odr) {
+		val = INV_ICM42600_GYRO_CONFIG0_FS(conf->fs) |
+		      INV_ICM42600_GYRO_CONFIG0_ODR(conf->odr);
+		ret = regmap_write(st->map, INV_ICM42600_REG_GYRO_CONFIG0, val);
+		if (ret)
+			return ret;
+		oldconf->fs = conf->fs;
+		oldconf->odr = conf->odr;
+	}
+
+	/* set GYRO_ACCEL_CONFIG0 register (gyro filter) */
+	if (conf->filter != oldconf->filter) {
+		val = INV_ICM42600_GYRO_ACCEL_CONFIG0_ACCEL_FILT(st->conf.accel.filter) |
+		      INV_ICM42600_GYRO_ACCEL_CONFIG0_GYRO_FILT(conf->filter);
+		ret = regmap_write(st->map, INV_ICM42600_REG_GYRO_ACCEL_CONFIG0, val);
+		if (ret)
+			return ret;
+		oldconf->filter = conf->filter;
+	}
+
+	/* set PWR_MGMT0 register (gyro sensor mode) */
+	return inv_icm42600_set_pwr_mgmt0(st, conf->mode, st->conf.accel.mode,
+					  st->conf.temp_en, sleep_ms);
+
+	return 0;
+}
+
+int inv_icm42600_set_temp_conf(struct inv_icm42600_state *st, bool enable,
+			       unsigned int *sleep_ms)
+{
+	return inv_icm42600_set_pwr_mgmt0(st, st->conf.gyro.mode,
+					  st->conf.accel.mode, enable,
+					  sleep_ms);
+}
+
+int inv_icm42600_debugfs_reg(struct iio_dev *indio_dev, unsigned int reg,
+			     unsigned int writeval, unsigned int *readval)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	if (readval)
+		ret = regmap_read(st->map, reg, readval);
+	else
+		ret = regmap_write(st->map, reg, writeval);
+
+	mutex_unlock(&st->lock);
+
+	return ret;
+}
+
+static int inv_icm42600_set_conf(struct inv_icm42600_state *st,
+				 const struct inv_icm42600_conf *conf)
+{
+	unsigned int val;
+	int ret;
+
+    printk("%s:%d, ACHEUL in", __FUNCTION__, __LINE__);
+
+	/* set PWR_MGMT0 register (gyro & accel sensor mode, temp enabled) */
+	val = INV_ICM42600_PWR_MGMT0_GYRO(conf->gyro.mode) |
+	      INV_ICM42600_PWR_MGMT0_ACCEL(conf->accel.mode);
+	if (!conf->temp_en)
+		val |= INV_ICM42600_PWR_MGMT0_TEMP_DIS;
+	ret = regmap_write(st->map, INV_ICM42600_REG_PWR_MGMT0, val);
+	if (ret){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	/* set GYRO_CONFIG0 register (gyro fullscale & odr) */
+	val = INV_ICM42600_GYRO_CONFIG0_FS(conf->gyro.fs) |
+	      INV_ICM42600_GYRO_CONFIG0_ODR(conf->gyro.odr);
+	ret = regmap_write(st->map, INV_ICM42600_REG_GYRO_CONFIG0, val);
+	if (ret){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	/* set ACCEL_CONFIG0 register (accel fullscale & odr) */
+	val = INV_ICM42600_ACCEL_CONFIG0_FS(conf->accel.fs) |
+	      INV_ICM42600_ACCEL_CONFIG0_ODR(conf->accel.odr);
+	ret = regmap_write(st->map, INV_ICM42600_REG_ACCEL_CONFIG0, val);
+	if (ret){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	/* set GYRO_ACCEL_CONFIG0 register (gyro & accel filters) */
+	val = INV_ICM42600_GYRO_ACCEL_CONFIG0_ACCEL_FILT(conf->accel.filter) |
+	      INV_ICM42600_GYRO_ACCEL_CONFIG0_GYRO_FILT(conf->gyro.filter);
+	ret = regmap_write(st->map, INV_ICM42600_REG_GYRO_ACCEL_CONFIG0, val);
+	if (ret){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	/* update internal conf */
+	st->conf = *conf;
+
+    printk("%s:%d, ACHEUL out", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+/**
+ *  inv_icm42600_setup() - check and setup chip
+ *  @st:	driver internal state
+ *  @bus_setup:	callback for setting up bus specific registers
+ *
+ *  Returns 0 on success, a negative error code otherwise.
+ */
+static int inv_icm42600_setup(struct inv_icm42600_state *st, inv_icm42600_bus_setup bus_setup)
+{
+	const struct inv_icm42600_hw *hw = &inv_icm42600_hw[st->chip];
+	const struct device *dev = regmap_get_device(st->map);
+	unsigned int val;
+	int ret;
+
+    printk("%s:%d, ACHEUL in", __FUNCTION__, __LINE__);
+
+	/* check chip self-identification value */
+	ret = regmap_read(st->map, INV_ICM42600_REG_WHOAMI, &val);
+	if (ret){
+        printk("%s:%d, ACHEUL, failed read regmap: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+    printk("%s:%d, ACHEUL val: %d, whoami: %d, name: %s", __FUNCTION__, __LINE__, val, hw->whoami, hw->name);
+
+	if (val != hw->whoami) {
+		dev_err(dev, "invalid whoami %#02x expected %#02x (%s)\n", val, hw->whoami, hw->name);
+        printk("%s:%d, invalid whoami %#02x expected %#02x (%s)\n", __FUNCTION__, __LINE__, val, hw->whoami, hw->name);
+		return -ENODEV;
+	}
+	st->name = hw->name;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	/* reset to make sure previous state are not there */
+	ret = regmap_write(st->map, INV_ICM42600_REG_DEVICE_CONFIG, INV_ICM42600_DEVICE_CONFIG_SOFT_RESET);
+	if (ret){
+        printk("%s:%d, ACHEUL, failed write regmap: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+	msleep(INV_ICM42600_RESET_TIME_MS);
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	ret = regmap_read(st->map, INV_ICM42600_REG_INT_STATUS, &val);
+	if (ret){
+        printk("%s:%d, ACHEUL, failed read regmap: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	if (!(val & INV_ICM42600_INT_STATUS_RESET_DONE)) {
+		dev_err(dev, "reset error, reset done bit not set\n");
+        printk("%s:%d, ACHEUL, reset problem", __FUNCTION__, __LINE__);
+		return -ENODEV;
+	}
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	/* set chip bus configuration */
+	ret = bus_setup(st);
+	if (ret) {
+        printk("%s:%d, ACHEUL, failed to bus setup: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	/* sensor data in big-endian (default) */
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG0,
+				 INV_ICM42600_INTF_CONFIG0_SENSOR_DATA_ENDIAN,
+				 INV_ICM42600_INTF_CONFIG0_SENSOR_DATA_ENDIAN);
+	if (ret) {
+        printk("%s:%d, ACHEUL, failed to regmap_update_bits ret: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	ret = inv_icm42600_set_conf(st, hw->conf);
+
+    printk("%s:%d, ACHEUL out: ret: %d", __FUNCTION__, __LINE__, ret);
+    return ret;
+}
+
+static irqreturn_t inv_icm42600_irq_timestamp(int irq, void *_data)
+{
+	struct inv_icm42600_state *st = _data;
+
+	st->timestamp.gyro = iio_get_time_ns(st->indio_gyro);
+	st->timestamp.accel = iio_get_time_ns(st->indio_accel);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t inv_icm42600_irq_handler(int irq, void *_data)
+{
+	struct inv_icm42600_state *st = _data;
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int status;
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	ret = regmap_read(st->map, INV_ICM42600_REG_INT_STATUS, &status);
+	if (ret)
+		goto out_unlock;
+
+	/* FIFO full */
+	if (status & INV_ICM42600_INT_STATUS_FIFO_FULL)
+		dev_warn(dev, "FIFO full data lost!\n");
+
+	/* FIFO threshold reached */
+	if (status & INV_ICM42600_INT_STATUS_FIFO_THS) {
+		ret = inv_icm42600_buffer_fifo_read(st, 0);
+		if (ret) {
+			dev_err(dev, "FIFO read error %d\n", ret);
+			goto out_unlock;
+		}
+		ret = inv_icm42600_buffer_fifo_parse(st);
+		if (ret)
+			dev_err(dev, "FIFO parsing error %d\n", ret);
+	}
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	return IRQ_HANDLED;
+}
+
+/**
+ * inv_icm42600_irq_init() - initialize int pin and interrupt handler
+ * @st:		driver internal state
+ * @irq:	irq number
+ * @irq_type:	irq trigger type
+ * @open_drain:	true if irq is open drain, false for push-pull
+ *
+ * Returns 0 on success, a negative error code otherwise.
+ */
+static int inv_icm42600_irq_init(struct inv_icm42600_state *st, int irq, int irq_type, bool open_drain)
+{
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int val;
+	int ret;
+
+    printk("%s:%d, ACHEUL, in", __FUNCTION__, __LINE__);
+
+	/* configure INT1 interrupt: default is active low on edge */
+	switch (irq_type) {
+	case IRQF_TRIGGER_RISING:
+	case IRQF_TRIGGER_HIGH:
+		val = INV_ICM42600_INT_CONFIG_INT1_ACTIVE_HIGH;
+		break;
+	default:
+		val = INV_ICM42600_INT_CONFIG_INT1_ACTIVE_LOW;
+		break;
+	}
+
+	switch (irq_type) {
+	case IRQF_TRIGGER_LOW:
+	case IRQF_TRIGGER_HIGH:
+		val |= INV_ICM42600_INT_CONFIG_INT1_LATCHED;
+		break;
+	default:
+		break;
+	}
+
+	if (!open_drain)
+		val |= INV_ICM42600_INT_CONFIG_INT1_PUSH_PULL;
+
+	ret = regmap_write(st->map, INV_ICM42600_REG_INT_CONFIG, val);
+	if (ret) {
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	/* Deassert async reset for proper INT pin operation (cf datasheet) */
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INT_CONFIG1,
+				 INV_ICM42600_INT_CONFIG1_ASYNC_RESET, 0);
+	if (ret){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		return ret;
+    }
+
+	ret = devm_request_threaded_irq(dev, irq, inv_icm42600_irq_timestamp, inv_icm42600_irq_handler, irq_type, "inv_icm42600", st);
+
+    printk("%s:%d, ACHEUL, out: ret: %d", __FUNCTION__, __LINE__, ret);
+    return ret;
+}
+
+static int inv_icm42600_enable_regulator_vddio(struct inv_icm42600_state *st)
+{
+
+#if USE_VDD
+	int ret;
+    printk("%s:%d ACHEUL, VDD management is enabled", __FUNCTION__, __LINE__);
+
+	ret = regulator_enable(st->vddio_supply);
+	if (ret)
+		return ret;
+
+	/* wait a little for supply ramp */
+	usleep_range(3000, 4000);
+#else
+    printk("%s:%d ACHEUL, FIXME! VDD management is disabled", __FUNCTION__, __LINE__);
+#endif // USE_VDD
+
+	return 0;
+}
+
+#if USE_VDD
+static void inv_icm42600_disable_vdd_reg(void *_data)
+{
+	struct inv_icm42600_state *st = _data;
+	const struct device *dev = regmap_get_device(st->map);
+	int ret;
+
+	ret = regulator_disable(st->vdd_supply);
+	if (ret)
+		dev_err(dev, "failed to disable vdd error %d\n", ret);
+}
+#endif // USE_VDD
+
+#if USE_VDD
+static void inv_icm42600_disable_vddio_reg(void *_data)
+{
+	struct inv_icm42600_state *st = _data;
+	const struct device *dev = regmap_get_device(st->map);
+	int ret;
+
+	ret = regulator_disable(st->vddio_supply);
+	if (ret)
+		dev_err(dev, "failed to disable vddio error %d\n", ret);
+}
+#endif // USE_VDD
+
+static void inv_icm42600_disable_pm(void *_data)
+{
+	struct device *dev = _data;
+
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+}
+
+int inv_icm42600_core_probe(struct regmap *regmap, int chip, int irq, inv_icm42600_bus_setup bus_setup)
+{
+	struct device *dev = regmap_get_device(regmap);
+	struct inv_icm42600_state *st;
+	struct irq_data *irq_desc;
+	int irq_type;
+	bool open_drain;
+	int ret;
+
+    printk("%s:%d, ACHEUL, IN", __FUNCTION__, __LINE__);
+
+	if (chip <= INV_CHIP_INVALID || chip >= INV_CHIP_NB) {
+		dev_err(dev, "ACHEUL, invalid chip = %d\n", chip);
+		return -ENODEV;
+	}
+
+    printk("%s:%d, ACHEUL, chip: %d", __FUNCTION__, __LINE__, chip);
+
+	/* get irq properties, set trigger falling by default */
+	irq_desc = irq_get_irq_data(irq);
+	if (!irq_desc) {
+		dev_err(dev, "ACHEUL, could not find IRQ: %d\n", irq);
+		return -EINVAL;
+	}
+
+	irq_type = irqd_get_trigger_type(irq_desc);
+	if (!irq_type)
+		irq_type = IRQF_TRIGGER_FALLING;
+
+	open_drain = device_property_read_bool(dev, "drive-open-drain");
+
+	st = devm_kzalloc(dev, sizeof(*st), GFP_KERNEL);
+	if (!st) {
+		dev_err(dev, "ACHEUL, could allocate mem\n");
+		return -ENOMEM;
+    }
+
+	dev_set_drvdata(dev, st);
+	mutex_init(&st->lock);
+	st->chip = chip;
+	st->map = regmap;
+
+	ret = of_iio_read_mount_matrix(dev, "mount-matrix", &st->orientation);
+	if (ret) {
+		dev_err(dev, "ACHEUL, FIXME! failed to retrieve mounting matrix %d\n", ret);
+		return ret;
+	}
+
+// ===============================================
+// ACHEUL, FIXME VDD/VDDIO not supported yet
+#if USE_VDD
+    printk("%s:%d ACHEUL, VDD management is enabled", __FUNCTION__, __LINE__);
+
+	st->vdd_supply = devm_regulator_get(dev, "vdd");
+	if (IS_ERR(st->vdd_supply)) {
+		dev_err(dev, "failed, no vdd supply\n");
+		//return PTR_ERR(st->vdd_supply);
+    }
+
+	st->vddio_supply = devm_regulator_get(dev, "vddio");
+	if (IS_ERR(st->vddio_supply)) {
+		dev_err(dev, "failed, no vddio supply\n");
+		//return PTR_ERR(st->vddio_supply);
+    }
+
+	ret = regulator_enable(st->vdd_supply);
+	if (ret) {
+		dev_err(dev, "failed to enable regulator\n");
+		return ret;
+    }
+	msleep(INV_ICM42600_POWER_UP_TIME_MS);
+
+	ret = devm_add_action_or_reset(dev, inv_icm42600_disable_vdd_reg, st);
+	if (ret) {
+		dev_err(dev, "failed to add action reset\n");
+		return ret;
+    }
+
+	ret = inv_icm42600_enable_regulator_vddio(st);
+	if (ret){
+		dev_err(dev, "failed to enable vddio\n");
+		return ret;
+    }
+
+	ret = devm_add_action_or_reset(dev, inv_icm42600_disable_vddio_reg, st);
+	if (ret){
+		dev_err(dev, "failed to add action reset\n");
+		return ret;
+    }
+#endif // 0
+// ===============================================
+
+	/* setup chip registers */
+	ret = inv_icm42600_setup(st, bus_setup);
+	if (ret) {
+		dev_err(dev, "ACHEUL, failed to setup, error: %d\n", ret);
+		return ret;
+    }
+
+	ret = inv_icm42600_timestamp_setup(st);
+	if (ret) {
+		dev_err(dev, "ACHEUL, failed to timestamp setup, error: %d\n", ret);
+		return ret;
+    }
+
+	ret = inv_icm42600_buffer_init(st);
+	if (ret) {
+		dev_err(dev, "ACHEUL, failed, to buffer init, error: %d\n", ret);
+		return ret;
+    }
+
+	st->indio_gyro = inv_icm42600_gyro_init(st);
+	if (IS_ERR(st->indio_gyro)) {
+		return PTR_ERR(st->indio_gyro);
+    }
+
+	st->indio_accel = inv_icm42600_accel_init(st);
+	if (IS_ERR(st->indio_accel)) {
+		dev_err(dev, "ACHEUL, failed, accel init\n");
+		return PTR_ERR(st->indio_accel);
+    }
+
+	ret = inv_icm42600_irq_init(st, irq, irq_type, open_drain);
+	if (ret) {
+		dev_err(dev, "ACHEUL, failed, irq initi, %d\n", ret);
+		return ret;
+    }
+
+	/* setup runtime power management */
+	ret = pm_runtime_set_active(dev);
+	if (ret) {
+		dev_err(dev, "ACHEUL, failed, pm_runtime_set_active, %d\n", ret);
+		return ret;
+    }
+
+	pm_runtime_get_noresume(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_set_autosuspend_delay(dev, INV_ICM42600_SUSPEND_DELAY_MS);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_put(dev);
+
+	return devm_add_action_or_reset(dev, inv_icm42600_disable_pm, dev);
+}
+EXPORT_SYMBOL_GPL(inv_icm42600_core_probe);
+
+/*
+ * Suspend saves sensors state and turns everything off.
+ * Check first if runtime suspend has not already done the job.
+ */
+static int __maybe_unused inv_icm42600_suspend(struct device *dev)
+{
+
+#if USE_VDD
+	struct inv_icm42600_state *st = dev_get_drvdata(dev);
+	int ret;
+
+    printk("%s:%d ACHEUL, in", __FUNCTION__, __LINE__);
+
+	mutex_lock(&st->lock);
+
+	st->suspended.gyro = st->conf.gyro.mode;
+	st->suspended.accel = st->conf.accel.mode;
+	st->suspended.temp = st->conf.temp_en;
+	if (pm_runtime_suspended(dev)) {
+		ret = 0;
+		goto out_unlock;
+	}
+
+	/* disable FIFO data streaming */
+	if (st->fifo.on) {
+		ret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,
+				   INV_ICM42600_FIFO_CONFIG_BYPASS);
+		if (ret)
+			goto out_unlock;
+	}
+
+	ret = inv_icm42600_set_pwr_mgmt0(st, INV_ICM42600_SENSOR_MODE_OFF,
+					 INV_ICM42600_SENSOR_MODE_OFF, false,
+					 NULL);
+	if (ret)
+		goto out_unlock;
+
+	regulator_disable(st->vddio_supply);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	return ret;
+#else
+    printk("%s:%d ACHEUL, FIXME! VDD management is disabled", __FUNCTION__, __LINE__);
+    return 0;
+#endif // USE_VDD
+
+}
+
+/*
+ * System resume gets the system back on and restores the sensors state.
+ * Manually put runtime power management in system active state.
+ */
+static int __maybe_unused inv_icm42600_resume(struct device *dev)
+{
+	struct inv_icm42600_state *st = dev_get_drvdata(dev);
+	int ret;
+
+    printk("%s:%d ACHEUL, in", __FUNCTION__, __LINE__);
+
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_enable_regulator_vddio(st);
+	if (ret)
+		goto out_unlock;
+
+	pm_runtime_disable(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	/* restore sensors state */
+	ret = inv_icm42600_set_pwr_mgmt0(st, st->suspended.gyro,
+					 st->suspended.accel,
+					 st->suspended.temp, NULL);
+	if (ret)
+		goto out_unlock;
+
+	/* restore FIFO data streaming */
+	if (st->fifo.on)
+		ret = regmap_write(st->map, INV_ICM42600_REG_FIFO_CONFIG,
+				   INV_ICM42600_FIFO_CONFIG_STREAM);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+    printk("%s:%d ACHEUL, out: %d", __FUNCTION__, __LINE__, ret);
+	return ret;
+}
+
+/* Runtime suspend will turn off sensors that are enabled by iio devices. */
+static int __maybe_unused inv_icm42600_runtime_suspend(struct device *dev)
+{
+	struct inv_icm42600_state *st = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	/* disable all sensors */
+	ret = inv_icm42600_set_pwr_mgmt0(st, INV_ICM42600_SENSOR_MODE_OFF,
+					 INV_ICM42600_SENSOR_MODE_OFF, false,
+					 NULL);
+	if (ret)
+		goto error_unlock;
+
+#if USE_VDD
+    printk("%s:%d ACHEUL, VDD management is enabled", __FUNCTION__, __LINE__);
+	regulator_disable(st->vddio_supply);
+#else
+    printk("%s:%d ACHEUL, VDD management is disabled", __FUNCTION__, __LINE__);
+#endif // USE_VDD
+
+error_unlock:
+	mutex_unlock(&st->lock);
+	return ret;
+}
+
+/* Sensors are enabled by iio devices, no need to turn them back on here. */
+static int __maybe_unused inv_icm42600_runtime_resume(struct device *dev)
+{
+	struct inv_icm42600_state *st = dev_get_drvdata(dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+#if USE_VDD
+    printk("%s:%d ACHEUL, VDD management is enabled", __FUNCTION__, __LINE__);
+	ret = inv_icm42600_enable_regulator_vddio(st);
+#else
+    printk("%s:%d ACHEUL, VDD management is disabled", __FUNCTION__, __LINE__);
+#endif // USE_VDD
+
+	mutex_unlock(&st->lock);
+	return ret;
+}
+
+const struct dev_pm_ops inv_icm42600_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(inv_icm42600_suspend, inv_icm42600_resume)
+	SET_RUNTIME_PM_OPS(inv_icm42600_runtime_suspend,
+			   inv_icm42600_runtime_resume, NULL)
+};
+EXPORT_SYMBOL_GPL(inv_icm42600_pm_ops);
+
+MODULE_AUTHOR("ACHEUL & InvenSense, Inc.");
+MODULE_DESCRIPTION("InvenSense ICM-426xx device driver");
+MODULE_LICENSE("GPL");
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_gyro.c kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_gyro.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_gyro.c	1969-12-31 19:00:00.000000000 -0500
+++ kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_gyro.c	2024-05-29 22:10:12.861805193 -0400
@@ -0,0 +1,801 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Invensense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/math64.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/kfifo_buf.h>
+
+#include "inv_icm42600.h"
+#include "inv_icm42600_temp.h"
+#include "inv_icm42600_buffer.h"
+#include "inv_icm42600_timestamp.h"
+
+#define INV_ICM42600_GYRO_CHAN(_modifier, _index, _ext_info)		\
+	{								\
+		.type = IIO_ANGL_VEL,					\
+		.modified = 1,						\
+		.channel2 = _modifier,					\
+		.info_mask_separate =					\
+			BIT(IIO_CHAN_INFO_RAW) |			\
+			BIT(IIO_CHAN_INFO_CALIBBIAS),			\
+		.info_mask_shared_by_type =				\
+			BIT(IIO_CHAN_INFO_SCALE),			\
+		.info_mask_shared_by_type_available =			\
+			BIT(IIO_CHAN_INFO_SCALE) |			\
+			BIT(IIO_CHAN_INFO_CALIBBIAS),			\
+		.info_mask_shared_by_all =				\
+			BIT(IIO_CHAN_INFO_SAMP_FREQ),			\
+		.info_mask_shared_by_all_available =			\
+			BIT(IIO_CHAN_INFO_SAMP_FREQ),			\
+		.scan_index = _index,					\
+		.scan_type = {						\
+			.sign = 's',					\
+			.realbits = 16,					\
+			.storagebits = 16,				\
+			.endianness = IIO_BE,				\
+		},							\
+		.ext_info = _ext_info,					\
+	}
+
+enum inv_icm42600_gyro_scan {
+	INV_ICM42600_GYRO_SCAN_X,
+	INV_ICM42600_GYRO_SCAN_Y,
+	INV_ICM42600_GYRO_SCAN_Z,
+	INV_ICM42600_GYRO_SCAN_TEMP,
+	INV_ICM42600_GYRO_SCAN_TIMESTAMP,
+};
+
+static const struct iio_chan_spec_ext_info inv_icm42600_gyro_ext_infos[] = {
+	IIO_MOUNT_MATRIX(IIO_SHARED_BY_ALL, inv_icm42600_get_mount_matrix),
+	{},
+};
+
+static const struct iio_chan_spec inv_icm42600_gyro_channels[] = {
+	INV_ICM42600_GYRO_CHAN(IIO_MOD_X, INV_ICM42600_GYRO_SCAN_X,
+			       inv_icm42600_gyro_ext_infos),
+	INV_ICM42600_GYRO_CHAN(IIO_MOD_Y, INV_ICM42600_GYRO_SCAN_Y,
+			       inv_icm42600_gyro_ext_infos),
+	INV_ICM42600_GYRO_CHAN(IIO_MOD_Z, INV_ICM42600_GYRO_SCAN_Z,
+			       inv_icm42600_gyro_ext_infos),
+	INV_ICM42600_TEMP_CHAN(INV_ICM42600_GYRO_SCAN_TEMP),
+	IIO_CHAN_SOFT_TIMESTAMP(INV_ICM42600_GYRO_SCAN_TIMESTAMP),
+};
+
+/*
+ * IIO buffer data: size must be a power of 2 and timestamp aligned
+ * 16 bytes: 6 bytes angular velocity, 2 bytes temperature, 8 bytes timestamp
+ */
+struct inv_icm42600_gyro_buffer {
+	struct inv_icm42600_fifo_sensor_data gyro;
+	int16_t temp;
+	int64_t timestamp __aligned(8);
+};
+
+#define INV_ICM42600_SCAN_MASK_GYRO_3AXIS				\
+	(BIT(INV_ICM42600_GYRO_SCAN_X) |				\
+	BIT(INV_ICM42600_GYRO_SCAN_Y) |					\
+	BIT(INV_ICM42600_GYRO_SCAN_Z))
+
+#define INV_ICM42600_SCAN_MASK_TEMP	BIT(INV_ICM42600_GYRO_SCAN_TEMP)
+
+static const unsigned long inv_icm42600_gyro_scan_masks[] = {
+	/* 3-axis gyro + temperature */
+	INV_ICM42600_SCAN_MASK_GYRO_3AXIS | INV_ICM42600_SCAN_MASK_TEMP,
+	0,
+};
+
+/* enable gyroscope sensor and FIFO write */
+static int inv_icm42600_gyro_update_scan_mode(struct iio_dev *indio_dev,
+					      const unsigned long *scan_mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	unsigned int fifo_en = 0;
+	unsigned int sleep_gyro = 0;
+	unsigned int sleep_temp = 0;
+	unsigned int sleep;
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	if (*scan_mask & INV_ICM42600_SCAN_MASK_TEMP) {
+		/* enable temp sensor */
+		ret = inv_icm42600_set_temp_conf(st, true, &sleep_temp);
+		if (ret)
+			goto out_unlock;
+		fifo_en |= INV_ICM42600_SENSOR_TEMP;
+	}
+
+	if (*scan_mask & INV_ICM42600_SCAN_MASK_GYRO_3AXIS) {
+		/* enable gyro sensor */
+		conf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;
+		ret = inv_icm42600_set_gyro_conf(st, &conf, &sleep_gyro);
+		if (ret)
+			goto out_unlock;
+		fifo_en |= INV_ICM42600_SENSOR_GYRO;
+	}
+
+	/* update data FIFO write */
+	inv_icm42600_timestamp_apply_odr(ts, 0, 0, 0);
+	ret = inv_icm42600_buffer_set_fifo_en(st, fifo_en | st->fifo.en);
+	if (ret)
+		goto out_unlock;
+
+	ret = inv_icm42600_buffer_update_watermark(st);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	/* sleep maximum required time */
+	if (sleep_gyro > sleep_temp)
+		sleep = sleep_gyro;
+	else
+		sleep = sleep_temp;
+	if (sleep)
+		msleep(sleep);
+	return ret;
+}
+
+static int inv_icm42600_gyro_read_sensor(struct inv_icm42600_state *st,
+					 struct iio_chan_spec const *chan,
+					 int16_t *val)
+{
+	struct device *dev = regmap_get_device(st->map);
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	unsigned int reg;
+	__be16 *data;
+	int ret;
+
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_GYRO_DATA_X;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_GYRO_DATA_Y;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_GYRO_DATA_Z;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	/* enable gyro sensor */
+	conf.mode = INV_ICM42600_SENSOR_MODE_LOW_NOISE;
+	ret = inv_icm42600_set_gyro_conf(st, &conf, NULL);
+	if (ret)
+		goto exit;
+
+	/* read gyro register data */
+	data = (__be16 *)&st->buffer[0];
+	ret = regmap_bulk_read(st->map, reg, data, sizeof(*data));
+	if (ret)
+		goto exit;
+
+	*val = (int16_t)be16_to_cpup(data);
+	if (*val == INV_ICM42600_DATA_INVALID)
+		ret = -EINVAL;
+exit:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	return ret;
+}
+
+/* IIO format int + nano */
+static const int inv_icm42600_gyro_scale[] = {
+	/* +/- 2000dps => 0.001065264 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_2000DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_2000DPS + 1] = 1065264,
+	/* +/- 1000dps => 0.000532632 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_1000DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_1000DPS + 1] = 532632,
+	/* +/- 500dps => 0.000266316 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_500DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_500DPS + 1] = 266316,
+	/* +/- 250dps => 0.000133158 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_250DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_250DPS + 1] = 133158,
+	/* +/- 125dps => 0.000066579 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_125DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_125DPS + 1] = 66579,
+	/* +/- 62.5dps => 0.000033290 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_62_5DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_62_5DPS + 1] = 33290,
+	/* +/- 31.25dps => 0.000016645 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_31_25DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_31_25DPS + 1] = 16645,
+	/* +/- 15.625dps => 0.000008322 rad/s */
+	[2 * INV_ICM42600_GYRO_FS_15_625DPS] = 0,
+	[2 * INV_ICM42600_GYRO_FS_15_625DPS + 1] = 8322,
+};
+
+static int inv_icm42600_gyro_read_scale(struct inv_icm42600_state *st,
+					int *val, int *val2)
+{
+	unsigned int idx;
+
+	idx = st->conf.gyro.fs;
+
+	*val = inv_icm42600_gyro_scale[2 * idx];
+	*val2 = inv_icm42600_gyro_scale[2 * idx + 1];
+	return IIO_VAL_INT_PLUS_NANO;
+}
+
+static int inv_icm42600_gyro_write_scale(struct inv_icm42600_state *st,
+					 int val, int val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int idx;
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	int ret;
+
+	for (idx = 0; idx < ARRAY_SIZE(inv_icm42600_gyro_scale); idx += 2) {
+		if (val == inv_icm42600_gyro_scale[idx] &&
+		    val2 == inv_icm42600_gyro_scale[idx + 1])
+			break;
+	}
+	if (idx >= ARRAY_SIZE(inv_icm42600_gyro_scale))
+		return -EINVAL;
+
+	conf.fs = idx / 2;
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_set_gyro_conf(st, &conf, NULL);
+
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+/* IIO format int + micro */
+static const int inv_icm42600_gyro_odr[] = {
+	/* 12.5Hz */
+	12, 500000,
+	/* 25Hz */
+	25, 0,
+	/* 50Hz */
+	50, 0,
+	/* 100Hz */
+	100, 0,
+	/* 200Hz */
+	200, 0,
+	/* 1kHz */
+	1000, 0,
+	/* 2kHz */
+	2000, 0,
+	/* 4kHz */
+	4000, 0,
+};
+
+static const int inv_icm42600_gyro_odr_conv[] = {
+	INV_ICM42600_ODR_12_5HZ,
+	INV_ICM42600_ODR_25HZ,
+	INV_ICM42600_ODR_50HZ,
+	INV_ICM42600_ODR_100HZ,
+	INV_ICM42600_ODR_200HZ,
+	INV_ICM42600_ODR_1KHZ_LN,
+	INV_ICM42600_ODR_2KHZ_LN,
+	INV_ICM42600_ODR_4KHZ_LN,
+};
+
+static int inv_icm42600_gyro_read_odr(struct inv_icm42600_state *st,
+				      int *val, int *val2)
+{
+	unsigned int odr;
+	unsigned int i;
+
+	odr = st->conf.gyro.odr;
+
+	for (i = 0; i < ARRAY_SIZE(inv_icm42600_gyro_odr_conv); ++i) {
+		if (inv_icm42600_gyro_odr_conv[i] == odr)
+			break;
+	}
+	if (i >= ARRAY_SIZE(inv_icm42600_gyro_odr_conv))
+		return -EINVAL;
+
+	*val = inv_icm42600_gyro_odr[2 * i];
+	*val2 = inv_icm42600_gyro_odr[2 * i + 1];
+
+	return IIO_VAL_INT_PLUS_MICRO;
+}
+
+static int inv_icm42600_gyro_write_odr(struct iio_dev *indio_dev,
+				       int val, int val2)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	struct device *dev = regmap_get_device(st->map);
+	unsigned int idx;
+	struct inv_icm42600_sensor_conf conf = INV_ICM42600_SENSOR_CONF_INIT;
+	int ret;
+
+	for (idx = 0; idx < ARRAY_SIZE(inv_icm42600_gyro_odr); idx += 2) {
+		if (val == inv_icm42600_gyro_odr[idx] &&
+		    val2 == inv_icm42600_gyro_odr[idx + 1])
+			break;
+	}
+	if (idx >= ARRAY_SIZE(inv_icm42600_gyro_odr))
+		return -EINVAL;
+
+	conf.odr = inv_icm42600_gyro_odr_conv[idx / 2];
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_timestamp_update_odr(ts, inv_icm42600_odr_to_period(conf.odr),
+						iio_buffer_enabled(indio_dev));
+	if (ret)
+		goto out_unlock;
+
+	ret = inv_icm42600_set_gyro_conf(st, &conf, NULL);
+	if (ret)
+		goto out_unlock;
+	inv_icm42600_buffer_update_fifo_period(st);
+	inv_icm42600_buffer_update_watermark(st);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return ret;
+}
+
+/*
+ * Calibration bias values, IIO range format int + nano.
+ * Value is limited to +/-64dps coded on 12 bits signed. Step is 1/32 dps.
+ */
+static int inv_icm42600_gyro_calibbias[] = {
+	-1, 117010721,		/* min: -1.117010721 rad/s */
+	0, 545415,		/* step: 0.000545415 rad/s */
+	1, 116465306,		/* max: 1.116465306 rad/s */
+};
+
+static int inv_icm42600_gyro_read_offset(struct inv_icm42600_state *st,
+					 struct iio_chan_spec const *chan,
+					 int *val, int *val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	int64_t val64;
+	int32_t bias;
+	unsigned int reg;
+	int16_t offset;
+	uint8_t data[2];
+	int ret;
+
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_OFFSET_USER0;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_OFFSET_USER1;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_OFFSET_USER3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	ret = regmap_bulk_read(st->map, reg, st->buffer, sizeof(data));
+	memcpy(data, st->buffer, sizeof(data));
+
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	if (ret)
+		return ret;
+
+	/* 12 bits signed value */
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		offset = sign_extend32(((data[1] & 0x0F) << 8) | data[0], 11);
+		break;
+	case IIO_MOD_Y:
+		offset = sign_extend32(((data[0] & 0xF0) << 4) | data[1], 11);
+		break;
+	case IIO_MOD_Z:
+		offset = sign_extend32(((data[1] & 0x0F) << 8) | data[0], 11);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/*
+	 * convert raw offset to dps then to rad/s
+	 * 12 bits signed raw max 64 to dps: 64 / 2048
+	 * dps to rad: Pi / 180
+	 * result in nano (1000000000)
+	 * (offset * 64 * Pi * 1000000000) / (2048 * 180)
+	 */
+	val64 = (int64_t)offset * 64LL * 3141592653LL;
+	/* for rounding, add + or - divisor (2048 * 180) divided by 2 */
+	if (val64 >= 0)
+		val64 += 2048 * 180 / 2;
+	else
+		val64 -= 2048 * 180 / 2;
+	bias = div_s64(val64, 2048 * 180);
+	*val = bias / 1000000000L;
+	*val2 = bias % 1000000000L;
+
+	return IIO_VAL_INT_PLUS_NANO;
+}
+
+static int inv_icm42600_gyro_write_offset(struct inv_icm42600_state *st,
+					  struct iio_chan_spec const *chan,
+					  int val, int val2)
+{
+	struct device *dev = regmap_get_device(st->map);
+	int64_t val64, min, max;
+	unsigned int reg, regval;
+	int16_t offset;
+	int ret;
+
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		reg = INV_ICM42600_REG_OFFSET_USER0;
+		break;
+	case IIO_MOD_Y:
+		reg = INV_ICM42600_REG_OFFSET_USER1;
+		break;
+	case IIO_MOD_Z:
+		reg = INV_ICM42600_REG_OFFSET_USER3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* inv_icm42600_gyro_calibbias: min - step - max in nano */
+	min = (int64_t)inv_icm42600_gyro_calibbias[0] * 1000000000LL +
+	      (int64_t)inv_icm42600_gyro_calibbias[1];
+	max = (int64_t)inv_icm42600_gyro_calibbias[4] * 1000000000LL +
+	      (int64_t)inv_icm42600_gyro_calibbias[5];
+	val64 = (int64_t)val * 1000000000LL + (int64_t)val2;
+	if (val64 < min || val64 > max)
+		return -EINVAL;
+
+	/*
+	 * convert rad/s to dps then to raw value
+	 * rad to dps: 180 / Pi
+	 * dps to raw 12 bits signed, max 64: 2048 / 64
+	 * val in nano (1000000000)
+	 * val * 180 * 2048 / (Pi * 1000000000 * 64)
+	 */
+	val64 = val64 * 180LL * 2048LL;
+	/* for rounding, add + or - divisor (3141592653 * 64) divided by 2 */
+	if (val64 >= 0)
+		val64 += 3141592653LL * 64LL / 2LL;
+	else
+		val64 -= 3141592653LL * 64LL / 2LL;
+	offset = div64_s64(val64, 3141592653LL * 64LL);
+
+	/* clamp value limited to 12 bits signed */
+	if (offset < -2048)
+		offset = -2048;
+	else if (offset > 2047)
+		offset = 2047;
+
+	pm_runtime_get_sync(dev);
+	mutex_lock(&st->lock);
+
+	switch (chan->channel2) {
+	case IIO_MOD_X:
+		/* OFFSET_USER1 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER1,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = offset & 0xFF;
+		st->buffer[1] = (regval & 0xF0) | ((offset & 0xF00) >> 8);
+		break;
+	case IIO_MOD_Y:
+		/* OFFSET_USER1 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER1,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = ((offset & 0xF00) >> 4) | (regval & 0x0F);
+		st->buffer[1] = offset & 0xFF;
+		break;
+	case IIO_MOD_Z:
+		/* OFFSET_USER4 register is shared */
+		ret = regmap_read(st->map, INV_ICM42600_REG_OFFSET_USER4,
+				  &regval);
+		if (ret)
+			goto out_unlock;
+		st->buffer[0] = offset & 0xFF;
+		st->buffer[1] = (regval & 0xF0) | ((offset & 0xF00) >> 8);
+		break;
+	default:
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	ret = regmap_bulk_write(st->map, reg, st->buffer, 2);
+
+out_unlock:
+	mutex_unlock(&st->lock);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+	return ret;
+}
+
+static int inv_icm42600_gyro_read_raw(struct iio_dev *indio_dev,
+				      struct iio_chan_spec const *chan,
+				      int *val, int *val2, long mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int16_t data;
+	int ret;
+
+	switch (chan->type) {
+	case IIO_ANGL_VEL:
+		break;
+	case IIO_TEMP:
+		return inv_icm42600_temp_read_raw(indio_dev, chan, val, val2, mask);
+	default:
+		return -EINVAL;
+	}
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_gyro_read_sensor(st, chan, &data);
+		iio_device_release_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		*val = data;
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		return inv_icm42600_gyro_read_scale(st, val, val2);
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return inv_icm42600_gyro_read_odr(st, val, val2);
+	case IIO_CHAN_INFO_CALIBBIAS:
+		return inv_icm42600_gyro_read_offset(st, chan, val, val2);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_gyro_read_avail(struct iio_dev *indio_dev,
+					struct iio_chan_spec const *chan,
+					const int **vals,
+					int *type, int *length, long mask)
+{
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		*vals = inv_icm42600_gyro_scale;
+		*type = IIO_VAL_INT_PLUS_NANO;
+		*length = ARRAY_SIZE(inv_icm42600_gyro_scale);
+		return IIO_AVAIL_LIST;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*vals = inv_icm42600_gyro_odr;
+		*type = IIO_VAL_INT_PLUS_MICRO;
+		*length = ARRAY_SIZE(inv_icm42600_gyro_odr);
+		return IIO_AVAIL_LIST;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		*vals = inv_icm42600_gyro_calibbias;
+		*type = IIO_VAL_INT_PLUS_NANO;
+		return IIO_AVAIL_RANGE;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_gyro_write_raw(struct iio_dev *indio_dev,
+				       struct iio_chan_spec const *chan,
+				       int val, int val2, long mask)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_gyro_write_scale(st, val, val2);
+		iio_device_release_direct_mode(indio_dev);
+		return ret;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return inv_icm42600_gyro_write_odr(indio_dev, val, val2);
+	case IIO_CHAN_INFO_CALIBBIAS:
+		ret = iio_device_claim_direct_mode(indio_dev);
+		if (ret)
+			return ret;
+		ret = inv_icm42600_gyro_write_offset(st, chan, val, val2);
+		iio_device_release_direct_mode(indio_dev);
+		return ret;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_gyro_write_raw_get_fmt(struct iio_dev *indio_dev,
+					       struct iio_chan_spec const *chan,
+					       long mask)
+{
+	if (chan->type != IIO_ANGL_VEL)
+		return -EINVAL;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		return IIO_VAL_INT_PLUS_NANO;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		return IIO_VAL_INT_PLUS_NANO;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int inv_icm42600_gyro_hwfifo_set_watermark(struct iio_dev *indio_dev,
+						  unsigned int val)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	mutex_lock(&st->lock);
+
+	st->fifo.watermark.gyro = val;
+	ret = inv_icm42600_buffer_update_watermark(st);
+
+	mutex_unlock(&st->lock);
+
+	return ret;
+}
+
+static int inv_icm42600_gyro_hwfifo_flush(struct iio_dev *indio_dev,
+					  unsigned int count)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	int ret;
+
+	if (count == 0)
+		return 0;
+
+	mutex_lock(&st->lock);
+
+	ret = inv_icm42600_buffer_hwfifo_flush(st, count);
+	if (!ret)
+		ret = st->fifo.nb.gyro;
+
+	mutex_unlock(&st->lock);
+
+	return ret;
+}
+
+static const struct iio_info inv_icm42600_gyro_info = {
+	.read_raw = inv_icm42600_gyro_read_raw,
+	.read_avail = inv_icm42600_gyro_read_avail,
+	.write_raw = inv_icm42600_gyro_write_raw,
+	.write_raw_get_fmt = inv_icm42600_gyro_write_raw_get_fmt,
+	.debugfs_reg_access = inv_icm42600_debugfs_reg,
+	.update_scan_mode = inv_icm42600_gyro_update_scan_mode,
+	.hwfifo_set_watermark = inv_icm42600_gyro_hwfifo_set_watermark,
+	.hwfifo_flush_to_buffer = inv_icm42600_gyro_hwfifo_flush,
+};
+
+struct iio_dev *inv_icm42600_gyro_init(struct inv_icm42600_state *st)
+{
+	struct device *dev = regmap_get_device(st->map);
+	const char *name;
+	struct inv_icm42600_timestamp *ts;
+	struct iio_dev *indio_dev;
+	int ret;
+
+
+	name = devm_kasprintf(dev, GFP_KERNEL, "%s-gyro", st->name);
+	if (!name)
+		return ERR_PTR(-ENOMEM);
+
+	indio_dev = devm_iio_device_alloc(dev, sizeof(*ts));
+	if (!indio_dev)
+		return ERR_PTR(-ENOMEM);
+
+	ts = iio_priv(indio_dev);
+	inv_icm42600_timestamp_init(ts, inv_icm42600_odr_to_period(st->conf.gyro.odr));
+
+	iio_device_set_drvdata(indio_dev, st);
+	indio_dev->name = name;
+	indio_dev->info = &inv_icm42600_gyro_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = inv_icm42600_gyro_channels;
+	indio_dev->num_channels = ARRAY_SIZE(inv_icm42600_gyro_channels);
+	indio_dev->available_scan_masks = inv_icm42600_gyro_scan_masks;
+	indio_dev->setup_ops = &inv_icm42600_buffer_ops;
+
+// FIXME! ACHEUL
+#if 0
+	ret = devm_iio_kfifo_buffer_setup(dev, indio_dev,
+					  INDIO_BUFFER_SOFTWARE,
+					  &inv_icm42600_buffer_ops);
+	if (ret)
+		return ERR_PTR(ret);
+#endif 
+
+	ret = devm_iio_device_register(dev, indio_dev);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return indio_dev;
+}
+
+int inv_icm42600_gyro_parse_fifo(struct iio_dev *indio_dev)
+{
+	struct inv_icm42600_state *st = iio_device_get_drvdata(indio_dev);
+	struct inv_icm42600_timestamp *ts = iio_priv(indio_dev);
+	ssize_t i, size;
+	unsigned int no;
+	const void *accel, *gyro, *timestamp;
+	const int8_t *temp;
+	unsigned int odr;
+	int64_t ts_val;
+	struct inv_icm42600_gyro_buffer buffer;
+
+	/* parse all fifo packets */
+	for (i = 0, no = 0; i < st->fifo.count; i += size, ++no) {
+		size = inv_icm42600_fifo_decode_packet(&st->fifo.data[i],
+				&accel, &gyro, &temp, &timestamp, &odr);
+		/* quit if error or FIFO is empty */
+		if (size <= 0)
+			return size;
+
+		/* skip packet if no gyro data or data is invalid */
+		if (gyro == NULL || !inv_icm42600_fifo_is_data_valid(gyro))
+			continue;
+
+		/* update odr */
+		if (odr & INV_ICM42600_SENSOR_GYRO)
+			inv_icm42600_timestamp_apply_odr(ts, st->fifo.period,
+							 st->fifo.nb.total, no);
+
+		/* buffer is copied to userspace, zeroing it to avoid any data leak */
+		memset(&buffer, 0, sizeof(buffer));
+		memcpy(&buffer.gyro, gyro, sizeof(buffer.gyro));
+		/* convert 8 bits FIFO temperature in high resolution format */
+		buffer.temp = temp ? (*temp * 64) : 0;
+		ts_val = inv_icm42600_timestamp_pop(ts);
+		iio_push_to_buffers_with_timestamp(indio_dev, &buffer, ts_val);
+	}
+
+	return 0;
+}
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_i2c.c kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_i2c.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_i2c.c	1969-12-31 19:00:00.000000000 -0500
+++ kernel/msm-4.19/drivers/iio/imu/inv_icm42600/inv_icm42600_i2c.c	2024-05-29 22:10:12.849805087 -0400
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 InvenSense, Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/property.h>
+
+#include "inv_icm42600.h"
+
+static int inv_icm42600_i2c_bus_setup(struct inv_icm42600_state *st)
+{
+	unsigned int mask, val;
+	int ret;
+
+	/*
+	 * setup interface registers
+	 * This register write to REG_INTF_CONFIG6 enables a spike filter that
+	 * is impacting the line and can prevent the I2C ACK to be seen by the
+	 * controller. So we don't test the return value.
+	 */
+	regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG6,
+			   INV_ICM42600_INTF_CONFIG6_MASK,
+			   INV_ICM42600_INTF_CONFIG6_I3C_EN);
+
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG4,
+				 INV_ICM42600_INTF_CONFIG4_I3C_BUS_ONLY, 0);
+	if (ret)
+		return ret;
+
+	/* set slew rates for I2C and SPI */
+	mask = INV_ICM42600_DRIVE_CONFIG_I2C_MASK |
+	       INV_ICM42600_DRIVE_CONFIG_SPI_MASK;
+	val = INV_ICM42600_DRIVE_CONFIG_I2C(INV_ICM42600_SLEW_RATE_12_36NS) |
+	      INV_ICM42600_DRIVE_CONFIG_SPI(INV_ICM42600_SLEW_RATE_12_36NS);
+	ret = regmap_update_bits(st->map, INV_ICM42600_REG_DRIVE_CONFIG,
+				 mask, val);
+	if (ret)
+		return ret;
+
+	/* disable SPI bus */
+	return regmap_update_bits(st->map, INV_ICM42600_REG_INTF_CONFIG0,
+				  INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_MASK,
+				  INV_ICM42600_INTF_CONFIG0_UI_SIFS_CFG_SPI_DIS);
+}
+
+static int inv_icm42600_probe(struct i2c_client *client)
+{
+	const void *match;
+	enum inv_icm42600_chip chip;
+	struct regmap *regmap;
+    char message[256];
+    int ret = 0;
+
+    sprintf(message, "%s:%d ACHEUL\n", __FUNCTION__, __LINE__);
+
+    printk     ("printk                   : %s", message);
+    dev_err    (&client->dev, "dev_err    : %s", message);
+    dev_warn   (&client->dev, "dev_warning: %s", message);
+    dev_notice (&client->dev, "dev_notice : %s", message);
+    dev_info   (&client->dev, "dev_info   : %s", message);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK)) {
+        printk("%s:%d, ACHEUL, error, i2c functionality", __FUNCTION__, __LINE__);
+		return -ENOTSUPP;
+    }
+
+	match = device_get_match_data(&client->dev);
+	if (!match){
+        printk("%s:%d, ACHEUL, error, no match", __FUNCTION__, __LINE__);
+		return -EINVAL;
+    }
+	chip = (enum inv_icm42600_chip)match;
+
+	regmap = devm_regmap_init_i2c(client, &inv_icm42600_regmap_config);
+	if (IS_ERR(regmap)) {
+        printk("%s:%d, ACHEUL, error config regmap", __FUNCTION__, __LINE__);
+		return PTR_ERR(regmap);
+    }
+
+	ret = inv_icm42600_core_probe(regmap, chip, client->irq, inv_icm42600_i2c_bus_setup);
+
+    printk("%s:%d, ACHEUL, ret: %d", __FUNCTION__, __LINE__, ret);
+    return ret;
+
+}// inv_icm42600_probe
+
+static const struct of_device_id inv_icm42600_of_matches[] = {
+	{
+		.compatible = "invensense,icm42600",
+		.data = (void *)INV_CHIP_ICM42600,
+	}, {
+		.compatible = "invensense,icm42602",
+		.data = (void *)INV_CHIP_ICM42602,
+	}, {
+		.compatible = "invensense,icm42605",
+		.data = (void *)INV_CHIP_ICM42605,
+	}, {
+		.compatible = "invensense,icm42622",
+		.data = (void *)INV_CHIP_ICM42622,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, inv_icm42600_of_matches);
+
+static struct i2c_driver inv_icm42600_driver = {
+	.driver = {
+		.name = "inv-icm42600-i2c",
+		.of_match_table = inv_icm42600_of_matches,
+		.pm = &inv_icm42600_pm_ops,
+	},
+	.probe_new = inv_icm42600_probe,
+};
+module_i2c_driver(inv_icm42600_driver);
+
+MODULE_AUTHOR("InvenSense, Inc.");
+MODULE_DESCRIPTION("InvenSense ICM-426xx I2C driver");
+MODULE_LICENSE("GPL");
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: inv_mpu6050
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/Kconfig kernel/msm-4.19/drivers/iio/imu/Kconfig
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/Kconfig	2024-05-28 20:43:09.117068295 -0400
+++ kernel/msm-4.19/drivers/iio/imu/Kconfig	2024-05-29 22:10:12.865805228 -0400
@@ -41,6 +41,11 @@
 source "drivers/iio/imu/inv_mpu6050/Kconfig"
 source "drivers/iio/imu/st_lsm6dsx/Kconfig"
 
+########################################################
+## ACHEUL
+########################################################
+source "drivers/iio/imu/inv_icm42600/Kconfig"
+
 endmenu
 
 config IIO_ADIS_LIB
@@ -54,3 +59,4 @@
 	help
 	  A set of buffer helper functions for the Analog Devices ADIS* device
 	  family.
+
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: kmx61.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/Makefile kernel/msm-4.19/drivers/iio/imu/Makefile
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu/Makefile	2024-05-28 20:43:09.117068295 -0400
+++ kernel/msm-4.19/drivers/iio/imu/Makefile	2024-05-29 22:10:12.869805263 -0400
@@ -9,6 +9,11 @@
 obj-$(CONFIG_ADIS16400) += adis16400.o
 obj-$(CONFIG_ADIS16480) += adis16480.o
 
+#########################################
+## ACHEUL
+obj-y += inv_icm42600/
+#########################################
+
 adis_lib-y += adis.o
 adis_lib-$(CONFIG_IIO_ADIS_LIB_BUFFER) += adis_trigger.o
 adis_lib-$(CONFIG_IIO_ADIS_LIB_BUFFER) += adis_buffer.o
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/imu: st_lsm6dsx
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-buffer.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-configfs.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/industrialio-core.c kernel/msm-4.19/drivers/iio/industrialio-core.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/industrialio-core.c	2024-05-28 20:43:10.341081434 -0400
+++ kernel/msm-4.19/drivers/iio/industrialio-core.c	2024-05-29 22:10:12.841805017 -0400
@@ -1446,6 +1446,8 @@
 	struct iio_dev *dev;
 	size_t alloc_size;
 
+    printk("%s:%d, ACHEUL, size: %d", __FUNCTION__, __LINE__, sizeof_priv);
+
 	alloc_size = sizeof(struct iio_dev);
 	if (sizeof_priv) {
 		alloc_size = ALIGN(alloc_size, IIO_ALIGN);
@@ -1454,9 +1456,14 @@
 	/* ensure 32-byte alignment of whole construct ? */
 	alloc_size += IIO_ALIGN - 1;
 
+    printk("%s:%d, ACHEUL, real size: %d", __FUNCTION__, __LINE__, alloc_size);
+
 	dev = kzalloc(alloc_size, GFP_KERNEL);
 
 	if (dev) {
+
+
+        printk("%s:%d, ACHEUL pointer OK", __FUNCTION__, __LINE__);
 		dev->dev.groups = dev->groups;
 		dev->dev.type = &iio_device_type;
 		dev->dev.bus = &iio_bus_type;
@@ -1466,6 +1473,7 @@
 		mutex_init(&dev->info_exist_lock);
 		INIT_LIST_HEAD(&dev->channel_attr_list);
 
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 		dev->id = ida_simple_get(&iio_ida, 0, 0, GFP_KERNEL);
 		if (dev->id < 0) {
 			/* cannot use a dev_err as the name isn't available */
@@ -1473,10 +1481,13 @@
 			kfree(dev);
 			return NULL;
 		}
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 		dev_set_name(&dev->dev, "iio:device%d", dev->id);
 		INIT_LIST_HEAD(&dev->buffer_list);
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	}
 
+    printk("%s:%d, ACHEUL out", __FUNCTION__, __LINE__);
 	return dev;
 }
 EXPORT_SYMBOL(iio_device_alloc);
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-event.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-sw-device.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-sw-trigger.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-trigger.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: industrialio-triggered-event.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: inkern.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: acpi-als.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: adjd_s311.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: al3320a.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: apds9300.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: apds9960.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: bh1750.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: bh1780.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: cm32181.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: cm3232.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: cm3323.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: cm3605.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: cm36651.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: cros_ec_light_prox.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: gp2ap020a00f.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: hid-sensor-als.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: hid-sensor-prox.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: isl29018.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: isl29028.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: isl29125.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: jsa1212.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light/Kconfig kernel/msm-4.19/drivers/iio/light/Kconfig
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light/Kconfig	2024-05-28 20:43:10.545083623 -0400
+++ kernel/msm-4.19/drivers/iio/light/Kconfig	2024-05-29 22:10:12.881805368 -0400
@@ -3,6 +3,7 @@
 # Light sensors
 #
 # When adding new entries keep the list in alphabetical order
+# ACHEUL
 
 menu "Light sensors"
 
@@ -460,6 +461,16 @@
 	 To compile this driver as a module, choose M here: the
 	 module will be called vcnl4000.
 
+config VCNL3040
+	tristate "VCNL3040 combined ALS and proximity sensor"
+	depends on I2C
+	help
+	 Say Y here if you want to build a driver for the Vishay VCNL3040,
+	 proximity sensor.
+
+	 To compile this driver as a module, choose M here: the
+	 module will be called VCNL3040.
+
 config VEML6070
 	tristate "VEML6070 UV A light sensor"
 	depends on I2C
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: lm3533-als.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: ltr501.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: lv0104cs.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: max44000.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: opt3001.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: pa12203001.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: rpr0521.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: si1133.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: si1145.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: stk3310.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: st_uvis25_core.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: st_uvis25.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: st_uvis25_i2c.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: st_uvis25_spi.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: tcs3414.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: tcs3472.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: tsl2563.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: tsl2583.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: tsl2772.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: tsl4531.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: us5182d.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light/vcnl4000.c kernel/msm-4.19/drivers/iio/light/vcnl4000.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light/vcnl4000.c	2024-05-28 20:43:11.381092597 -0400
+++ kernel/msm-4.19/drivers/iio/light/vcnl4000.c	2024-05-29 22:10:12.877805333 -0400
@@ -99,6 +99,17 @@
 {
 	int ret, prod_id;
 
+    char message[256];
+
+    sprintf(message, "%s:%d ACHEUL\n", __FUNCTION__, __LINE__);
+
+    printk     ("printk                         : %s", message);
+    dev_crit   (&data->client->dev, "dev_crit   : %s", message);
+    dev_err    (&data->client->dev, "dev_err    : %s", message);
+    dev_warn   (&data->client->dev, "dev_warning: %s", message);
+    dev_notice (&data->client->dev, "dev_notice : %s", message);
+    dev_info   (&data->client->dev, "dev_info   : %s", message);
+
 	ret = i2c_smbus_read_byte_data(data->client, VCNL4000_PROD_REV);
 	if (ret < 0)
 		return ret;
@@ -130,22 +141,33 @@
 {
 	int ret;
 
+    printk("%s:%d ACHEUL\n", __FUNCTION__, __LINE__);
+
 	ret = i2c_smbus_read_word_data(data->client, VCNL4200_DEV_ID);
-	if (ret < 0)
+	if (ret < 0) {
+        printk("%s:%d ACHEUL, error, failed to read i2c: %d, error: %d", __FUNCTION__, __LINE__, VCNL4200_DEV_ID, ret);
 		return ret;
+    }
 
-	if ((ret & 0xff) != VCNL4200_PROD_ID)
+	if ((ret & 0xff) != VCNL4200_PROD_ID){
+        printk("%s:%d ACHEUL, error, invalid prod id, got: 0x%02X, looking for: 0x%02X", __FUNCTION__, __LINE__, ret & 0xFF,  VCNL4200_PROD_ID);
 		return -ENODEV;
+    }
 
 	data->rev = (ret >> 8) & 0xf;
 
 	/* Set defaults and enable both channels */
 	ret = i2c_smbus_write_byte_data(data->client, VCNL4200_AL_CONF, 0x00);
-	if (ret < 0)
+	if (ret < 0) {
+        printk("%s:%d ACHEUL, error, invalid VCNL4200_AL_CONF: 0x%02X", __FUNCTION__, __LINE__, VCNL4200_AL_CONF);
 		return ret;
+    };
+
 	ret = i2c_smbus_write_byte_data(data->client, VCNL4200_PS_CONF1, 0x00);
-	if (ret < 0)
+	if (ret < 0) {
+        printk("%s:%d ACHEUL, error, invalid VCNL4200_PS_CONF1: 0x%02X", __FUNCTION__, __LINE__, VCNL4200_PS_CONF1);
 		return ret;
+    }
 
 	data->al_scale = 24000;
 	data->vcnl4200_al.reg = VCNL4200_AL_DATA;
@@ -158,6 +180,7 @@
 	mutex_init(&data->vcnl4200_al.lock);
 	mutex_init(&data->vcnl4200_ps.lock);
 
+    printk("%s:%d ACHEUL success\n", __FUNCTION__, __LINE__);
 	return 0;
 };
 
@@ -167,6 +190,7 @@
 	int tries = 20;
 	__be16 buf;
 	int ret;
+    printk("%s:%d ACHEUL\n", __FUNCTION__, __LINE__);
 
 	mutex_lock(&data->vcnl4000_lock);
 
@@ -213,6 +237,7 @@
 	int ret;
 	s64 delta;
 	ktime_t next_measurement;
+    printk("%s:%d ACHEUL\n", __FUNCTION__, __LINE__);
 
 	mutex_lock(&chan->lock);
 
@@ -336,22 +361,28 @@
 	struct iio_dev *indio_dev;
 	int ret;
 
+    printk ("%s: %d: ACHEUL", __FUNCTION__, __LINE__);
+
 	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
 	if (!indio_dev)
 		return -ENOMEM;
 
+    printk ("%s: %d: ACHEUL", __FUNCTION__, __LINE__);
+
 	data = iio_priv(indio_dev);
 	i2c_set_clientdata(client, indio_dev);
 	data->client = client;
 	data->id = id->driver_data;
 	data->chip_spec = &vcnl4000_chip_spec_cfg[data->id];
 
+    printk ("%s: %d: ACHEUL", __FUNCTION__, __LINE__);
 	ret = data->chip_spec->init(data);
-	if (ret < 0)
+	if (ret < 0){
+        printk("%s: %d, ACHEUL error init: %d", __FUNCTION__, __LINE__, ret);
 		return ret;
+    }
 
-	dev_dbg(&client->dev, "%s Ambient light/proximity sensor, Rev: %02x\n",
-		data->chip_spec->prod, data->rev);
+	printk("%s: %d, ACHEUL, %s Ambient light/proximity sensor, Rev: %02x", __FUNCTION__, __LINE__, data->chip_spec->prod, data->rev);
 
 	indio_dev->dev.parent = &client->dev;
 	indio_dev->info = &vcnl4000_info;
@@ -360,7 +391,11 @@
 	indio_dev->name = VCNL4000_DRV_NAME;
 	indio_dev->modes = INDIO_DIRECT_MODE;
 
-	return devm_iio_device_register(&client->dev, indio_dev);
+    printk ("%s:%d, before geristering device", __FUNCTION__, __LINE__);
+    ret = devm_iio_device_register(&client->dev, indio_dev);
+
+    printk ("%s:%d, device registered: %d", __FUNCTION__, __LINE__, ret);
+	return ret;
 }
 
 static struct i2c_driver vcnl4000_driver = {
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: veml6070.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: vl6180.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/light: zopt2201.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: magnetometer
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: multiplexer
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: orientation
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: potentiometer
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: potentiostat
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: pressure
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: as3935.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: isl29501.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/Kconfig kernel/msm-4.19/drivers/iio/proximity/Kconfig
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/Kconfig	2024-05-28 20:43:12.101100326 -0400
+++ kernel/msm-4.19/drivers/iio/proximity/Kconfig	2024-05-29 22:10:12.885805403 -0400
@@ -1,9 +1,21 @@
 #
 # Proximity sensors
 #
+# ACHEUL
 
 menu "Lightning sensors"
 
+config VCNL3040
+	tristate "VCNL3040 combined ALS and proximity sensor"
+    select REGMAP_I2C
+	depends on I2C
+	help
+	 Say Y here if you want to build a driver for the Vishay VCNL3040,
+	 proximity sensor.
+
+	 To compile this driver as a module, choose M here: the
+	 module will be called VCNL3040.
+
 config AS3935
 	tristate "AS3935 Franklin lightning sensor"
 	select IIO_BUFFER
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/Makefile kernel/msm-4.19/drivers/iio/proximity/Makefile
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/Makefile	2024-05-28 20:43:12.101100326 -0400
+++ kernel/msm-4.19/drivers/iio/proximity/Makefile	2024-05-29 22:10:12.897805508 -0400
@@ -2,12 +2,13 @@
 #
 # Makefile for IIO proximity sensors
 #
-
+# ACHEUL
 # When adding new entries keep the list in alphabetical order
 obj-$(CONFIG_AS3935)		+= as3935.o
 obj-$(CONFIG_ISL29501)		+= isl29501.o
 obj-$(CONFIG_LIDAR_LITE_V2)	+= pulsedlight-lidar-lite-v2.o
 obj-$(CONFIG_RFD77402)		+= rfd77402.o
-obj-$(CONFIG_SRF04)		+= srf04.o
-obj-$(CONFIG_SRF08)		+= srf08.o
+obj-$(CONFIG_SRF04)		    += srf04.o
+obj-$(CONFIG_SRF08)		    += srf08.o
 obj-$(CONFIG_SX9500)		+= sx9500.o
+obj-$(CONFIG_VCNL3040)      += vcnl3040.o
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: pulsedlight-lidar-lite-v2.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: rfd77402.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: srf04.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: srf08.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity: sx9500.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/vcnl3040.c kernel/msm-4.19/drivers/iio/proximity/vcnl3040.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio/proximity/vcnl3040.c	1969-12-31 19:00:00.000000000 -0500
+++ kernel/msm-4.19/drivers/iio/proximity/vcnl3040.c	2024-05-29 22:10:12.889805438 -0400
@@ -0,0 +1,694 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Support for Vishay VCNL3040 proximity sensor on i2c bus.
+ * Based on Vishay VCNL4000 driver code.
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/regmap.h>
+#include <linux/interrupt.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/events.h>
+
+#define VCNL3040_PROD_ID	0x0186
+#define LED_MASK_VALUE      0xF8FF
+
+enum VCNL3040_REGS {
+    PS_CONF1_2   = 0x03,
+    PS_CONF3_MS  = 0x04,
+    PS_CANCEL    = 0x05,
+    PS_LOW_THDL  = 0x06,
+    PS_HIGH_THDL = 0x07,
+    PS_DATA      = 0x08,
+    INT_FLAGS    = 0x0B,
+    DEVICE_ID    = 0x0C
+};
+
+enum VCNL3040_PARAM
+{
+    ///LED current settings
+    LED_CURRENT_50mA = 0x00,
+    LED_CURRENT_75mA = 0x01,
+    LED_CURRENT_120mA = 0x02,
+    LED_CURRENT_140mA = 0x03,
+    LED_CURRENT_160mA = 0x04,
+    LED_CURRENT_180mA = 0x05,
+    LED_CURRENT_200mA = 0x07,
+
+    ///Duty cycle for sensors LED
+    PS_DUTY_40 = 0x00,
+    PS_DUTY_80 = 0x01,
+    PS_DUTY_160 = 0x02,
+    PS_DUTY_320 = 0x03,
+
+    ///Measurement integration time 1T0 - IT = 1 -  125us (application note page 5 )
+    PS_IT_1T0 = 0x00,
+    PS_IT_1T5 = 0x01,
+    PS_IT_2T0 = 0x02,
+    PS_IT_2T5 = 0x03,
+    PS_IT_3T0 = 0x04,
+    PS_IT_3T5 = 0x05,
+    PS_IT_4T0 = 0x06,
+    PS_IT_8T0 = 0x07,
+
+    ///Interupt persistance setting - how many consecutive measruements
+    ///have to be made in interupt range to trigger interupt (datasheet page 11)
+    PS_PERS_1 = 0x00,
+    PS_PERS_2 = 0x01,
+    PS_PERS_3 = 0x02,
+    PS_PERS_4 = 0x03,
+
+    ///Iterupt modes
+    PS_INT_DISABLED = 0x00,
+    PS_INT_CLOSING = 0x01,
+    PS_INT_AWAY = 0x02,
+    PS_INT_CLOSING_AWAY = 0x03,
+};
+
+
+#define VCNL_COMMAND		0x80 /* Command register */
+#define VCNL_PROD_REV		0x81 /* Product ID and Revision ID */
+#define VCNL_PROXIMITY_RATE	0x82 /* Rate of Proximity Measurement */
+#define VCNL_LED_CURRENT	0x83 /* IR LED current for proximity mode */
+#define VCNL_PS_RESULT_HI	0x87 /* Proximity result register, MSB */
+#define VCNL_PS_RESULT_LO	0x88 /* Proximity result register, LSB */
+#define VCNL_PS_ICR		    0x89 /* Interrupt Control Register */
+#define VCNL_PS_LO_THR_HI	0x8a /* High byte of low threshold value */
+#define VCNL_PS_LO_THR_LO	0x8b /* Low byte of low threshold value */
+#define VCNL_PS_HI_THR_HI	0x8c /* High byte of high threshold value */
+#define VCNL_PS_HI_THR_LO	0x8d /* Low byte of high threshold value */
+#define VCNL_ISR		    0x8e /* Interrupt Status Register */
+#define VCNL_PS_MOD_ADJ		0x8f /* Proximity Modulator Timing Adjustment */
+
+/* Bit masks for COMMAND register */
+#define VCNL_PS_RDY		BIT(5) /* proximity data ready? */
+#define VCNL_PS_OD		BIT(3) /* start on-demand proximity
+					* measurement
+					*/
+
+/* Enables periodic proximity measurement */
+#define VCNL_PS_EN		BIT(1)
+
+/* Enables state machine and LP oscillator for self timed  measurements */
+#define VCNL_PS_SELFTIMED_EN	BIT(0)
+
+/* Bit masks for ICR */
+
+/* Enable interrupts on low or high thresholds */
+#define  VCNL_ICR_THRES_EN	BIT(1)
+
+/* Bit masks for ISR */
+#define VCNL_INT_TH_HI		BIT(0)	/* High threshold hit */
+#define VCNL_INT_TH_LOW		BIT(1)	/* Low threshold hit */
+
+#define VCNL_ON_DEMAND_TIMEOUT_US	100000
+#define VCNL_POLL_US			20000
+
+static const int vcnl3040_prox_sampling_frequency[][2] = {
+	{1, 950000},
+	{3, 906250},
+	{7, 812500},
+	{16, 625000},
+	{31, 250000},
+	{62, 500000},
+	{125, 0},
+	{250, 0},
+};
+
+/**
+ * struct vcnl3040_data - vcnl3040 specific data.
+ * @regmap:	device register map.
+ * @dev:	vcnl3040 device.
+ * @rev:	revision id.
+ * @lock:	lock for protecting access to device hardware registers.
+ * @buf:	DMA safe __be16 buffer.
+ */
+struct vcnl3040_data {
+	struct regmap *regmap;
+	struct device *dev;
+    struct i2c_client *client;
+	u8 rev;
+	struct mutex lock;
+	__be16 buf ____cacheline_aligned;
+};
+
+/**
+ * struct vcnl3040_property - vcnl3040 property.
+ * @name:	property name.
+ * @reg:	i2c register offset.
+ * @conversion_func:	conversion function.
+ */
+struct vcnl3040_property {
+	const char *name;
+	u32 reg;
+	u32 (*conversion_func)(u32 *val);
+};
+
+uint16_t vcnl3040_read_register(struct vcnl3040_data *data, uint8_t reg){
+
+    uint16_t ret;
+
+	ret = i2c_smbus_read_word_data(data->client, reg);
+
+    //printk("%s:%d, ACHEUL reading vcnl3040 reg[0x%02X]: 0x%04X", __FUNCTION__, __LINE__, reg, ret);
+
+    return ret;
+}// vcnl3040_read_register
+
+uint16_t vcnl3040_write_register(struct vcnl3040_data *data, uint8_t reg, uint16_t value){
+
+    uint16_t ret;
+
+	ret = i2c_smbus_write_word_data(data->client, reg, value);
+
+    //printk("%s:%d, ACHEUL writing vcnl3040 reg[0x%02X]: 0x%04X, ret: %d", __FUNCTION__, __LINE__, reg, value, ret);
+
+    return ret;
+}// vcnl3040_write_register
+
+uint16_t vcnl3040_read_sensor(struct vcnl3040_data *data) {
+
+    uint16_t sensor_value = vcnl3040_read_register(data, PS_DATA);
+
+    printk("%s:%d, ACHEUL, sensor value 0x%04X", __FUNCTION__, __LINE__, sensor_value);
+
+    return sensor_value;
+}// vcnl3040_read_sensor
+
+static int vcnl3040_start(struct vcnl3040_data *data) {
+    uint16_t current_settings = vcnl3040_read_register(data, PS_CONF1_2);
+    uint16_t new_settings     = current_settings & 0xFFFE;
+
+    printk("%s:%d, ACHEUL, starting proximity sensor from: 0x%04X to 0x%04X", __FUNCTION__, __LINE__, current_settings, new_settings);
+
+    vcnl3040_write_register(data, PS_CONF1_2, new_settings);
+
+    return 0;
+}// vcnl3040_start
+
+#if 0
+static int vcnl3040_stop(struct vcnl3040_data *data) {
+    uint16_t current_settings = vcnl3040_read_register(data, PS_CONF3_MS);
+    uint16_t new_settings     = current_settings | 0x0001;
+
+    printk("%s:%d, ACHEUL, stopping proximity sensor from: 0x%04X to 0x%04X", __FUNCTION__, __LINE__, current_settings, new_settings);
+
+    vcnl3040_write_register(data, PS_CONF3_MS, new_settings);
+
+    return 0;
+}// vcnl3040_stop
+#endif // 0
+
+static int vcnl3040_show_config(struct vcnl3040_data *data) {
+    uint16_t config;
+    uint8_t  i;
+
+    printk("%s:%d, ACHEUL, =============================================", __FUNCTION__, __LINE__);
+    for (i = PS_CONF1_2; i <= PS_HIGH_THDL; i++) {
+
+        config = vcnl3040_read_register(data, i);
+        printk("%s:%d, ACHEUL, config: 0x%02X: 0x%04X", __FUNCTION__, __LINE__, i, config);
+    }
+    printk("%s:%d, ACHEUL, =============================================", __FUNCTION__, __LINE__);
+
+    return 0;
+
+}// vcnl3040_show_config
+
+static int vcnl3040_set_led(struct vcnl3040_data *data, uint8_t led_setting) {
+    uint16_t current_led_setting = vcnl3040_read_register(data, PS_CONF3_MS) | LED_MASK_VALUE;
+    uint16_t new_led_setting     = current_led_setting | (led_setting << 8);
+
+    printk("%s:%d, ACHEUL, setting led from: 0x%04X to 0x%04X", __FUNCTION__, __LINE__, current_led_setting, new_led_setting);
+
+    vcnl3040_write_register(data, PS_CONF3_MS, new_led_setting);
+
+    return 0;
+}// vcnl3040_set_led
+
+static int vcnl3040_init(struct vcnl3040_data *data) {
+	uint16_t reg;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+    reg = vcnl3040_read_register(data, DEVICE_ID);
+
+    if (reg != VCNL3040_PROD_ID) {
+        printk("%s:%d, ACHEUL invalid product id: 0x%04X, looking for: 0x%04X", __FUNCTION__, __LINE__, reg, VCNL3040_PROD_ID);
+		return -ENODEV;
+    }
+
+    vcnl3040_write_register(data, PS_CONF1_2  , 0x0003); // PS shut down 0x0001, PS_IT = (0 : 0 : 1) = 1.5T 0x0002
+    vcnl3040_write_register(data, PS_CONF3_MS , 0x0000);
+    vcnl3040_write_register(data, PS_CANCEL   , 0x0000);
+    vcnl3040_write_register(data, PS_LOW_THDL , 0x0000);
+    vcnl3040_write_register(data, PS_HIGH_THDL, 0x0000);
+
+    vcnl3040_set_led(data, LED_CURRENT_200mA);
+    vcnl3040_start  (data);
+
+    vcnl3040_show_config(data);
+    return 0;
+} // vcnl3040_init
+
+static int vcnl3040_read_proxy_samp_freq(struct vcnl3040_data *data, int *val, int *val2)
+{
+	int rc;
+	unsigned int prox_rate;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	rc = regmap_read(data->regmap, VCNL_PROXIMITY_RATE, &prox_rate);
+	if (rc)
+		return rc;
+
+	if (prox_rate >= ARRAY_SIZE(vcnl3040_prox_sampling_frequency))
+		return -EINVAL;
+
+	*val = vcnl3040_prox_sampling_frequency[prox_rate][0];
+	*val2 = vcnl3040_prox_sampling_frequency[prox_rate][1];
+
+	return 0;
+}
+
+static bool vcnl3040_is_thr_enabled(struct vcnl3040_data *data)
+{
+	int rc;
+	unsigned int icr;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	rc = regmap_read(data->regmap, VCNL_PS_ICR, &icr);
+	if (rc) {
+		dev_err(data->dev,
+			"Error (%d) reading ICR register\n", rc);
+		return false;
+	}
+
+	return !!(icr & VCNL_ICR_THRES_EN);
+}
+
+static int vcnl3040_read_event(struct iio_dev *indio_dev,
+			       const struct iio_chan_spec *chan,
+			       enum iio_event_type type,
+			       enum iio_event_direction dir,
+			       enum iio_event_info info,
+			       int *val, int *val2)
+{
+	int rc;
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	switch (info) {
+	case IIO_EV_INFO_VALUE:
+		switch (dir) {
+		case IIO_EV_DIR_RISING:
+			rc = regmap_bulk_read(data->regmap, VCNL_PS_HI_THR_HI,
+					      &data->buf, sizeof(data->buf));
+			if (rc < 0)
+				return rc;
+			*val = be16_to_cpu(data->buf);
+			return IIO_VAL_INT;
+		case IIO_EV_DIR_FALLING:
+			rc = regmap_bulk_read(data->regmap, VCNL_PS_LO_THR_HI,
+					      &data->buf, sizeof(data->buf));
+			if (rc < 0)
+				return rc;
+			*val = be16_to_cpu(data->buf);
+			return IIO_VAL_INT;
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+}
+
+static int vcnl3040_write_event(struct iio_dev *indio_dev,
+				const struct iio_chan_spec *chan,
+				enum iio_event_type type,
+				enum iio_event_direction dir,
+				enum iio_event_info info,
+				int val, int val2)
+{
+	int rc;
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	mutex_lock(&data->lock);
+
+	switch (info) {
+	case IIO_EV_INFO_VALUE:
+		switch (dir) {
+		case IIO_EV_DIR_RISING:
+			/* 16 bit word/ low * high */
+			data->buf = cpu_to_be16(val);
+			rc = regmap_bulk_write(data->regmap, VCNL_PS_HI_THR_HI,
+					       &data->buf, sizeof(data->buf));
+			if (rc < 0)
+				goto err_unlock;
+			rc = IIO_VAL_INT;
+			goto err_unlock;
+		case IIO_EV_DIR_FALLING:
+			data->buf = cpu_to_be16(val);
+			rc = regmap_bulk_write(data->regmap, VCNL_PS_LO_THR_HI,
+					       &data->buf, sizeof(data->buf));
+			if (rc < 0)
+				goto err_unlock;
+			rc = IIO_VAL_INT;
+			goto err_unlock;
+		default:
+			rc = -EINVAL;
+			goto err_unlock;
+		}
+	default:
+		rc = -EINVAL;
+		goto err_unlock;
+	}
+err_unlock:
+	mutex_unlock(&data->lock);
+
+	return rc;
+}
+
+static int vcnl3040_enable_periodic(struct iio_dev *indio_dev,
+				    struct vcnl3040_data *data)
+{
+	int rc;
+	int cmd;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	mutex_lock(&data->lock);
+
+	/* Enable periodic measurement of proximity data. */
+	cmd = VCNL_PS_EN | VCNL_PS_SELFTIMED_EN;
+
+	rc = regmap_write(data->regmap, VCNL_COMMAND, cmd);
+	if (rc) {
+		dev_err(data->dev,
+			"Error (%d) writing command register\n", rc);
+		goto err_unlock;
+	}
+
+	/*
+	 * Enable interrupts on threshold, for proximity data by
+	 * default.
+	 */
+	rc = regmap_write(data->regmap, VCNL_PS_ICR, VCNL_ICR_THRES_EN);
+	if (rc)
+		dev_err(data->dev,
+			"Error (%d) reading ICR register\n", rc);
+
+err_unlock:
+	mutex_unlock(&data->lock);
+
+	return rc;
+}
+
+static int vcnl3040_disable_periodic(struct iio_dev *indio_dev,
+				     struct vcnl3040_data *data)
+{
+	int rc;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	mutex_lock(&data->lock);
+
+	rc = regmap_write(data->regmap, VCNL_COMMAND, 0);
+	if (rc) {
+		dev_err(data->dev,
+			"Error (%d) writing command register\n", rc);
+		goto err_unlock;
+	}
+
+	rc = regmap_write(data->regmap, VCNL_PS_ICR, 0);
+	if (rc) {
+		dev_err(data->dev,
+			"Error (%d) writing ICR register\n", rc);
+		goto err_unlock;
+	}
+
+	/* Clear interrupt flag bit */
+	rc = regmap_write(data->regmap, VCNL_ISR, 0);
+	if (rc)
+		dev_err(data->dev,
+			"Error (%d) writing ISR register\n", rc);
+
+err_unlock:
+	mutex_unlock(&data->lock);
+
+	return rc;
+}
+
+static int vcnl3040_config_threshold(struct iio_dev *indio_dev, bool state)
+{
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	if (state) {
+		return vcnl3040_enable_periodic(indio_dev, data);
+	} else {
+		if (!vcnl3040_is_thr_enabled(data))
+			return 0;
+		return vcnl3040_disable_periodic(indio_dev, data);
+	}
+}
+
+static int vcnl3040_write_event_config(struct iio_dev *indio_dev,
+				       const struct iio_chan_spec *chan,
+				       enum iio_event_type type,
+				       enum iio_event_direction dir,
+				       int state)
+{
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	switch (chan->type) {
+	case IIO_PROXIMITY:
+		return vcnl3040_config_threshold(indio_dev, state);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int vcnl3040_read_event_config(struct iio_dev *indio_dev,
+				      const struct iio_chan_spec *chan,
+				      enum iio_event_type type,
+				      enum iio_event_direction dir)
+{
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+
+	switch (chan->type) {
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	case IIO_PROXIMITY:
+		return vcnl3040_is_thr_enabled(data);
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct iio_event_spec vcnl3040_event_spec[] = {
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_RISING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	}, {
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_FALLING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	}, {
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_EITHER,
+		.mask_separate = BIT(IIO_EV_INFO_ENABLE),
+	},
+};
+
+static const struct iio_chan_spec vcnl3040_channels[] = {
+	{
+		.type                         = IIO_PROXIMITY,
+		.info_mask_separate           = BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SAMP_FREQ),
+		.info_mask_separate_available = BIT(IIO_CHAN_INFO_SAMP_FREQ),
+		.event_spec                   = vcnl3040_event_spec,
+		.num_event_specs              = ARRAY_SIZE(vcnl3040_event_spec),
+	},
+};
+
+static int vcnl3040_read_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int *val, int *val2, long mask)
+{
+	int rc;
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	switch (mask) {
+	    case IIO_CHAN_INFO_RAW:
+            *val = (int) vcnl3040_read_sensor(data);
+		    return IIO_VAL_INT;
+	    case IIO_CHAN_INFO_SAMP_FREQ:
+		    rc = vcnl3040_read_proxy_samp_freq(data, val, val2);
+		    if (rc < 0)
+			    return rc;
+		    return IIO_VAL_INT_PLUS_MICRO;
+	    default:
+		    return -EINVAL;
+	}
+}// vcnl3040_read_raw
+
+static int vcnl3040_write_raw(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int val1, int val2, long mask)
+{
+	struct vcnl3040_data *data = iio_priv(indio_dev);
+    int                   ret  = 0;
+
+    printk("%s:%d, ACHEUL, val1: 0x%02X, val2: 0x%02X", __FUNCTION__, __LINE__, val1, val2);
+
+    if ((val1 < PS_CONF1_2) || (val1 > PS_HIGH_THDL)){
+        printk("%s:%d, ACHEUL, error, invalid register: 0x%02X, supported values: [0x%02X..0x%02X]", __FUNCTION__, __LINE__, val1, PS_CONF1_2, PS_HIGH_THDL);
+		return -EINVAL;
+    }
+
+    ret = vcnl3040_write_register(data, (uint8_t) val1, (uint16_t) val2);
+
+    vcnl3040_show_config(data);
+    return ret;
+}// vcnl3040_write_raw
+
+static int vcnl3040_read_avail(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan,
+			       const int **vals, int *type, int *length,
+			       long mask)
+{
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*vals = (int *)vcnl3040_prox_sampling_frequency;
+		*type = IIO_VAL_INT_PLUS_MICRO;
+		*length = 2 * ARRAY_SIZE(vcnl3040_prox_sampling_frequency);
+		return IIO_AVAIL_LIST;
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct iio_info vcnl3040_info = {
+	.read_raw           = vcnl3040_read_raw,
+	.write_raw          = vcnl3040_write_raw,
+	.read_avail         = vcnl3040_read_avail,
+	.read_event_value   = vcnl3040_read_event,
+	.write_event_value  = vcnl3040_write_event,
+	.read_event_config  = vcnl3040_read_event_config,
+	.write_event_config = vcnl3040_write_event_config,
+};
+
+static const struct regmap_config vcnl3040_regmap_config = {
+	.reg_bits     = 8,
+	.val_bits     = 16,
+	.max_register = DEVICE_ID
+};
+
+static irqreturn_t vcnl3040_handle_irq_thread(int irq, void *p)
+{
+    struct iio_dev*       indio_dev       = p;
+    struct vcnl3040_data* data            = iio_priv(indio_dev);
+    uint16_t              int_flags       = vcnl3040_read_register(data, INT_FLAGS);
+    bool                  close_proximity = int_flags & 0x0200 ? true : false;
+    bool                  away_proximity  = int_flags & 0x0100 ? true : false;
+
+    // FIXME! remove this
+    printk("%s:%d, ACHEUL, close_proximity: %d, away_proximity: %d", __FUNCTION__, __LINE__, close_proximity, away_proximity);
+
+    if (close_proximity) {
+        iio_push_event(indio_dev, IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1, IIO_EV_TYPE_THRESH, IIO_EV_DIR_RISING), iio_get_time_ns(indio_dev));
+    }
+
+    if (away_proximity) {
+        iio_push_event(indio_dev, IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1, IIO_EV_TYPE_THRESH, IIO_EV_DIR_FALLING), iio_get_time_ns(indio_dev));
+    }
+
+    return IRQ_HANDLED;
+}// vcnl3040_handle_irq_thread
+
+static int vcnl3040_probe(struct i2c_client *client)
+{
+	struct vcnl3040_data *data;
+	struct iio_dev *indio_dev;
+	struct regmap *regmap;
+	int rc;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	regmap = devm_regmap_init_i2c(client, &vcnl3040_regmap_config);
+	if (IS_ERR(regmap)) {
+        printk("%s:%d, ACHEUL, error: reg map init failed", __FUNCTION__, __LINE__);
+		return PTR_ERR(regmap);
+	}
+
+	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
+	if (!indio_dev) {
+        printk("%s:%d, ACHEUL, error: failed to allocate", __FUNCTION__, __LINE__);
+		return -ENOMEM;
+    }
+
+	data = iio_priv(indio_dev);
+	i2c_set_clientdata(client, indio_dev);
+	data->regmap = regmap;
+	data->dev    = &client->dev;
+    data->client = client;
+
+	rc = vcnl3040_init(data);
+	if (rc){
+        printk("%s:%d, ACHEUL, error: failed to initialize", __FUNCTION__, __LINE__);
+		return rc;
+    }
+
+	indio_dev->info         = &vcnl3040_info;
+	indio_dev->channels     = vcnl3040_channels;
+	indio_dev->num_channels = ARRAY_SIZE(vcnl3040_channels);
+	indio_dev->name         = "vcnl3040";
+	indio_dev->modes        = INDIO_DIRECT_MODE;
+
+    if (client->irq) {
+        rc = devm_request_threaded_irq(&client->dev, client->irq, NULL, vcnl3040_handle_irq_thread, IRQF_ONESHOT, indio_dev->name, indio_dev);
+        if (rc) {
+            printk("%s:%d, ACHEUL, error: failed to initialize IRQ", __FUNCTION__, __LINE__);
+            return rc;
+        }
+    }
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+    rc = devm_iio_device_register(&client->dev, indio_dev);
+    if (rc) {
+        printk("%s:%d, ACHEUL, error: failed to register iio device, error: %d", __FUNCTION__, __LINE__, rc);
+        return rc;
+    }
+
+    return rc;
+}// vcnl3040_probe
+
+static const struct of_device_id vcnl3040_of_match[] = {
+	{
+		.compatible = "vishay,vcnl3040",
+	},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, vcnl3040_of_match);
+
+static struct i2c_driver vcnl3040_driver = {
+	.driver = {
+		.name           = "vishay,vcnl3040",
+		.of_match_table = vcnl3040_of_match,
+	},
+	.probe_new  = vcnl3040_probe,
+};
+module_i2c_driver(vcnl3040_driver);
+
+MODULE_AUTHOR("Bruno Bauthier <bruno.gauth@gmail.com>");
+MODULE_DESCRIPTION("Vishay VCNL3040 proximity sensor driver");
+MODULE_LICENSE("GPL");
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: resolver
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: temperature
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/iio: trigger
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: infiniband
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: apm-power.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: evbug.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: evdev.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: event_notify.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: ff-core.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: ff-memless.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: gameport
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: input.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: input-compat.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: input-compat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: input-leds.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: input-mt.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: input-polldev.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: joydev.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: joystick
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: keyboard
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: keycombo.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: keyreset.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/Makefile kernel/msm-4.19/drivers/input/Makefile
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/Makefile	2024-05-28 20:43:40.865409230 -0400
+++ kernel/msm-4.19/drivers/input/Makefile	2024-05-29 22:10:12.929805789 -0400
@@ -31,3 +31,9 @@
 obj-$(CONFIG_INPUT_KEYCOMBO)	+= keycombo.o
 
 obj-$(CONFIG_RMI4_CORE)		+= rmi4/
+
+###############################################
+## ACHEUL
+###############################################
+obj-y += misc/
+###############################################
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: matrix-keymap.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: 88pm80x_onkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: 88pm860x_onkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: ab8500-ponkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: ad714x.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: ad714x.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: ad714x-i2c.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: ad714x-spi.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: adxl34x.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: adxl34x.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: adxl34x-i2c.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: adxl34x-spi.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc/akm09911.c kernel/msm-4.19/drivers/input/misc/akm09911.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc/akm09911.c	1969-12-31 19:00:00.000000000 -0500
+++ kernel/msm-4.19/drivers/input/misc/akm09911.c	2024-05-29 22:10:12.917805684 -0400
@@ -0,0 +1,2490 @@
+/* drivers/misc/akm09911.c - akm09911 compass driver
+ *
+        p * Copyright (c) 2014-2015, Linux Foundation. All rights reserved.
+ * Copyright (C) 2007-2008 HTC Corporation.
+ * Author: Hou-Kun Chen <houkun.chen@gmail.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*#define DEBUG*/
+/*#define VERBOSE_DEBUG*/
+
+#include <linux/akm09911.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/freezer.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/sensors.h>
+
+#define AKM_DEBUG_IF		 	1
+#define AKM_HAS_RESET			0
+#define AKM_INPUT_DEVICE_NAME	"akm09911-mag"
+#define AKM_DRDY_TIMEOUT_MS		100
+#define AKM_BASE_NUM			10
+
+#define AKM_IS_MAG_DATA_ENABLED() (akm->enable_flag & (1 << MAG_DATA_FLAG))
+
+/* POWER SUPPLY VOLTAGE RANGE */
+#define AKM09911_VDD_MIN_UV	2000000
+#define AKM09911_VDD_MAX_UV	3300000
+#define AKM09911_VIO_MIN_UV	1750000
+#define AKM09911_VIO_MAX_UV	1950000
+
+#define STATUS_ERROR(st)		(((st)&0x08) != 0x0)
+
+#define AKM09911_RETRY_COUNT	10
+
+// ACHEUL
+#define SYN_TIME_SEC        4
+#define SYN_TIME_NSEC       5
+// ACHEUL
+
+enum {
+	AKM09911_AXIS_X = 0,
+	AKM09911_AXIS_Y,
+	AKM09911_AXIS_Z,
+	AKM09911_AXIS_COUNT,
+};
+
+/* Save last device state for power down */
+struct akm_sensor_state {
+	bool power_on;
+	uint8_t mode;
+};
+
+struct akm_compass_data {
+	struct i2c_client	*i2c;
+	struct input_dev	*input;
+	struct device		*class_dev;
+	struct class		*compass;
+	struct pinctrl		*pinctrl;
+	struct pinctrl_state	*pin_default;
+	struct pinctrl_state	*pin_sleep;
+	struct sensors_classdev	cdev;
+	struct delayed_work	dwork;
+	struct workqueue_struct	*work_queue;
+	struct mutex		op_mutex;
+	struct timespec 	ts;
+
+	wait_queue_head_t	drdy_wq;
+	wait_queue_head_t	open_wq;
+
+	/* These two buffers are initialized at start up.
+	   After that, the value is not changed */
+	uint8_t sense_info[AKM_SENSOR_INFO_SIZE];
+	uint8_t sense_conf[AKM_SENSOR_CONF_SIZE];
+
+	struct	mutex sensor_mutex;
+	uint8_t	sense_data[AKM_SENSOR_DATA_SIZE];
+	struct mutex accel_mutex;
+	int16_t accel_data[3];
+
+	struct mutex	val_mutex;
+	uint32_t		enable_flag;
+	int64_t			delay[AKM_NUM_SENSORS];
+
+	atomic_t	active;
+	atomic_t	drdy;
+
+	char	layout;
+	int	irq;
+	int	gpio_rstn;
+	int	power_enabled;
+	int	auto_report;
+	int	use_hrtimer;
+
+	/* The input event last time */
+	int	last_x;
+	int	last_y;
+	int	last_z;
+
+	int	flush_count;
+
+	/* dummy value to avoid sensor event get eaten */
+	int	rep_cnt;
+
+	struct regulator	*vdd;
+	struct regulator	*vio;
+	struct akm_sensor_state state;
+	struct hrtimer	poll_timer;
+};
+
+static struct sensors_classdev sensors_cdev = {
+	.name = "akm09911-mag",
+	.vendor = "Asahi Kasei Microdevices Corporation",
+	.version = 1,
+	.handle = SENSORS_MAGNETIC_FIELD_HANDLE,
+	.type = SENSOR_TYPE_MAGNETIC_FIELD,
+	.max_range = "1228.8",
+	.resolution = "0.15", //0.6:akm09911, 0.15:AKM09916
+	.sensor_power = "0.35",
+	.min_delay = 10000,
+	.max_delay = 10000,
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 10,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+
+static struct akm_compass_data *s_akm;
+
+static int akm_compass_power_set(struct akm_compass_data *data, bool on);
+/***** I2C I/O function ***********************************************/
+static int akm_i2c_rxdata(
+	struct i2c_client *i2c,
+	uint8_t *rxData,
+	int length)
+{
+	int ret;
+
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr = i2c->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = rxData,
+		},
+		{
+			.addr = i2c->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = rxData,
+		},
+	};
+	uint8_t addr = rxData[0];
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	ret = i2c_transfer(i2c->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret < 0) {
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		dev_err(&i2c->dev, "%s: transfer failed.", __func__);
+		return ret;
+	} else if (ret != ARRAY_SIZE(msgs)) {
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
+		dev_err(&i2c->dev, "%s: transfer failed(size error).\n",
+				__func__);
+		return -ENXIO;
+	}
+
+	dev_vdbg(&i2c->dev, "RxData: len=%02x, addr=%02x, data=%02x",
+		length, addr, rxData[0]);
+
+    printk("%s:%d, ACHEUL, RxData: len=%02x, addr=%02x, data=%02x", __FUNCTION__, __LINE__, length, addr, rxData[0]);
+
+	return 0;
+}
+
+static int akm_i2c_txdata(
+	struct i2c_client *i2c,
+	uint8_t *txData,
+	int length)
+{
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr = i2c->addr,
+			.flags = 0,
+			.len = length,
+			.buf = txData,
+		},
+	};
+
+	ret = i2c_transfer(i2c->adapter, msg, ARRAY_SIZE(msg));
+	if (ret < 0) {
+		dev_err(&i2c->dev, "%s: transfer failed.", __func__);
+		return ret;
+	} else if (ret != ARRAY_SIZE(msg)) {
+		dev_err(&i2c->dev, "%s: transfer failed(size error).",
+				__func__);
+		return -ENXIO;
+	}
+
+	dev_vdbg(&i2c->dev, "TxData: len=%02x, addr=%02x data=%02x",
+		length, txData[0], txData[1]);
+
+    printk("%s:%d, ACHEUL, TxData: len=%02x, addr=%02x, data=%02x", __FUNCTION__, __LINE__, length, txData[0], txData[1]);
+	return 0;
+}
+
+/***** akm miscdevice functions *************************************/
+static int AKECS_Set_CNTL(
+	struct akm_compass_data *akm,
+	uint8_t mode)
+{
+	uint8_t buffer[2];
+	int err;
+
+	/***** lock *****/
+	mutex_lock(&akm->sensor_mutex);
+	/* Set measure mode */
+	buffer[0] = AKM_REG_MODE;
+	buffer[1] = mode;
+	err = akm_i2c_txdata(akm->i2c, buffer, 2);
+	if (err < 0) {
+		dev_err(&akm->i2c->dev,
+				"%s: Can not set CNTL.", __func__);
+	} else {
+		dev_vdbg(&akm->i2c->dev,
+				"Mode is set to (%d).", mode);
+		atomic_set(&akm->drdy, 0);
+		/* wait at least 100us after changing mode */
+		udelay(100);
+	}
+
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+	return err;
+}
+
+static int AKECS_Set_PowerDown(
+	struct akm_compass_data *akm)
+{
+	uint8_t buffer[2];
+	int err;
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	/***** lock *****/
+	mutex_lock(&akm->sensor_mutex);
+
+	/* Set powerdown mode */
+	buffer[0] = AKM_REG_MODE;
+	buffer[1] = AKM_MODE_POWERDOWN;
+	err = akm_i2c_txdata(akm->i2c, buffer, 2);
+	if (err < 0) {
+		dev_err(&akm->i2c->dev,
+			"%s: Can not set to powerdown mode.", __func__);
+	} else {
+		dev_dbg(&akm->i2c->dev, "Powerdown mode is set.");
+		/* wait at least 100us after changing mode */
+		udelay(100);
+	}
+	atomic_set(&akm->drdy, 0);
+
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+	return err;
+}
+
+static int AKECS_Reset(
+	struct akm_compass_data *akm,
+	int hard)
+{
+	int err;
+
+#if AKM_HAS_RESET
+	uint8_t buffer[2];
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	/***** lock *****/
+	mutex_lock(&akm->sensor_mutex);
+
+	if (hard != 0) {
+		gpio_set_value(akm->gpio_rstn, 0);
+		udelay(5);
+		gpio_set_value(akm->gpio_rstn, 1);
+		/* No error is returned */
+		err = 0;
+	} else {
+		buffer[0] = AKM_REG_RESET;
+		buffer[1] = AKM_RESET_DATA;
+		err = akm_i2c_txdata(akm->i2c, buffer, 2);
+		if (err < 0) {
+			dev_err(&akm->i2c->dev,
+				"%s: Can not set SRST bit.", __func__);
+		} else {
+			dev_dbg(&akm->i2c->dev, "Soft reset is done.");
+		}
+	}
+	/* Device will be accessible 100 us after */
+	udelay(100);
+	atomic_set(&akm->drdy, 0);
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+#else
+	err = AKECS_Set_PowerDown(akm);
+#endif
+
+	return err;
+}
+
+static int AKECS_SetMode(
+	struct akm_compass_data *akm,
+	uint8_t mode)
+{
+	int err;
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	switch (mode & 0x1F) {
+	case AKM_MODE_SNG_MEASURE:
+	case AKM_MODE_SELF_TEST:
+	case AKM_MODE_FUSE_ACCESS:
+	case AKM_MODE_CONTINUOUS_10HZ:
+	case AKM_MODE_CONTINUOUS_20HZ:
+	case AKM_MODE_CONTINUOUS_50HZ:
+	case AKM_MODE_CONTINUOUS_100HZ:
+		err = AKECS_Set_CNTL(akm, mode);
+		break;
+	case AKM_MODE_POWERDOWN:
+		err = AKECS_Set_PowerDown(akm);
+		break;
+	default:
+		dev_err(&akm->i2c->dev,
+			"%s: Unknown mode(%d).", __func__, mode);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static void AKECS_SetYPR(
+	struct akm_compass_data *akm,
+	int *rbuf)
+{
+	uint32_t ready;
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+
+	dev_vdbg(&akm->i2c->dev, "%s: flag =0x%X", __func__, rbuf[0]);
+	dev_vdbg(&akm->input->dev, "  Acc [LSB]   : %6d,%6d,%6d stat=%d",
+		rbuf[1], rbuf[2], rbuf[3], rbuf[4]);
+	dev_vdbg(&akm->input->dev, "  Geo [LSB]   : %6d,%6d,%6d stat=%d",
+		rbuf[5], rbuf[6], rbuf[7], rbuf[8]);
+	dev_vdbg(&akm->input->dev, "  Orientation : %6d,%6d,%6d",
+		rbuf[9], rbuf[10], rbuf[11]);
+	dev_vdbg(&akm->input->dev, "  Rotation V  : %6d,%6d,%6d,%6d",
+		rbuf[12], rbuf[13], rbuf[14], rbuf[15]);
+
+	/* No events are reported */
+	if (!rbuf[0]) {
+		dev_dbg(&akm->i2c->dev, "Don't waste a time.");
+		return;
+	}
+
+	mutex_lock(&akm->val_mutex);
+	ready = (akm->enable_flag & (uint32_t)rbuf[0]);
+	mutex_unlock(&akm->val_mutex);
+
+	/* Report acceleration sensor information */
+	if (ready & ACC_DATA_READY) {
+		input_report_abs(akm->input, ABS_X, rbuf[1]);
+		input_report_abs(akm->input, ABS_Y, rbuf[2]);
+		input_report_abs(akm->input, ABS_Z, rbuf[3]);
+		input_report_abs(akm->input, ABS_RX, rbuf[4]);
+	}
+	/* Report magnetic vector information */
+	if (ready & MAG_DATA_READY) {
+		input_report_abs(akm->input, ABS_X, rbuf[5]);
+		input_report_abs(akm->input, ABS_Y, rbuf[6]);
+		input_report_abs(akm->input, ABS_Z, rbuf[7]);
+		input_report_abs(akm->input, ABS_MISC, rbuf[8]);
+	}
+	/* Report fusion sensor information */
+	if (ready & FUSION_DATA_READY) {
+		/* Orientation */
+		input_report_abs(akm->input, ABS_HAT0Y, rbuf[9]);
+		input_report_abs(akm->input, ABS_HAT1X, rbuf[10]);
+		input_report_abs(akm->input, ABS_HAT1Y, rbuf[11]);
+		/* Rotation Vector */
+		input_report_abs(akm->input, ABS_TILT_X, rbuf[12]);
+		input_report_abs(akm->input, ABS_TILT_Y, rbuf[13]);
+		input_report_abs(akm->input, ABS_TOOL_WIDTH, rbuf[14]);
+		input_report_abs(akm->input, ABS_VOLUME, rbuf[15]);
+	}
+
+	input_sync(akm->input);
+}
+
+/* This function will block a process until the latest measurement
+ * data is available.
+ */
+static int AKECS_GetData(
+	struct akm_compass_data *akm,
+	uint8_t *rbuf,
+	int size)
+{
+	int err;
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	/* Block! */
+	err = wait_event_interruptible_timeout(
+			akm->drdy_wq,
+			atomic_read(&akm->drdy),
+			msecs_to_jiffies(AKM_DRDY_TIMEOUT_MS));
+
+	if (err < 0) {
+		dev_err(&akm->i2c->dev,
+			"%s: wait_event failed (%d).", __func__, err);
+		return err;
+	}
+	if (!atomic_read(&akm->drdy)) {
+		dev_err(&akm->i2c->dev,
+			"%s: DRDY is not set.", __func__);
+		return -ENODATA;
+	}
+
+	/***** lock *****/
+	mutex_lock(&akm->sensor_mutex);
+
+	memcpy(rbuf, akm->sense_data, size);
+	atomic_set(&akm->drdy, 0);
+
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+	return 0;
+}
+
+static int AKECS_GetData_Poll(
+	struct akm_compass_data *akm,
+	uint8_t *rbuf,
+	int size)
+{
+	uint8_t buffer[AKM_SENSOR_DATA_SIZE];
+	int err;
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	/* Read data */
+	buffer[0] = AKM_REG_STATUS;
+	err = akm_i2c_rxdata(akm->i2c, buffer, AKM_SENSOR_DATA_SIZE);
+	if (err < 0) {
+		dev_err(&akm->i2c->dev, "%s failed.", __func__);
+		return err;
+	}
+
+	/* Check ST bit */
+	if (!(AKM_DRDY_IS_HIGH(buffer[0])))
+		dev_dbg(&akm->i2c->dev, "DRDY is low. Use last value.\n");
+
+	/* Data is over run is */
+	if (AKM_DOR_IS_HIGH(buffer[0]))
+		dev_dbg(&akm->i2c->dev, "Data over run!\n");
+
+	memcpy(rbuf, buffer, size);
+	atomic_set(&akm->drdy, 0);
+
+	return 0;
+}
+
+static int AKECS_GetOpenStatus(
+	struct akm_compass_data *akm)
+{
+	return wait_event_interruptible(
+			akm->open_wq, (atomic_read(&akm->active) > 0));
+}
+
+static int AKECS_GetCloseStatus(
+	struct akm_compass_data *akm)
+{
+	return wait_event_interruptible(
+			akm->open_wq, (atomic_read(&akm->active) <= 0));
+}
+
+static int AKECS_Open(struct inode *inode, struct file *file)
+{
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	file->private_data = s_akm;
+	return nonseekable_open(inode, file);
+}
+
+static int AKECS_Release(struct inode *inode, struct file *file)
+{
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static long
+AKECS_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct akm_compass_data *akm = file->private_data;
+
+	/* NOTE: In this function the size of "char" should be 1-byte. */
+	uint8_t i2c_buf[AKM_RWBUF_SIZE];		/* for READ/WRITE */
+	uint8_t dat_buf[AKM_SENSOR_DATA_SIZE];/* for GET_DATA */
+	int32_t ypr_buf[AKM_YPR_DATA_SIZE];		/* for SET_YPR */
+	int64_t delay[AKM_NUM_SENSORS];	/* for GET_DELAY */
+	int16_t acc_buf[3];	/* for GET_ACCEL */
+	uint8_t mode;			/* for SET_MODE*/
+	int status;			/* for OPEN/CLOSE_STATUS */
+	int ret = 0;		/* Return value. */
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+	case ECS_IOCTL_WRITE:
+		if (argp == NULL) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		if (copy_from_user(&i2c_buf, argp, sizeof(i2c_buf))) {
+			dev_err(&akm->i2c->dev, "copy_from_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_SET_MODE:
+		if (argp == NULL) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		if (copy_from_user(&mode, argp, sizeof(mode))) {
+			dev_err(&akm->i2c->dev, "copy_from_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_SET_YPR:
+		if (argp == NULL) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		if (copy_from_user(&ypr_buf, argp, sizeof(ypr_buf))) {
+			dev_err(&akm->i2c->dev, "copy_from_user failed.");
+			return -EFAULT;
+		}
+	case ECS_IOCTL_GET_INFO:
+	case ECS_IOCTL_GET_CONF:
+	case ECS_IOCTL_GET_DATA:
+	case ECS_IOCTL_GET_OPEN_STATUS:
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+	case ECS_IOCTL_GET_DELAY:
+	case ECS_IOCTL_GET_LAYOUT:
+	case ECS_IOCTL_GET_ACCEL:
+		/* Check buffer pointer for writing a data later. */
+		if (argp == NULL) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_READ called.");
+		if ((i2c_buf[0] < 1) || (i2c_buf[0] > (AKM_RWBUF_SIZE-1))) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		ret = akm_i2c_rxdata(akm->i2c, &i2c_buf[1], i2c_buf[0]);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_WRITE:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_WRITE called.");
+		if ((i2c_buf[0] < 2) || (i2c_buf[0] > (AKM_RWBUF_SIZE-1))) {
+			dev_err(&akm->i2c->dev, "invalid argument.");
+			return -EINVAL;
+		}
+		ret = akm_i2c_txdata(akm->i2c, &i2c_buf[1], i2c_buf[0]);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_RESET:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_RESET called.");
+		ret = AKECS_Reset(akm, akm->gpio_rstn);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_SET_MODE:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_SET_MODE called.");
+		ret = AKECS_SetMode(akm, mode);
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_SET_YPR:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_SET_YPR called.");
+		AKECS_SetYPR(akm, ypr_buf);
+		break;
+	case ECS_IOCTL_GET_DATA:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_DATA called.");
+		if (akm->irq)
+			ret = AKECS_GetData(akm, dat_buf, AKM_SENSOR_DATA_SIZE);
+		else
+			ret = AKECS_GetData_Poll(
+					akm, dat_buf, AKM_SENSOR_DATA_SIZE);
+
+		if (ret < 0)
+			return ret;
+		break;
+	case ECS_IOCTL_GET_OPEN_STATUS:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_OPEN_STATUS called.");
+		ret = AKECS_GetOpenStatus(akm);
+		if (ret < 0) {
+			dev_err(&akm->i2c->dev,
+				"Get Open returns error (%d).", ret);
+			return ret;
+		}
+		break;
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_CLOSE_STATUS called.");
+		ret = AKECS_GetCloseStatus(akm);
+		if (ret < 0) {
+			dev_err(&akm->i2c->dev,
+				"Get Close returns error (%d).", ret);
+			return ret;
+		}
+		break;
+	case ECS_IOCTL_GET_DELAY:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_DELAY called.");
+		mutex_lock(&akm->val_mutex);
+		delay[0] = ((akm->enable_flag & ACC_DATA_READY) ?
+				akm->delay[0] : -1);
+		delay[1] = ((akm->enable_flag & MAG_DATA_READY) ?
+				akm->delay[1] : -1);
+		delay[2] = ((akm->enable_flag & FUSION_DATA_READY) ?
+				akm->delay[2] : -1);
+		mutex_unlock(&akm->val_mutex);
+		break;
+	case ECS_IOCTL_GET_INFO:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_INFO called.");
+		break;
+	case ECS_IOCTL_GET_CONF:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_CONF called.");
+		break;
+	case ECS_IOCTL_GET_LAYOUT:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_LAYOUT called.");
+		break;
+	case ECS_IOCTL_GET_ACCEL:
+		dev_vdbg(&akm->i2c->dev, "IOCTL_GET_ACCEL called.");
+		mutex_lock(&akm->accel_mutex);
+		acc_buf[0] = akm->accel_data[0];
+		acc_buf[1] = akm->accel_data[1];
+		acc_buf[2] = akm->accel_data[2];
+		mutex_unlock(&akm->accel_mutex);
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	switch (cmd) {
+	case ECS_IOCTL_READ:
+		/* +1  is for the first byte */
+		if (copy_to_user(argp, &i2c_buf, i2c_buf[0]+1)) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_INFO:
+		if (copy_to_user(argp, &akm->sense_info,
+					sizeof(akm->sense_info))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_CONF:
+		if (copy_to_user(argp, &akm->sense_conf,
+					sizeof(akm->sense_conf))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_DATA:
+		if (copy_to_user(argp, &dat_buf, sizeof(dat_buf))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_OPEN_STATUS:
+	case ECS_IOCTL_GET_CLOSE_STATUS:
+		status = atomic_read(&akm->active);
+		if (copy_to_user(argp, &status, sizeof(status))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_DELAY:
+		if (copy_to_user(argp, &delay, sizeof(delay))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_LAYOUT:
+		if (copy_to_user(argp, &akm->layout, sizeof(akm->layout))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	case ECS_IOCTL_GET_ACCEL:
+		if (copy_to_user(argp, &acc_buf, sizeof(acc_buf))) {
+			dev_err(&akm->i2c->dev, "copy_to_user failed.");
+			return -EFAULT;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static const struct file_operations AKECS_fops = {
+	.owner = THIS_MODULE,
+	.open = AKECS_Open,
+	.release = AKECS_Release,
+	.unlocked_ioctl = AKECS_ioctl,
+};
+
+static struct miscdevice akm_compass_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = AKM_MISCDEV_NAME,
+	.fops = &AKECS_fops,
+};
+
+/***** akm sysfs functions ******************************************/
+static int create_device_attributes(
+	struct device *dev,
+	struct device_attribute *attrs)
+{
+	int i;
+	int err = 0;
+
+	for (i = 0 ; NULL != attrs[i].attr.name ; ++i) {
+		err = device_create_file(dev, &attrs[i]);
+		if (err)
+			break;
+	}
+
+	if (err) {
+		for (--i; i >= 0 ; --i)
+			device_remove_file(dev, &attrs[i]);
+	}
+
+	return err;
+}
+
+static void remove_device_attributes(
+	struct device *dev,
+	struct device_attribute *attrs)
+{
+	int i;
+
+	for (i = 0 ; NULL != attrs[i].attr.name ; ++i)
+		device_remove_file(dev, &attrs[i]);
+}
+
+static int create_device_binary_attributes(
+	struct kobject *kobj,
+	struct bin_attribute *attrs)
+{
+	int i;
+	int err = 0;
+
+	err = 0;
+
+	for (i = 0 ; NULL != attrs[i].attr.name ; ++i) {
+		err = sysfs_create_bin_file(kobj, &attrs[i]);
+		if (0 != err)
+			break;
+	}
+
+	if (0 != err) {
+		for (--i; i >= 0 ; --i)
+			sysfs_remove_bin_file(kobj, &attrs[i]);
+	}
+
+	return err;
+}
+
+static void remove_device_binary_attributes(
+	struct kobject *kobj,
+	struct bin_attribute *attrs)
+{
+	int i;
+
+	for (i = 0 ; NULL != attrs[i].attr.name ; ++i)
+		sysfs_remove_bin_file(kobj, &attrs[i]);
+}
+
+/*********************************************************************
+ *
+ * SysFS attribute functions
+ *
+ * directory : /sys/class/compass/akmXXXX/
+ * files :
+ *  - enable_acc    [rw] [t] : enable flag for accelerometer
+ *  - enable_mag    [rw] [t] : enable flag for magnetometer
+ *  - enable_fusion [rw] [t] : enable flag for fusion sensor
+ *  - delay_acc     [rw] [t] : delay in nanosecond for accelerometer
+ *  - delay_mag     [rw] [t] : delay in nanosecond for magnetometer
+ *  - delay_fusion  [rw] [t] : delay in nanosecond for fusion sensor
+ *
+ * debug :
+ *  - mode       [w]  [t] : E-Compass mode
+ *  - bdata      [r]  [t] : buffered raw data
+ *  - asa        [r]  [t] : FUSEROM data
+ *  - regs       [r]  [t] : read all registers
+ *
+ * [b] = binary format
+ * [t] = text format
+ */
+
+/***** sysfs enable *************************************************/
+static void akm_compass_sysfs_update_status(
+	struct akm_compass_data *akm)
+{
+	uint32_t en;
+	mutex_lock(&akm->val_mutex);
+	en = akm->enable_flag;
+	mutex_unlock(&akm->val_mutex);
+
+	if (en == 0) {
+		if (atomic_cmpxchg(&akm->active, 1, 0) == 1) {
+			wake_up(&akm->open_wq);
+			dev_dbg(akm->class_dev, "Deactivated");
+		}
+	} else {
+		if (atomic_cmpxchg(&akm->active, 0, 1) == 0) {
+			wake_up(&akm->open_wq);
+			dev_dbg(akm->class_dev, "Activated");
+		}
+	}
+	dev_dbg(&akm->i2c->dev,
+		"Status updated: enable=0x%X, active=%d",
+		en, atomic_read(&akm->active));
+}
+
+static inline uint8_t akm_select_frequency(int64_t delay_ns)
+{
+	if (delay_ns >= 100000000LL)
+		return AKM_MODE_CONTINUOUS_10HZ;
+	else if (delay_ns >= 50000000LL)
+		return AKM_MODE_CONTINUOUS_20HZ;
+	else if (delay_ns >= 20000000LL)
+		return AKM_MODE_CONTINUOUS_50HZ;
+	else
+		return AKM_MODE_CONTINUOUS_100HZ;
+}
+
+static int akm_enable_set(struct sensors_classdev *sensors_cdev,
+		unsigned int enable)
+{
+	int ret = 0;
+	struct akm_compass_data *akm = container_of(sensors_cdev,
+			struct akm_compass_data, cdev);
+	uint8_t mode;
+
+	mutex_lock(&akm->val_mutex);
+	akm->enable_flag &= ~(1<<MAG_DATA_FLAG);
+	akm->enable_flag |= ((uint32_t)(enable))<<MAG_DATA_FLAG;
+	mutex_unlock(&akm->val_mutex);
+
+	akm_compass_sysfs_update_status(akm);
+	mutex_lock(&akm->op_mutex);
+	if (enable) {
+		ret = akm_compass_power_set(akm, true);
+		if (ret) {
+			dev_err(&akm->i2c->dev,
+				"Fail to power on the device!\n");
+			goto exit;
+		}
+
+		if (akm->auto_report) {
+			mode = akm_select_frequency(akm->delay[MAG_DATA_FLAG]);
+			AKECS_SetMode(akm, mode);
+			if (akm->use_hrtimer)
+				hrtimer_start(&akm->poll_timer,
+					ns_to_ktime(akm->delay[MAG_DATA_FLAG]),
+					HRTIMER_MODE_REL);
+			else
+				queue_delayed_work(akm->work_queue, &akm->dwork,
+					(unsigned long)nsecs_to_jiffies64(
+						akm->delay[MAG_DATA_FLAG]));
+		}
+	} else {
+		if (akm->auto_report) {
+			if (akm->use_hrtimer) {
+				hrtimer_cancel(&akm->poll_timer);
+				cancel_work_sync(&akm->dwork.work);
+			} else {
+				cancel_delayed_work_sync(&akm->dwork);
+			}
+			AKECS_SetMode(akm, AKM_MODE_POWERDOWN);
+		}
+		ret = akm_compass_power_set(akm, false);
+		if (ret) {
+			dev_err(&akm->i2c->dev,
+				"Fail to power off the device!\n");
+			goto exit;
+		}
+	}
+
+exit:
+	mutex_unlock(&akm->op_mutex);
+	return ret;
+}
+
+static ssize_t akm_compass_sysfs_enable_show(
+	struct akm_compass_data *akm, char *buf, int pos)
+{
+	int flag;
+
+	mutex_lock(&akm->val_mutex);
+	flag = ((akm->enable_flag >> pos) & 1);
+	mutex_unlock(&akm->val_mutex);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", flag);
+}
+
+static ssize_t akm_compass_sysfs_enable_store(
+	struct akm_compass_data *akm, char const *buf, size_t count, int pos)
+{
+	long en = 0;
+	int ret = 0;
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+
+	if (NULL == buf)
+		return -EINVAL;
+
+	if (0 == count)
+		return 0;
+
+	if (kstrtol(buf, AKM_BASE_NUM, &en))
+		return -EINVAL;
+
+	en = en ? 1 : 0;
+
+	mutex_lock(&akm->op_mutex);
+	ret = akm_compass_power_set(akm, en);
+	if (ret) {
+		dev_err(&akm->i2c->dev,
+			"Fail to configure device power!\n");
+		goto exit;
+	}
+	mutex_lock(&akm->val_mutex);
+	akm->enable_flag &= ~(1<<pos);
+	akm->enable_flag |= ((uint32_t)(en))<<pos;
+	mutex_unlock(&akm->val_mutex);
+
+	akm_compass_sysfs_update_status(akm);
+
+exit:
+	mutex_unlock(&akm->op_mutex);
+
+	return ret ? ret : count;
+}
+
+/***** Acceleration ***/
+static ssize_t akm_enable_acc_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_enable_show(
+		dev_get_drvdata(dev), buf, ACC_DATA_FLAG);
+}
+static ssize_t akm_enable_acc_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_enable_store(
+		dev_get_drvdata(dev), buf, count, ACC_DATA_FLAG);
+}
+
+/***** Magnetic field ***/
+static ssize_t akm_enable_mag_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_enable_show(dev_get_drvdata(dev), buf, MAG_DATA_FLAG);
+}
+static ssize_t akm_enable_mag_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_enable_store(
+		dev_get_drvdata(dev), buf, count, MAG_DATA_FLAG);
+}
+
+/***** Fusion ***/
+static ssize_t akm_enable_fusion_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_enable_show(
+		dev_get_drvdata(dev), buf, FUSION_DATA_FLAG);
+}
+static ssize_t akm_enable_fusion_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_enable_store(
+		dev_get_drvdata(dev), buf, count, FUSION_DATA_FLAG);
+}
+
+static int akm_flush_set(struct sensors_classdev *sensors_cdev)
+{
+	struct akm_compass_data *akm = container_of(sensors_cdev,
+			struct akm_compass_data, cdev);
+
+	if(!AKM_IS_MAG_DATA_ENABLED())
+		return -EINVAL;
+
+	input_event(akm->input, EV_SYN, SYN_CONFIG, akm->flush_count++);
+	input_sync(akm->input);
+
+	dev_dbg(&akm->i2c->dev, "%s: end \n", __func__);
+
+	return 0;
+}
+
+/***** sysfs delay **************************************************/
+static int akm_poll_delay_set(struct sensors_classdev *sensors_cdev,
+		unsigned int delay_msec)
+{
+	struct akm_compass_data *akm = container_of(sensors_cdev,
+			struct akm_compass_data, cdev);
+	uint8_t mode;
+	int ret;
+
+	mutex_lock(&akm->val_mutex);
+
+	akm->delay[MAG_DATA_FLAG] = delay_msec * 1000000;
+	mode = akm_select_frequency(akm->delay[MAG_DATA_FLAG]);
+	ret = AKECS_SetMode(akm, mode);
+	if (ret < 0)
+		dev_err(&akm->i2c->dev, "Failed to set to mode(%x)\n", mode);
+
+	mutex_unlock(&akm->val_mutex);
+	return ret;
+}
+
+static ssize_t akm_compass_sysfs_delay_show(
+	struct akm_compass_data *akm, char *buf, int pos)
+{
+	int64_t val;
+
+	mutex_lock(&akm->val_mutex);
+	val = akm->delay[pos];
+	mutex_unlock(&akm->val_mutex);
+
+	return scnprintf(buf, PAGE_SIZE, "%lld\n", val);
+}
+
+static ssize_t akm_compass_sysfs_delay_store(
+	struct akm_compass_data *akm, char const *buf, size_t count, int pos)
+{
+	long long val = 0;
+
+	if (NULL == buf)
+		return -EINVAL;
+
+	if (0 == count)
+		return 0;
+
+	if (kstrtoll(buf, AKM_BASE_NUM, &val))
+		return -EINVAL;
+
+	mutex_lock(&akm->val_mutex);
+	akm->delay[pos] = val;
+	mutex_unlock(&akm->val_mutex);
+
+	return count;
+}
+
+/***** Accelerometer ***/
+static ssize_t akm_delay_acc_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_delay_show(
+		dev_get_drvdata(dev), buf, ACC_DATA_FLAG);
+}
+static ssize_t akm_delay_acc_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_delay_store(
+		dev_get_drvdata(dev), buf, count, ACC_DATA_FLAG);
+}
+
+/***** Magnetic field ***/
+static ssize_t akm_delay_mag_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_delay_show(
+		dev_get_drvdata(dev), buf, MAG_DATA_FLAG);
+}
+static ssize_t akm_delay_mag_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_delay_store(
+		dev_get_drvdata(dev), buf, count, MAG_DATA_FLAG);
+}
+
+/***** Fusion ***/
+static ssize_t akm_delay_fusion_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return akm_compass_sysfs_delay_show(
+		dev_get_drvdata(dev), buf, FUSION_DATA_FLAG);
+}
+static ssize_t akm_delay_fusion_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	return akm_compass_sysfs_delay_store(
+		dev_get_drvdata(dev), buf, count, FUSION_DATA_FLAG);
+}
+
+/***** accel (binary) ***/
+static ssize_t akm_bin_accel_write(
+	struct file *file,
+	struct kobject *kobj,
+	struct bin_attribute *attr,
+		char *buf,
+		loff_t pos,
+		size_t size)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	int16_t *accel_data;
+
+	if (size == 0)
+		return 0;
+
+	accel_data = (int16_t *)buf;
+
+	mutex_lock(&akm->accel_mutex);
+	akm->accel_data[0] = accel_data[0];
+	akm->accel_data[1] = accel_data[1];
+	akm->accel_data[2] = accel_data[2];
+	mutex_unlock(&akm->accel_mutex);
+
+	dev_vdbg(&akm->i2c->dev, "accel:%d,%d,%d\n",
+			accel_data[0], accel_data[1], accel_data[2]);
+
+	return size;
+}
+
+
+#if AKM_DEBUG_IF
+static ssize_t akm_sysfs_mode_store(
+	struct device *dev, struct device_attribute *attr,
+	char const *buf, size_t count)
+{
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	long mode = 0;
+
+	if (NULL == buf)
+		return -EINVAL;
+
+	if (0 == count)
+		return 0;
+
+	if (kstrtol(buf, AKM_BASE_NUM, &mode))
+		return -EINVAL;
+
+	if (AKECS_SetMode(akm, (uint8_t)mode) < 0)
+		return -EINVAL;
+
+	return 1;
+}
+
+static ssize_t akm_buf_print(
+	char *buf, uint8_t *data, size_t num)
+{
+	int sz, i;
+	char *cur;
+	size_t cur_len;
+
+	cur = buf;
+	cur_len = PAGE_SIZE;
+	sz = snprintf(cur, cur_len, "(HEX):");
+	if (sz < 0)
+		return sz;
+	cur += sz;
+	cur_len -= sz;
+	for (i = 0; i < num; i++) {
+		sz = snprintf(cur, cur_len, "%02X,", *data);
+		if (sz < 0)
+			return sz;
+		cur += sz;
+		cur_len -= sz;
+		data++;
+	}
+	sz = snprintf(cur, cur_len, "\n");
+	if (sz < 0)
+		return sz;
+	cur += sz;
+
+	return (ssize_t)(cur - buf);
+}
+
+static ssize_t akm_sysfs_bdata_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	uint8_t rbuf[AKM_SENSOR_DATA_SIZE];
+
+	mutex_lock(&akm->sensor_mutex);
+	memcpy(&rbuf, akm->sense_data, sizeof(rbuf));
+	mutex_unlock(&akm->sensor_mutex);
+
+	return akm_buf_print(buf, rbuf, AKM_SENSOR_DATA_SIZE);
+}
+
+static ssize_t akm_sysfs_asa_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	int err;
+	uint8_t asa[3];
+
+	err = AKECS_SetMode(akm, AKM_MODE_FUSE_ACCESS);
+	if (err < 0)
+		return err;
+
+	asa[0] = AKM_FUSE_1ST_ADDR;
+	err = akm_i2c_rxdata(akm->i2c, asa, 3);
+	if (err < 0)
+		return err;
+
+	err = AKECS_SetMode(akm, AKM_MODE_POWERDOWN);
+	if (err < 0)
+		return err;
+
+	return akm_buf_print(buf, asa, 3);
+}
+
+static ssize_t akm_sysfs_regs_show(
+	struct device *dev, struct device_attribute *attr, char *buf)
+{
+	/* The total number of registers depends on the device. */
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	int err;
+	uint8_t regs[AKM_REGS_SIZE];
+
+	/* This function does not lock mutex obj */
+	regs[0] = AKM_REGS_1ST_ADDR;
+	err = akm_i2c_rxdata(akm->i2c, regs, AKM_REGS_SIZE);
+	if (err < 0)
+		return err;
+
+	return akm_buf_print(buf, regs, AKM_REGS_SIZE);
+}
+#endif
+
+static struct device_attribute akm_compass_attributes[] = {
+	__ATTR(enable_acc   , 0660, akm_enable_acc_show   , akm_enable_acc_store),
+	__ATTR(enable_mag   , 0660, akm_enable_mag_show   , akm_enable_mag_store),
+	__ATTR(enable_fusion, 0660, akm_enable_fusion_show, akm_enable_fusion_store),
+	__ATTR(delay_acc    , 0660, akm_delay_acc_show    , akm_delay_acc_store),
+	__ATTR(delay_mag    , 0660, akm_delay_mag_show    , akm_delay_mag_store),
+	__ATTR(delay_fusion , 0660, akm_delay_fusion_show , akm_delay_fusion_store),
+#if AKM_DEBUG_IF
+	__ATTR(mode,  0220, NULL, akm_sysfs_mode_store),
+	__ATTR(bdata, 0440, akm_sysfs_bdata_show, NULL),
+	__ATTR(asa,   0440, akm_sysfs_asa_show, NULL),
+	__ATTR(regs,  0440, akm_sysfs_regs_show, NULL),
+#endif
+	__ATTR_NULL,
+};
+
+static struct bin_attribute akm_compass_bin_attributes[] = {
+	__BIN_ATTR(accel, 0220, NULL, akm_bin_accel_write, 6),
+	__BIN_ATTR_NULL
+};
+
+static char const *const device_link_name = "i2c";
+static dev_t const akm_compass_device_dev_t = MKDEV(MISC_MAJOR, 240);
+
+static int create_sysfs_interfaces(struct akm_compass_data *akm)
+{
+	int err;
+
+	if (NULL == akm)
+		return -EINVAL;
+
+	err = 0;
+
+	akm->compass = class_create(THIS_MODULE, AKM_SYSCLS_NAME);
+	if (IS_ERR(akm->compass)) {
+		err = PTR_ERR(akm->compass);
+		goto exit_class_create_failed;
+	}
+
+	akm->class_dev = device_create(
+						akm->compass,
+						NULL,
+						akm_compass_device_dev_t,
+						akm,
+						AKM_SYSDEV_NAME);
+	if (IS_ERR(akm->class_dev)) {
+		err = PTR_ERR(akm->class_dev);
+		goto exit_class_device_create_failed;
+	}
+
+	err = sysfs_create_link(
+			&akm->class_dev->kobj,
+			&akm->i2c->dev.kobj,
+			device_link_name);
+	if (0 > err)
+		goto exit_sysfs_create_link_failed;
+
+	err = create_device_attributes(
+			akm->class_dev,
+			akm_compass_attributes);
+	if (0 > err)
+		goto exit_device_attributes_create_failed;
+
+	err = create_device_binary_attributes(
+			&akm->class_dev->kobj,
+			akm_compass_bin_attributes);
+	if (0 > err)
+		goto exit_device_binary_attributes_create_failed;
+
+	return err;
+
+exit_device_binary_attributes_create_failed:
+	remove_device_attributes(akm->class_dev, akm_compass_attributes);
+exit_device_attributes_create_failed:
+	sysfs_remove_link(&akm->class_dev->kobj, device_link_name);
+exit_sysfs_create_link_failed:
+	device_destroy(akm->compass, akm_compass_device_dev_t);
+exit_class_device_create_failed:
+	akm->class_dev = NULL;
+	class_destroy(akm->compass);
+exit_class_create_failed:
+	akm->compass = NULL;
+	return err;
+}
+
+static void remove_sysfs_interfaces(struct akm_compass_data *akm)
+{
+	if (NULL == akm)
+		return;
+
+	if (NULL != akm->class_dev) {
+		remove_device_binary_attributes(
+			&akm->class_dev->kobj,
+			akm_compass_bin_attributes);
+		remove_device_attributes(
+			akm->class_dev,
+			akm_compass_attributes);
+		sysfs_remove_link(
+			&akm->class_dev->kobj,
+			device_link_name);
+		akm->class_dev = NULL;
+	}
+	if (NULL != akm->compass) {
+		device_destroy(
+			akm->compass,
+			akm_compass_device_dev_t);
+		class_destroy(akm->compass);
+		akm->compass = NULL;
+	}
+}
+
+
+/***** akm input device functions ***********************************/
+static int akm_compass_input_init(
+	struct input_dev **input)
+{
+	int err = 0;
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	/* Declare input device */
+	*input = input_allocate_device();
+	if (!*input)
+		return -ENOMEM;
+
+	/* Setup input device */
+	set_bit(EV_ABS, (*input)->evbit);
+	/* Accelerometer (720 x 16G)*/
+	input_set_abs_params(*input, ABS_X,
+			-11520, 11520, 0, 0);
+	input_set_abs_params(*input, ABS_Y,
+			-11520, 11520, 0, 0);
+	input_set_abs_params(*input, ABS_Z,
+			-11520, 11520, 0, 0);
+	input_set_abs_params(*input, ABS_RX,
+			0, 3, 0, 0);
+	/* Magnetic field (limited to 16bit) */
+	input_set_abs_params(*input, ABS_RY,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_RZ,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_THROTTLE,
+			-32768, 32767, 0, 0);
+	input_set_abs_params(*input, ABS_RUDDER,
+			0, 3, 0, 0);
+
+	/* Orientation (degree in Q6 format) */
+	/*  yaw[0,360) pitch[-180,180) roll[-90,90) */
+	input_set_abs_params(*input, ABS_HAT0Y,
+			0, 23040, 0, 0);
+	input_set_abs_params(*input, ABS_HAT1X,
+			-11520, 11520, 0, 0);
+	input_set_abs_params(*input, ABS_HAT1Y,
+			-5760, 5760, 0, 0);
+	/* Rotation Vector [-1,+1] in Q14 format */
+	input_set_abs_params(*input, ABS_TILT_X,
+			-16384, 16384, 0, 0);
+	input_set_abs_params(*input, ABS_TILT_Y,
+			-16384, 16384, 0, 0);
+	input_set_abs_params(*input, ABS_TOOL_WIDTH,
+			-16384, 16384, 0, 0);
+	input_set_abs_params(*input, ABS_VOLUME,
+			-16384, 16384, 0, 0);
+
+	/* Report the dummy value */
+	input_set_abs_params(*input, ABS_MISC,
+			INT_MIN, INT_MAX, 0, 0);
+
+	input_set_capability(*input, EV_REL, SYN_TIME_SEC);
+	input_set_capability(*input, EV_REL, SYN_TIME_NSEC);
+
+	/* Set name */
+	(*input)->name = AKM_INPUT_DEVICE_NAME;
+
+	/* Register */
+	err = input_register_device(*input);
+	if (err) {
+        printk("%s:%d, ACHEUL error: %d", __FUNCTION__, __LINE__, err);
+		input_free_device(*input);
+		return err;
+	}
+
+    printk("%s:%d, ACHEUL end: %d", __FUNCTION__, __LINE__, err);
+	return err;
+}
+
+/***** akm functions ************************************************/
+static irqreturn_t akm_compass_irq(int irq, void *handle)
+{
+	struct akm_compass_data *akm = handle;
+	uint8_t buffer[AKM_SENSOR_DATA_SIZE];
+	int err;
+
+	memset(buffer, 0, sizeof(buffer));
+
+	/***** lock *****/
+	mutex_lock(&akm->sensor_mutex);
+
+	/* Read whole data */
+	buffer[0] = AKM_REG_STATUS;
+	err = akm_i2c_rxdata(akm->i2c, buffer, AKM_SENSOR_DATA_SIZE);
+	if (err < 0) {
+		dev_err(&akm->i2c->dev, "IRQ I2C error.");
+		mutex_unlock(&akm->sensor_mutex);
+		/***** unlock *****/
+
+		return IRQ_HANDLED;
+	}
+	/* Check ST bit */
+	if (!(AKM_DRDY_IS_HIGH(buffer[0])))
+		goto work_func_none;
+
+	memcpy(akm->sense_data, buffer, AKM_SENSOR_DATA_SIZE);
+
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+	atomic_set(&akm->drdy, 1);
+	wake_up(&akm->drdy_wq);
+
+	dev_vdbg(&akm->i2c->dev, "IRQ handled.");
+	return IRQ_HANDLED;
+
+work_func_none:
+	mutex_unlock(&akm->sensor_mutex);
+	/***** unlock *****/
+
+	dev_vdbg(&akm->i2c->dev, "IRQ not handled.");
+	return IRQ_NONE;
+}
+
+static int akm_compass_suspend(struct device *dev)
+{
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (AKM_IS_MAG_DATA_ENABLED() && akm->auto_report) {
+		if (akm->use_hrtimer)
+			hrtimer_cancel(&akm->poll_timer);
+		else
+			cancel_delayed_work_sync(&akm->dwork);
+	}
+
+	ret = AKECS_SetMode(akm, AKM_MODE_POWERDOWN);
+	if (ret)
+		dev_warn(&akm->i2c->dev, "Failed to set to POWERDOWN mode.\n");
+
+	akm->state.power_on = akm->power_enabled;
+	if (akm->state.power_on)
+		akm_compass_power_set(akm, false);
+
+	ret = pinctrl_select_state(akm->pinctrl, akm->pin_sleep);
+	if (ret)
+		dev_err(dev, "Can't select pinctrl state\n");
+
+	dev_dbg(&akm->i2c->dev, "suspended\n");
+
+	return ret;
+}
+
+static int akm_compass_resume(struct device *dev)
+{
+	struct akm_compass_data *akm = dev_get_drvdata(dev);
+	int ret = 0;
+	uint8_t mode;
+
+	ret = pinctrl_select_state(akm->pinctrl, akm->pin_default);
+	if (ret)
+		dev_err(dev, "Can't select pinctrl state\n");
+
+	if (akm->state.power_on) {
+		ret = akm_compass_power_set(akm, true);
+		if (ret) {
+			dev_err(dev, "Sensor power resume fail!\n");
+			goto exit;
+		}
+
+		if (AKM_IS_MAG_DATA_ENABLED() && akm->auto_report) {
+			mode = akm_select_frequency(akm->delay[MAG_DATA_FLAG]);
+			ret = AKECS_SetMode(akm, mode);
+			if (ret < 0) {
+				dev_err(&akm->i2c->dev, "Failed to set to mode(%d)\n",
+						mode);
+				goto exit;
+			}
+			if (akm->use_hrtimer)
+				hrtimer_start(&akm->poll_timer,
+					ns_to_ktime(akm->delay[MAG_DATA_FLAG]),
+					HRTIMER_MODE_REL);
+			else
+				queue_delayed_work(akm->work_queue, &akm->dwork,
+					(unsigned long)nsecs_to_jiffies64(
+						akm->delay[MAG_DATA_FLAG]));
+		}
+	}
+
+	dev_dbg(&akm->i2c->dev, "resumed\n");
+
+exit:
+	return ret;
+}
+
+static int akm09911_i2c_check_device(struct i2c_client *client)
+{
+	/* AK09911 specific function */
+	struct akm_compass_data *akm                = i2c_get_clientdata(client);
+	int                      err                = 0;
+    char*                    akm_compass_device = "UNKNOWN";
+
+    printk("%s:%d, ACHEUL, checking device", __FUNCTION__, __LINE__);
+
+	akm->sense_info[0] = AK09911_REG_WIA1;
+	err                = akm_i2c_rxdata(client, akm->sense_info, AKM_SENSOR_INFO_SIZE);
+
+	if (err < 0){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, err);
+		return err;
+    }
+
+	/* Check read data */
+    switch (akm->sense_info[1])
+    {
+        case AK09911_WIA2_VALUE: akm_compass_device = "AK09911";
+                                 break;
+        case AK09916_WIA2_VALUE: akm_compass_device = "AK09916";
+                                 break;
+        case AK09919_WIA2_VALUE: akm_compass_device = "AK09919";
+                                 break;
+        default                : dev_err(&client->dev, "The device is not AKM Compass WIA2(0x%02x)", akm->sense_info[1]);
+                                 printk("%s:%d, ACHEUL, unsupported compass: 0x%02X", __FUNCTION__, __LINE__, akm->sense_info[1]);
+                                 return -ENXIO;
+    }
+
+    dev_info(&client->dev, "AKM-Chip is: %s", akm_compass_device);
+    printk  ("%s:%d, ACHEUL, AKM-Chip is: %s", __FUNCTION__, __LINE__, akm_compass_device);
+
+	/* ak9916 don't need read fuse, is value fixed 0x00 */
+	if ((akm->sense_info[1] == AK09916_WIA2_VALUE) ||
+        (akm->sense_info[1] == AK09919_WIA2_VALUE)  )
+    {
+		akm->sense_conf[0] = akm->sense_conf[1] = akm->sense_conf[2] = 0x00;
+	}
+	else
+	{
+		/* Set FUSE access mode */
+		err = AKECS_SetMode(akm, AK09911_MODE_FUSE_ACCESS);
+		if (err < 0)
+			return err;
+
+		akm->sense_conf[0] = AK09911_FUSE_ASAX;
+		err = akm_i2c_rxdata(client, akm->sense_conf, AKM_SENSOR_CONF_SIZE);
+		if (err < 0)
+			return err;
+		}
+
+	err = AKECS_SetMode(akm, AK09911_MODE_POWERDOWN);
+	if (err < 0)
+    {
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, err);
+		return err;
+    }
+
+    printk("%s:%d, ACHEUL, device checked", __FUNCTION__, __LINE__);
+	return err;
+}// akm09911_i2c_check_device
+
+static int akm_compass_power_set(struct akm_compass_data *data, bool on)
+{
+	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	if (!on && data->power_enabled) {
+#ifdef AKM_REGULATOR_CONTROL_ENABLE
+		rc = regulator_disable(data->vdd);
+		if (rc) {
+			dev_err(&data->i2c->dev,
+				"Regulator vdd disable failed rc=%d\n", rc);
+			goto err_vdd_disable;
+		}
+
+		rc = regulator_disable(data->vio);
+		if (rc) {
+			dev_err(&data->i2c->dev,
+				"Regulator vio disable failed rc=%d\n", rc);
+			goto err_vio_disable;
+		}
+#endif
+		data->power_enabled = false;
+		return rc;
+	} else if (on && !data->power_enabled) {
+#ifdef AKM_REGULATOR_CONTROL_ENABLE
+		rc = regulator_enable(data->vdd);
+		if (rc) {
+			dev_err(&data->i2c->dev,
+				"Regulator vdd enable failed rc=%d\n", rc);
+			goto err_vdd_enable;
+		}
+
+		rc = regulator_enable(data->vio);
+		if (rc) {
+			dev_err(&data->i2c->dev,
+				"Regulator vio enable failed rc=%d\n", rc);
+			goto err_vio_enable;
+		}
+#endif
+		data->power_enabled = true;
+
+		/*
+		 * The max time for the power supply rise time is 50ms.
+		 * Use 80ms to make sure it meets the requirements.
+		 */
+		msleep(80);
+		return rc;
+	} else {
+		dev_warn(&data->i2c->dev,
+				"Power on=%d. enabled=%d\n",
+				on, data->power_enabled);
+		return rc;
+	}
+
+#ifdef AKM_REGULATOR_CONTROL_ENABLE
+err_vio_enable:
+	regulator_disable(data->vio);
+err_vdd_enable:
+	return rc;
+
+err_vio_disable:
+	if (regulator_enable(data->vdd))
+		dev_warn(&data->i2c->dev, "Regulator vdd enable failed\n");
+err_vdd_disable:
+#endif
+	return rc;
+}
+
+static int akm_compass_power_init(struct akm_compass_data *data, bool on)
+{
+	int rc;
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	if (!on) {
+		if (regulator_count_voltages(data->vdd) > 0)
+			regulator_set_voltage(data->vdd, 0,
+				AKM09911_VDD_MAX_UV);
+
+		regulator_put(data->vdd);
+
+		if (regulator_count_voltages(data->vio) > 0)
+			regulator_set_voltage(data->vio, 0,
+				AKM09911_VIO_MAX_UV);
+
+		regulator_put(data->vio);
+
+	} else {
+		data->vdd = regulator_get(&data->i2c->dev, "vdd");
+		if (IS_ERR(data->vdd)) {
+			rc = PTR_ERR(data->vdd);
+			dev_err(&data->i2c->dev,
+				"Regulator get failed vdd rc=%d\n", rc);
+			return rc;
+		}
+
+		if (regulator_count_voltages(data->vdd) > 0) {
+			rc = regulator_set_voltage(data->vdd,
+				AKM09911_VDD_MIN_UV, AKM09911_VDD_MAX_UV);
+			if (rc) {
+				dev_err(&data->i2c->dev,
+					"Regulator set failed vdd rc=%d\n",
+					rc);
+				goto reg_vdd_put;
+			}
+		}
+
+		data->vio = regulator_get(&data->i2c->dev, "vio");
+		if (IS_ERR(data->vio)) {
+			rc = PTR_ERR(data->vio);
+			dev_err(&data->i2c->dev,
+				"Regulator get failed vio rc=%d\n", rc);
+			goto reg_vdd_set;
+		}
+
+		if (regulator_count_voltages(data->vio) > 0) {
+			rc = regulator_set_voltage(data->vio,
+				AKM09911_VIO_MIN_UV, AKM09911_VIO_MAX_UV);
+			if (rc) {
+				dev_err(&data->i2c->dev,
+				"Regulator set failed vio rc=%d\n", rc);
+				goto reg_vio_put;
+			}
+		}
+	}
+
+	return 0;
+
+reg_vio_put:
+	regulator_put(data->vio);
+reg_vdd_set:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, AKM09911_VDD_MAX_UV);
+reg_vdd_put:
+	regulator_put(data->vdd);
+	return rc;
+}
+
+#ifdef CONFIG_OF
+static int akm_compass_parse_dt(struct device *dev, struct akm_compass_data *akm)
+{
+	struct device_node *np = dev->of_node;
+	u32 temp_val;
+	int rc;
+    printk("%s:%d, ACHEUL in", __FUNCTION__, __LINE__);
+
+	rc = of_property_read_u32(np, "akm,layout", &temp_val);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read akm,layout\n");
+		return rc;
+	} else {
+		akm->layout = temp_val;
+	}
+
+	akm->auto_report = of_property_read_bool(np, "akm,auto-report");
+	akm->use_hrtimer = of_property_read_bool(np, "akm,use-hrtimer");
+	akm->gpio_rstn   = of_get_named_gpio_flags(dev->of_node, "akm,gpio_rstn", 0, NULL);
+
+#if 0
+	if (!gpio_is_valid(akm->gpio_rstn)) {
+		dev_err(dev, "gpio reset pin %d is invalid.\n", akm->gpio_rstn);
+		return -EINVAL;
+	}
+#endif // 0
+
+    printk("%s:%d, ACHEUL out", __FUNCTION__, __LINE__);
+	return 0;
+}
+#else
+static int akm_compass_parse_dt(struct device *dev,
+				struct akm_compass_data *akm)
+{
+	return -EINVAL;
+}
+#endif /* !CONFIG_OF */
+
+static int akm_pinctrl_init(struct akm_compass_data *akm)
+{
+	struct i2c_client *client = akm->i2c;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	akm->pinctrl = devm_pinctrl_get(&client->dev);
+	if (IS_ERR_OR_NULL(akm->pinctrl)) {
+		dev_err(&client->dev, "Failed to get pinctrl\n");
+		return PTR_ERR(akm->pinctrl);
+	}
+
+	akm->pin_default = pinctrl_lookup_state(akm->pinctrl, "default");
+	if (IS_ERR_OR_NULL(akm->pin_default)) {
+		dev_err(&client->dev, "Failed to look up default state\n");
+		return PTR_ERR(akm->pin_default);
+	}
+
+	akm->pin_sleep = pinctrl_lookup_state(akm->pinctrl, "sleep");
+	if (IS_ERR_OR_NULL(akm->pin_sleep)) {
+		dev_err(&client->dev, "Failed to look up sleep state\n");
+		return PTR_ERR(akm->pin_sleep);
+	}
+
+	return 0;
+}
+
+static int akm_report_data(struct akm_compass_data *akm)
+{
+	uint8_t dat_buf[AKM_SENSOR_DATA_SIZE];/* for GET_DATA */
+	int ret;
+	int mag_x, mag_y, mag_z;
+	int tmp;
+	uint8_t mode;
+
+    printk("%s:%d, ACHEUL in", __FUNCTION__, __LINE__);
+
+	ret = AKECS_GetData_Poll(akm, dat_buf, AKM_SENSOR_DATA_SIZE);
+	if (ret) {
+		dev_err(&akm->i2c->dev, "Get data failed.\n");
+		return -EIO;
+	}
+
+	if (STATUS_ERROR(dat_buf[8])) {
+		dev_warn(&akm->i2c->dev, "Status error. Reset...\n");
+		AKECS_Reset(akm, 0);
+		mode = akm_select_frequency(akm->delay[MAG_DATA_FLAG]);
+		AKECS_SetMode(akm, mode);
+
+		return -EIO;
+	}
+
+	if(akm->auto_report)
+		get_monotonic_boottime(&akm->ts);
+
+	tmp = (int)((int16_t)(dat_buf[2]<<8)+((int16_t)dat_buf[1]));
+	tmp = tmp * akm->sense_conf[0] / 128 + tmp;
+	mag_x = tmp;
+
+	tmp = (int)((int16_t)(dat_buf[4]<<8)+((int16_t)dat_buf[3]));
+	tmp = tmp * akm->sense_conf[1] / 128 + tmp;
+	mag_y = tmp;
+
+	tmp = (int)((int16_t)(dat_buf[6]<<8)+((int16_t)dat_buf[5]));
+	tmp = tmp * akm->sense_conf[2] / 128 + tmp;
+	mag_z = tmp;
+
+	dev_dbg(&akm->i2c->dev, "mag_x:%d mag_y:%d mag_z:%d\n",
+			mag_x, mag_y, mag_z);
+	dev_dbg(&akm->i2c->dev, "raw data: %d %d %d %d %d %d %d %d\n",
+			dat_buf[0], dat_buf[1], dat_buf[2], dat_buf[3],
+			dat_buf[4], dat_buf[5], dat_buf[6], dat_buf[7]);
+	dev_dbg(&akm->i2c->dev, "asa: %d %d %d\n", akm->sense_conf[0],
+			akm->sense_conf[1], akm->sense_conf[2]);
+
+    printk("%s:%d, ACHEUL, report data: mag_x: %d mag_y: %d mag_z: %d", __FUNCTION__, __LINE__,  mag_x, mag_y, mag_z);
+
+	switch (akm->layout) {
+	case 0:
+	case 1:
+		/* Fall into the default direction */
+		break;
+	case 2:
+		tmp = mag_x;
+		mag_x = mag_y;
+		mag_y = -tmp;
+		break;
+	case 3:
+		mag_x = -mag_x;
+		mag_y = -mag_y;
+		break;
+	case 4:
+		tmp = mag_x;
+		mag_x = -mag_y;
+		mag_y = tmp;
+		break;
+	case 5:
+		mag_x = -mag_x;
+		mag_z = -mag_z;
+		break;
+	case 6:
+		tmp = mag_x;
+		mag_x = mag_y;
+		mag_y = tmp;
+		mag_z = -mag_z;
+		break;
+	case 7:
+		mag_y = -mag_y;
+		mag_z = -mag_z;
+		break;
+	case 8:
+		tmp = mag_x;
+		mag_x = -mag_y;
+		mag_y = -tmp;
+		mag_z = -mag_z;
+		break;
+	}
+
+	input_report_abs(akm->input, ABS_X, mag_x);
+	input_report_abs(akm->input, ABS_Y, mag_y);
+	input_report_abs(akm->input, ABS_Z, mag_z);
+	input_event(akm->input,	EV_REL, SYN_TIME_SEC, akm->ts.tv_sec);
+	input_event(akm->input,	EV_REL, SYN_TIME_NSEC, akm->ts.tv_nsec);
+
+	/* avoid eaten by input subsystem framework */
+	if ((mag_x == akm->last_x) && (mag_y == akm->last_y) &&
+			(mag_z == akm->last_z))
+		input_report_abs(akm->input, ABS_MISC, akm->rep_cnt++);
+
+	akm->last_x = mag_x;
+	akm->last_y = mag_y;
+	akm->last_z = mag_z;
+
+	input_sync(akm->input);
+
+    printk("%s:%d, ACHEUL out", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+static void akm_dev_poll(struct work_struct *work)
+{
+	struct akm_compass_data *akm;
+	int ret;
+
+	akm = container_of((struct delayed_work *)work, struct akm_compass_data,  dwork);
+
+	ret = akm_report_data(akm);
+	if (ret < 0) {
+		dev_warn(&akm->i2c->dev, "Failed to report data\n");
+    }
+
+	if (!akm->use_hrtimer) {
+		queue_delayed_work(akm->work_queue, &akm->dwork, (unsigned long)nsecs_to_jiffies64(akm->delay[MAG_DATA_FLAG]));
+    }
+}
+
+static enum hrtimer_restart akm_timer_func(struct hrtimer *timer)
+{
+	struct akm_compass_data *akm;
+
+	akm = container_of(timer, struct akm_compass_data, poll_timer);
+
+	queue_work(akm->work_queue, &akm->dwork.work);
+	hrtimer_forward_now(&akm->poll_timer,
+			ns_to_ktime(akm->delay[MAG_DATA_FLAG]));
+
+	return HRTIMER_RESTART;
+}
+
+static int case_test(struct akm_compass_data *akm, const char test_name[],
+		const int testdata, const int lo_limit, const int hi_limit,
+		int *fail_total)
+{
+	/* Pass:0, Fail:-1 */
+	int result = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	if (fail_total == NULL)
+		return -EINVAL;
+
+	if (strcmp(test_name, "START") == 0) {
+		dev_dbg(&akm->i2c->dev, "----------------------------------------------------------\n");
+		dev_dbg(&akm->i2c->dev, "Test Name    Fail    Test Data    [      Low         High]\n");
+		dev_dbg(&akm->i2c->dev, "----------------------------------------------------------\n");
+	} else if (strcmp(test_name, "END") == 0) {
+		dev_dbg(&akm->i2c->dev, "----------------------------------------------------------\n");
+		if (*fail_total == 0)
+			dev_dbg(&akm->i2c->dev, "Factory shipment test passed.\n\n");
+		else
+			dev_dbg(&akm->i2c->dev, "%d test cases failed.\n\n",
+					*fail_total);
+	} else {
+		if ((testdata < lo_limit) || (testdata > hi_limit)) {
+			result = -1;
+			*fail_total += 1;
+		}
+
+		dev_dbg(&akm->i2c->dev, " %-10s      %c    %9d    [%9d    %9d]\n",
+				 test_name, ((result == 0) ? ('.') : ('F')),
+				 testdata, lo_limit, hi_limit);
+	}
+
+	return result;
+}
+
+static int akm_self_test(struct sensors_classdev *sensors_cdev)
+{
+	struct akm_compass_data *akm = container_of(sensors_cdev,
+			struct akm_compass_data, cdev);
+	uint8_t i2c_data[AKM_SENSOR_DATA_SIZE];
+	int hdata[AKM09911_AXIS_COUNT];
+	int asax, asay, asaz;
+	int count;
+	int ret;
+	int fail_total = 0;
+	uint8_t mode;
+	bool power_enabled = akm->power_enabled ? true : false;
+
+	mutex_lock(&akm->op_mutex);
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+	asax = akm->sense_conf[AKM09911_AXIS_X];
+	asay = akm->sense_conf[AKM09911_AXIS_Y];
+	asaz = akm->sense_conf[AKM09911_AXIS_Z];
+
+	if (!power_enabled) {
+		ret = akm_compass_power_set(akm, true);
+		if (ret) {
+			dev_err(&akm->i2c->dev, "Power up failed.\n");
+			goto exit;
+		}
+	} else {
+		i2c_data[0] = AKM_REG_MODE;
+		ret = akm_i2c_rxdata(akm->i2c, i2c_data, 1);
+		if (ret < 0) {
+			dev_err(&akm->i2c->dev, "Get mode failed.\n");
+			goto exit;
+		}
+		mode = i2c_data[1];
+	}
+
+	ret = AKECS_Reset(akm, 0);
+	if (ret < 0) {
+		dev_err(&akm->i2c->dev, "Reset failed.\n");
+		goto exit;
+	}
+
+	/* start test */
+	case_test(akm, "START", 0, 0, 0, &fail_total);
+
+	case_test(akm, TLIMIT_TN_ASAX_09911, asax, TLIMIT_LO_ASAX_09911,
+			TLIMIT_HI_ASAX_09911, &fail_total);
+	case_test(akm, TLIMIT_TN_ASAY_09911, asay, TLIMIT_LO_ASAY_09911,
+			TLIMIT_HI_ASAY_09911, &fail_total);
+	case_test(akm, TLIMIT_TN_ASAZ_09911, asaz, TLIMIT_LO_ASAZ_09911,
+			TLIMIT_HI_ASAZ_09911, &fail_total);
+
+	ret = AKECS_SetMode(akm, AK09911_MODE_SNG_MEASURE);
+	if (ret < 0) {
+		dev_err(&akm->i2c->dev, "Set to single measurement failed.\n");
+		goto exit;
+	}
+
+	count = AKM09911_RETRY_COUNT;
+	do {
+		/* The typical time for single measurement is 7.2ms */
+		ret = AKECS_GetData_Poll(akm, i2c_data, AKM_SENSOR_DATA_SIZE);
+		if (ret == -EAGAIN)
+			usleep_range(1000, 10000);
+	} while ((ret == -EAGAIN) && (--count));
+
+	if (!count) {
+		dev_err(&akm->i2c->dev, "Timeout get valid data.\n");
+		goto exit;
+	}
+
+	hdata[AKM09911_AXIS_X] = (s16)(i2c_data[1] | (i2c_data[2] << 8));
+	hdata[AKM09911_AXIS_Y] = (s16)(i2c_data[3] | (i2c_data[4] << 8));
+	hdata[AKM09911_AXIS_Z] = (s16)(i2c_data[5] | (i2c_data[6] << 8));
+
+	i2c_data[0] &= 0x7F;
+	case_test(akm, TLIMIT_TN_SNG_ST1_09911,
+	       (int)i2c_data[0], TLIMIT_LO_SNG_ST1_09911,
+		TLIMIT_HI_SNG_ST1_09911, &fail_total);
+
+	case_test(akm, TLIMIT_TN_SNG_HX_09911, hdata[0], TLIMIT_LO_SNG_HX_09911,
+			TLIMIT_HI_SNG_HX_09911, &fail_total);
+	case_test(akm, TLIMIT_TN_SNG_HY_09911, hdata[1], TLIMIT_LO_SNG_HY_09911,
+			TLIMIT_HI_SNG_HY_09911, &fail_total);
+	case_test(akm, TLIMIT_TN_SNG_HZ_09911, hdata[2], TLIMIT_LO_SNG_HZ_09911,
+			TLIMIT_HI_SNG_HZ_09911, &fail_total);
+
+	case_test(akm, TLIMIT_TN_SNG_ST2_09911, (int)i2c_data[8],
+			TLIMIT_LO_SNG_ST2_09911, TLIMIT_HI_SNG_ST2_09911,
+			&fail_total);
+
+	/* self-test mode */
+	ret = AKECS_SetMode(akm, AK09911_MODE_SELF_TEST);
+	if (ret < 0) {
+		dev_err(&akm->i2c->dev, "Set to self test mode failed\n");
+		goto exit;
+	}
+
+	count = AKM09911_RETRY_COUNT;
+	do {
+		/* The typical time for single measurement is 7.2ms */
+		ret = AKECS_GetData_Poll(akm, i2c_data, AKM_SENSOR_DATA_SIZE);
+		if (ret == -EAGAIN)
+			usleep_range(1000, 10000);
+	} while ((ret == -EAGAIN) && (--count));
+
+	if (!count) {
+		dev_err(&akm->i2c->dev, "Timeout get valid data.\n");
+		goto exit;
+	}
+
+	i2c_data[0] &= 0x7F;
+
+	case_test(akm, TLIMIT_TN_SLF_ST1_09911, (int)i2c_data[0],
+			TLIMIT_LO_SLF_ST1_09911, TLIMIT_HI_SLF_ST1_09911,
+			&fail_total);
+
+	hdata[AKM09911_AXIS_X] = (s16)(i2c_data[1] | (i2c_data[2] << 8));
+	hdata[AKM09911_AXIS_Y] = (s16)(i2c_data[3] | (i2c_data[4] << 8));
+	hdata[AKM09911_AXIS_Z] = (s16)(i2c_data[5] | (i2c_data[6] << 8));
+
+	case_test(akm, TLIMIT_TN_SLF_RVHX_09911, (hdata[0])*(asax/128 + 1),
+			TLIMIT_LO_SLF_RVHX_09911, TLIMIT_HI_SLF_RVHX_09911,
+			&fail_total);
+
+	case_test(akm, TLIMIT_TN_SLF_RVHY_09911, (hdata[1])*(asay/128 + 1),
+			TLIMIT_LO_SLF_RVHY_09911, TLIMIT_HI_SLF_RVHY_09911,
+			&fail_total);
+
+	case_test(akm, TLIMIT_TN_SLF_RVHZ_09911, (hdata[2])*(asaz/128 + 1),
+			TLIMIT_LO_SLF_RVHZ_09911, TLIMIT_HI_SLF_RVHZ_09911,
+			&fail_total);
+
+	case_test(akm, TLIMIT_TN_SLF_ST2_09911, (int)i2c_data[8],
+			TLIMIT_LO_SLF_ST2_09911, TLIMIT_HI_SLF_ST2_09911,
+			&fail_total);
+
+	case_test(akm, "END", 0, 0, 0, &fail_total);
+	/* clean up */
+	if (!power_enabled) {
+		ret = akm_compass_power_set(akm, false);
+		if (ret) {
+			dev_err(&akm->i2c->dev, "Power down failed.\n");
+			goto exit;
+		}
+	} else {
+		/* Set measure mode */
+		i2c_data[0] = AKM_REG_MODE;
+		i2c_data[1] = mode;
+		ret = akm_i2c_txdata(akm->i2c, i2c_data, 2);
+		if (ret < 0) {
+			dev_err(&akm->i2c->dev, "restore mode failed\n");
+			goto exit;
+		}
+	}
+
+exit:
+	mutex_unlock(&akm->op_mutex);
+	return ((fail_total > 0) || ret) ? -EIO : 0;
+}
+
+int akm_compass_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct akm09911_platform_data *pdata;
+	int err = 0;
+	int i;
+
+    printk("%s:%d, printk ACHEUL in", __FUNCTION__, __LINE__);
+	dev_dbg(&client->dev, "\nACHEUL dev_dbg start probing.\n");
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev,
+				"%s: check_functionality failed.", __func__);
+		err = -ENODEV;
+		goto exit0;
+	}
+
+	/* Allocate memory for driver data */
+	s_akm = kzalloc(sizeof(struct akm_compass_data), GFP_KERNEL);
+	if (!s_akm) {
+		dev_err(&client->dev,
+				"%s: memory allocation failed.", __func__);
+		err = -ENOMEM;
+		goto exit1;
+	}
+
+	/**** initialize variables in akm_compass_data *****/
+	init_waitqueue_head(&s_akm->drdy_wq);
+	init_waitqueue_head(&s_akm->open_wq);
+
+	mutex_init(&s_akm->sensor_mutex);
+	mutex_init(&s_akm->accel_mutex);
+	mutex_init(&s_akm->val_mutex);
+	mutex_init(&s_akm->op_mutex);
+
+	atomic_set(&s_akm->active, 0);
+	atomic_set(&s_akm->drdy, 0);
+
+	s_akm->enable_flag = 0;
+
+	/* Set to 1G in Android coordination, AKSC format */
+	s_akm->accel_data[0] = 0;
+	s_akm->accel_data[1] = 0;
+	s_akm->accel_data[2] = 720;
+
+	for (i = 0; i < AKM_NUM_SENSORS; i++)
+		s_akm->delay[i] = -1;
+
+	if (client->dev.of_node) {
+		err = akm_compass_parse_dt(&client->dev, s_akm);
+		if (err) {
+			dev_err(&client->dev,
+				"Unable to parse platfrom data err=%d\n", err);
+			goto exit2;
+		}
+	} else {
+		if (client->dev.platform_data) {
+			/* Copy platform data to local. */
+			pdata = client->dev.platform_data;
+			s_akm->layout = pdata->layout;
+			s_akm->gpio_rstn = pdata->gpio_RSTN;
+		} else {
+		/* Platform data is not available.
+		   Layout and information should be set by each application. */
+			s_akm->layout = 0;
+			s_akm->gpio_rstn = 0;
+			dev_warn(&client->dev, "%s: No platform data.",
+				__func__);
+		}
+	}
+
+	/***** I2C initialization *****/
+	s_akm->i2c = client;
+	/* set client data */
+	i2c_set_clientdata(client, s_akm);
+
+	/* initialize pinctrl */
+	if (!akm_pinctrl_init(s_akm)) {
+		err = pinctrl_select_state(s_akm->pinctrl, s_akm->pin_default);
+		if (err) {
+			dev_err(&client->dev, "Can't select pinctrl state\n");
+			goto exit2;
+		}
+	}
+
+	/* Pull up the reset pin */
+	AKECS_Reset(s_akm, 0);
+
+	/* check connection */
+	err = akm_compass_power_init(s_akm, 1);
+	if (err < 0)
+		goto exit2;
+	err = akm_compass_power_set(s_akm, 1);
+	if (err < 0)
+		goto exit3;
+
+	err = akm09911_i2c_check_device(client);
+	if (err < 0)
+		goto exit4;
+
+	/***** input *****/
+	err = akm_compass_input_init(&s_akm->input);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: input_dev register failed", __func__);
+		goto exit4;
+	}
+	input_set_drvdata(s_akm->input, s_akm);
+
+	/***** IRQ setup *****/
+	s_akm->irq = client->irq;
+
+	dev_dbg(&client->dev, "%s: IRQ is #%d.",
+			__func__, s_akm->irq);
+
+	if (s_akm->irq) {
+		err = request_threaded_irq(
+				s_akm->irq,
+				NULL,
+				akm_compass_irq,
+				IRQF_TRIGGER_HIGH|IRQF_ONESHOT,
+				dev_name(&client->dev),
+				s_akm);
+		if (err < 0) {
+			dev_err(&client->dev,
+				"%s: request irq failed.", __func__);
+			goto exit5;
+		}
+	} else if (s_akm->auto_report) {
+
+        printk("%s:%d, ACHEUL, auto report", __FUNCTION__, __LINE__);
+
+		if (s_akm->use_hrtimer) {
+			hrtimer_init(&s_akm->poll_timer, CLOCK_MONOTONIC,
+					HRTIMER_MODE_REL);
+			s_akm->poll_timer.function = akm_timer_func;
+			s_akm->work_queue = alloc_workqueue("akm_poll_work",
+				WQ_UNBOUND | WQ_MEM_RECLAIM | WQ_HIGHPRI, 1);
+			INIT_WORK(&s_akm->dwork.work, akm_dev_poll);
+		} else {
+			s_akm->work_queue = alloc_workqueue("akm_poll_work", 0, 0);
+			INIT_DELAYED_WORK(&s_akm->dwork, akm_dev_poll);
+		}
+	}
+
+	/***** misc *****/
+	err = misc_register(&akm_compass_dev);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: akm_compass_dev register failed", __func__);
+		goto exit6;
+	}
+
+	/***** sysfs *****/
+	err = create_sysfs_interfaces(s_akm);
+	if (0 > err) {
+		dev_err(&client->dev,
+			"%s: create sysfs failed.", __func__);
+		goto exit7;
+	}
+
+	s_akm->cdev = sensors_cdev;
+	s_akm->cdev.sensors_enable = akm_enable_set;
+	s_akm->cdev.sensors_poll_delay = akm_poll_delay_set;
+	s_akm->cdev.sensors_self_test = akm_self_test;
+	s_akm->cdev.sensors_flush = akm_flush_set;
+
+	s_akm->delay[MAG_DATA_FLAG] = sensors_cdev.delay_msec * 1000000;
+
+	err = sensors_classdev_register(&client->dev, &s_akm->cdev);
+
+	if (err) {
+		dev_err(&client->dev, "class device create failed: %d\n", err);
+		goto exit8;
+	}
+
+	akm_compass_power_set(s_akm, true);
+
+	dev_info(&client->dev, "successfully probed.");
+	return 0;
+
+exit8:
+	remove_sysfs_interfaces(s_akm);
+exit7:
+	misc_deregister(&akm_compass_dev);
+exit6:
+	if (s_akm->irq)
+		free_irq(s_akm->irq, s_akm);
+exit5:
+	input_unregister_device(s_akm->input);
+exit4:
+	akm_compass_power_set(s_akm, 0);
+exit3:
+	akm_compass_power_init(s_akm, 0);
+exit2:
+	kfree(s_akm);
+exit1:
+exit0:
+
+    printk("%s:%d, printk ACHEUL out: %d", __FUNCTION__, __LINE__, err);
+	return err;
+}
+
+static int akm_compass_remove(struct i2c_client *client)
+{
+	struct akm_compass_data *akm = i2c_get_clientdata(client);
+
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	if (akm->auto_report) {
+		if (akm->use_hrtimer) {
+			hrtimer_cancel(&akm->poll_timer);
+			cancel_work_sync(&akm->dwork.work);
+		} else {
+			cancel_delayed_work_sync(&akm->dwork);
+		}
+		destroy_workqueue(akm->work_queue);
+	}
+
+	if (akm_compass_power_set(akm, 0))
+		dev_err(&client->dev, "power set failed.");
+	if (akm_compass_power_init(akm, 0))
+		dev_err(&client->dev, "power deinit failed.");
+	remove_sysfs_interfaces(akm);
+	sensors_classdev_unregister(&akm->cdev);
+
+    // ACHEUL
+	//if (misc_deregister(&akm_compass_dev) < 0)
+    //    dev_err(&client->dev, "misc deregister failed.");
+	misc_deregister(&akm_compass_dev);
+    // ACHEUL
+
+	if (akm->irq)
+		free_irq(akm->irq, akm);
+	input_unregister_device(akm->input);
+	kfree(akm);
+	dev_info(&client->dev, "successfully removed.");
+	return 0;
+}
+
+static const struct i2c_device_id akm_compass_id[] = {
+	{AKM_I2C_NAME, 0 },
+	{ }
+};
+
+static const struct dev_pm_ops akm_compass_pm_ops = {
+	.suspend	= akm_compass_suspend,
+	.resume		= akm_compass_resume,
+};
+
+static struct of_device_id akm09911_match_table[] = {
+	{ .compatible = "ak,ak09911", },
+	{ },
+};
+
+static struct i2c_driver akm_compass_driver = {
+	.probe		= akm_compass_probe,
+	.remove		= akm_compass_remove,
+	.id_table	= akm_compass_id,
+	.driver = {
+		.name	= AKM_I2C_NAME,
+		.owner  = THIS_MODULE,
+		.of_match_table = akm09911_match_table,
+		.pm		= &akm_compass_pm_ops,
+	},
+};
+
+static int __init akm_compass_init(void)
+{
+    int ret = 0;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	pr_info("AKM compass driver: initialize.");
+    ret = i2c_add_driver(&akm_compass_driver);
+
+    printk("%s:%d, ACHEUL ret: %d", __FUNCTION__, __LINE__, ret);
+
+	return ret;
+}
+
+static void __exit akm_compass_exit(void)
+{
+    printk("%s:%d, ACHEUL\n", __FUNCTION__, __LINE__);
+	pr_info("%s:%d, AKM compass driver: release.", __FUNCTION__, __LINE__);
+	i2c_del_driver(&akm_compass_driver);
+}
+
+module_init(akm_compass_init);
+module_exit(akm_compass_exit);
+
+MODULE_AUTHOR("Bruno Gauthier <bruno.gauthier@acheul.com>");
+MODULE_DESCRIPTION("ACHEUL AKM compass driver");
+MODULE_LICENSE("GPL");
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: apanel.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: arizona-haptics.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: ati_remote2.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: atlas_btns.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: atmel_captouch.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: axp20x-pek.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: bma150.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: cm109.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: cma3000_d0x.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: cma3000_d0x.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: cma3000_d0x_i2c.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: cobalt_btns.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: cpcap-pwrbutton.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: da9052_onkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: da9055_onkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: da9063_onkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: dm355evm_keys.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: drv260x.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: drv2665.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: drv2667.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: e3x0-button.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: gp2ap002a00f.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_axis.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio-beeper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_decoder.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_event.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_input.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_matrix.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: gpio_output.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: hisi_powerkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: hp_sdc_rtc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: ideapad_slidebar.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: ims-pcu.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: ixp4xx-beeper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: keyspan_remote.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: kxtj9.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: m68kspkr.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc/Makefile kernel/msm-4.19/drivers/input/misc/Makefile
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc/Makefile	2024-05-28 20:43:48.413490334 -0400
+++ kernel/msm-4.19/drivers/input/misc/Makefile	2024-05-29 22:10:12.925805754 -0400
@@ -84,3 +84,9 @@
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
 obj-$(CONFIG_INPUT_IDEAPAD_SLIDEBAR)	+= ideapad_slidebar.o
+###############################################
+## ACHEUL
+###############################################
+obj-$(CONFIG_SENSORS_AKM09911)  += akm09911.o
+obj-y += sensors_class.o
+###############################################
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: max77693-haptic.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: max8925_onkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: max8997_haptic.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: mc13783-pwrbutton.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: mma8450.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: palmas-pwrbutton.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: pcap_keys.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: pcf50633-input.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: pcf8574_keypad.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: pcspkr.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: pm8941-pwrkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: pm8xxx-vibrator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: pmic8xxx-pwrkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: powermate.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: pwm-beeper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: pwm-vibra.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: qpnp-power-on.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: qti-haptics.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: rave-sp-pwrbutton.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: rb532_button.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: regulator-haptic.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: retu-pwrbutton.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: rk805-pwrkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: rotary_encoder.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: sc27xx-vibra.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: sgi_btns.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: sirfsoc-onkey.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: soc_button_array.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: sparcspkr.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: tps65218-pwrbutton.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: twl4030-pwrbutton.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: twl4030-vibra.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: twl6040-vibra.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: uinput.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: wistron_btns.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: wm831x-on.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: xen-kbdfront.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: yealink.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input/misc: yealink.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: mouse
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: mousedev.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: rmi4
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: serio
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: sparse-keymap.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: tablet
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/input: touchscreen
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: iommu
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: ipack
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: irqchip
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: isdn
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: leds
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: lightnvm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: macintosh
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: mailbox
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: mcb
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: md
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: media
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: memory
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: memstick
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: message
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: mfd
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: misc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: mmc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: mtd
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: mux
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: net
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: nfc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: ntb
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: nubus
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: nvdimm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: nvme
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: nvmem
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: of
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: opp
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: oprofile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: parisc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: parport
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: pci
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: pcmcia
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: perf
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: phy
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: pinctrl
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: platform
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: pnp
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: power
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: powercap
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: pps
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: ps3
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: ptp
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: pwm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: rapidio
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: ras
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: 88pg86x.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: 88pm800.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: 88pm8607.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: aat2870-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: ab3100.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: ab8500.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: ab8500-ext.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: act8865-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: act8945a-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: ad5398.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: anatop-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: arizona-ldo1.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: arizona-micsupp.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: as3711-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: as3722-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: axp20x-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: bcm590xx-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: bd71837-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: bd9571mwv-regulator.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator/core.c kernel/msm-4.19/drivers/regulator/core.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator/core.c	2024-05-28 20:53:17.323639639 -0400
+++ kernel/msm-4.19/drivers/regulator/core.c	2024-05-29 22:10:12.905805578 -0400
@@ -1477,6 +1477,9 @@
 
 static int _regulator_get_enable_time(struct regulator_dev *rdev)
 {
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (rdev->constraints && rdev->constraints->enable_time)
 		return rdev->constraints->enable_time;
 	if (!rdev->desc->ops->enable_time)
@@ -1663,12 +1666,17 @@
 	const char *devname = dev ? dev_name(dev) : "deviceless";
 	int ret;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (get_type >= MAX_GET_TYPE) {
+
+        printk("%s:%d, ACHEUL invalid type", __FUNCTION__, __LINE__);
 		dev_err(dev, "invalid type %d in %s\n", get_type, __func__);
 		return ERR_PTR(-EINVAL);
 	}
 
 	if (id == NULL) {
+        printk("%s:%d, ACHEUL no identifier", __FUNCTION__, __LINE__);
 		pr_err("get() with no identifier\n");
 		return ERR_PTR(-EINVAL);
 	}
@@ -1681,10 +1689,13 @@
 		 * If regulator_dev_lookup() fails with error other
 		 * than -ENODEV our job here is done, we simply return it.
 		 */
-		if (ret != -ENODEV)
+		if (ret != -ENODEV){
+            printk("%s:%d, ACHEUL no device", __FUNCTION__, __LINE__);
 			return ERR_PTR(ret);
+        }
 
 		if (!have_full_constraints()) {
+            printk("%s:%d, ACHEUL incomplete constrainst", __FUNCTION__, __LINE__);
 			dev_warn(dev,
 				 "incomplete constraints, dummy supplies not allowed\n");
 			return ERR_PTR(-ENODEV);
@@ -1697,6 +1708,7 @@
 			 * enabled, even if it isn't hooked up, and just
 			 * provide a dummy.
 			 */
+            printk("%s:%d, ACHEUL normal using dummy", __FUNCTION__, __LINE__);
 			dev_warn(dev,
 				 "%s supply %s not found, using dummy regulator\n",
 				 devname, id);
@@ -1705,24 +1717,30 @@
 			break;
 
 		case EXCLUSIVE_GET:
+            printk("%s:%d, ACHEUL, exclusive", __FUNCTION__, __LINE__);
 			dev_warn(dev,
 				 "dummy supplies not allowed for exclusive requests\n");
 			/* fall through */
 
-		default:
+		default: {
+            printk("%s:%d, ACHEUL no device", __FUNCTION__, __LINE__);
 			return ERR_PTR(-ENODEV);
+        }
 		}
 	}
 
 	if (rdev->exclusive) {
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 		regulator = ERR_PTR(-EPERM);
 		put_device(&rdev->dev);
+        printk("%s:%d, ACHEUL eperm, %p", __FUNCTION__, __LINE__, regulator);
 		return regulator;
 	}
 
 	if (get_type == EXCLUSIVE_GET && rdev->open_count) {
 		regulator = ERR_PTR(-EBUSY);
 		put_device(&rdev->dev);
+        printk("%s:%d, ACHEUL ebusy, %p", __FUNCTION__, __LINE__, regulator);
 		return regulator;
 	}
 
@@ -1730,12 +1748,14 @@
 	if (ret < 0) {
 		regulator = ERR_PTR(ret);
 		put_device(&rdev->dev);
+        printk("%s:%d, ACHEUL resolve supply, %p", __FUNCTION__, __LINE__, regulator);
 		return regulator;
 	}
 
 	if (!try_module_get(rdev->owner)) {
 		regulator = ERR_PTR(-EPROBE_DEFER);
 		put_device(&rdev->dev);
+        printk("%s:%d, ACHEUL, eprobe defer, %p", __FUNCTION__, __LINE__, regulator);
 		return regulator;
 	}
 
@@ -1744,6 +1764,7 @@
 		regulator = ERR_PTR(-ENOMEM);
 		put_device(&rdev->dev);
 		module_put(rdev->owner);
+        printk("%s:%d, ACHEUL nomem, %p", __FUNCTION__, __LINE__, regulator);
 		return regulator;
 	}
 
@@ -1760,6 +1781,7 @@
 
 	device_link_add(dev, &rdev->dev, DL_FLAG_STATELESS);
 
+    printk("%s:%d, ACHEUL ret: %p", __FUNCTION__, __LINE__, regulator);
 	return regulator;
 }
 
@@ -3030,12 +3052,17 @@
 	int best_supply_uV = 0;
 	int supply_change_uV = 0;
 
+    printk("%s:%d, ACHEUL, min: %d, max: %d", __FUNCTION__, __LINE__, min_uV, max_uV);
+    printk("%s:%d, ACHEUL, min: %d, max: %d", __FUNCTION__, __LINE__, voltage->min_uV, voltage->max_uV);
+
 	/* If we're setting the same range as last time the change
 	 * should be a noop (some cpufreq implementations use the same
 	 * voltage for multiple frequencies, for example).
 	 */
-	if (voltage->min_uV == min_uV && voltage->max_uV == max_uV)
+	if (voltage->min_uV == min_uV && voltage->max_uV == max_uV){
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		goto out;
+    }
 
 	/* If we're trying to set a range that overlaps the current voltage,
 	 * return successfully even though the regulator does not support
@@ -3053,14 +3080,17 @@
 	/* sanity check */
 	if (!rdev->desc->ops->set_voltage &&
 	    !rdev->desc->ops->set_voltage_sel) {
+        printk("%s:%d, ACHEUL, error, set voltage: %d, set_voltage_sel: %d", __FUNCTION__, __LINE__, rdev->desc->ops->set_voltage, rdev->desc->ops->set_voltage_sel);
 		ret = -EINVAL;
 		goto out;
 	}
 
 	/* constraints check */
 	ret = regulator_check_voltage(rdev, &min_uV, &max_uV);
-	if (ret < 0)
+	if (ret < 0){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
 		goto out;
+    }
 
 	/* restore original values in case of error */
 	old_min_uV = voltage->min_uV;
@@ -3069,8 +3099,10 @@
 	voltage->max_uV = max_uV;
 
 	ret = regulator_check_consumers(rdev, &min_uV, &max_uV, state);
-	if (ret < 0)
+	if (ret < 0){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
 		goto out2;
+    }
 
 	if (rdev->supply &&
 	    regulator_ops_is_valid(rdev->supply->rdev,
@@ -3082,12 +3114,14 @@
 
 		selector = regulator_map_voltage(rdev, min_uV, max_uV);
 		if (selector < 0) {
+            printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 			ret = selector;
 			goto out2;
 		}
 
 		best_supply_uV = _regulator_list_voltage(rdev, selector, 0);
 		if (best_supply_uV < 0) {
+            printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 			ret = best_supply_uV;
 			goto out2;
 		}
@@ -3096,6 +3130,7 @@
 
 		current_supply_uV = _regulator_get_voltage(rdev->supply->rdev);
 		if (current_supply_uV < 0) {
+            printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 			ret = current_supply_uV;
 			goto out2;
 		}
@@ -3118,13 +3153,16 @@
 	else
 		ret = _regulator_do_set_suspend_voltage(rdev, min_uV,
 							max_uV, state);
-	if (ret < 0)
+	if (ret < 0){
+        printk("%s:%d, ACHEUL, error, ret: %d", __FUNCTION__, __LINE__, ret);
 		goto out2;
+    }
 
 	if (supply_change_uV < 0) {
 		ret = regulator_set_voltage_unlocked(rdev->supply,
 				best_supply_uV, INT_MAX, state);
 		if (ret)
+            printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
 			dev_warn(&rdev->dev, "Failed to decrease supply voltage: %d\n",
 					ret);
 		/* No need to fail here */
@@ -3132,11 +3170,13 @@
 	}
 
 out:
+    printk("%s:%d, ACHEUL, ret: %d", __FUNCTION__, __LINE__, ret);
 	return ret;
 out2:
 	voltage->min_uV = old_min_uV;
 	voltage->max_uV = old_max_uV;
 
+    printk("%s:%d, ACHEUL, ret: %d", __FUNCTION__, __LINE__, ret);
 	return ret;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: cpcap-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: da903x.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: da9052-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: da9055-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: da9062-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: da9063-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: da9210-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: da9210-regulator.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: da9211-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: da9211-regulator.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: db8500-prcmu.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: dbx500-prcmu.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: dbx500-prcmu.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator/devres.c kernel/msm-4.19/drivers/regulator/devres.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator/devres.c	2024-05-28 20:53:17.935646281 -0400
+++ kernel/msm-4.19/drivers/regulator/devres.c	2024-05-29 22:10:12.901805543 -0400
@@ -29,18 +29,26 @@
 {
 	struct regulator **ptr, *regulator;
 
+    printk("%s:%d, ACHEUL, id: %s", __FUNCTION__, __LINE__, id);
+
+
 	ptr = devres_alloc(devm_regulator_release, sizeof(*ptr), GFP_KERNEL);
-	if (!ptr)
+	if (!ptr){
+        printk("%s:%d, ACHEUL no mem", __FUNCTION__, __LINE__);
 		return ERR_PTR(-ENOMEM);
+    }
 
 	regulator = _regulator_get(dev, id, get_type);
 	if (!IS_ERR(regulator)) {
 		*ptr = regulator;
 		devres_add(dev, ptr);
 	} else {
+
+        printk("%s:%d, ACHEUL error", __FUNCTION__, __LINE__);
 		devres_free(ptr);
 	}
 
+    printk("%s:%d, ACHEUL ret: %p", __FUNCTION__, __LINE__, regulator);
 	return regulator;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: dummy.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: dummy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: fan53555.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: fixed.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: fixed-helper.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: gpio-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: helpers.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: hi6421-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: hi6421v530-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: hi655x-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: internal.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: isl6271a-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: isl9305.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: lm363x-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: lp3971.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: lp3972.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: lp872x.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: lp873x-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: lp8755.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: lp87565-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: lp8788-buck.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: lp8788-ldo.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: ltc3589.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: ltc3676.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max14577-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max1586.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max77620-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max77686-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max77693-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max77802-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max8649.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max8660.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max8907-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max8925-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max8952.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max8973-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max8997-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: max8998.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: mc13783-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: mc13892-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: mc13xxx.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: mc13xxx-regulator-core.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: mt6311-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: mt6311-regulator.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: mt6323-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: mt6380-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: mt6397-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: of_regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: palmas-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pbias-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pcap-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pcf50633-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pfuze100-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: proxy-consumer.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pv88060-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pv88060-regulator.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pv88080-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pv88080-regulator.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pv88090-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pv88090-regulator.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: pwm-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: qcom_pm8008-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: qcom-rpmh-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: qcom_rpm-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: qcom_smd-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: qcom_spmi-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: qpnp-amoled-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: qpnp-labibb-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: qpnp-lcdb-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: qpnp-oledb-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: rc5t583-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: refgen.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: rk808-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: rn5t618-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: rpmh-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: rpm-smd-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: rt5033-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: s2mpa01.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: s2mps11.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: s5m8767.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: sc2731-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: sky81452-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: stm32-vrefbuf.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: stub-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: stw481x-vmmc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: sy8106a-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: ti-abb-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps51632-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps6105x-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps62360-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps65023-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps6507x-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps65086-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps65090-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps65132-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps65217-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps65218-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps6524x-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps6586x-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps65910-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps65912-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: tps80031-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: twl6030-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: twl-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: uniphier-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: userspace-consumer.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: vctrl-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: vexpress-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: virtual.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: wm831x-dcdc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: wm831x-isink.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: wm831x-ldo.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: wm8350-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: wm8400-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/regulator: wm8994-regulator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: remoteproc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: reset
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: rpmsg
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: rtc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: s390
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: sbus
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: scsi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: sensors
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: sfi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: sh
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: siox
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: slimbus
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: sn
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: actions
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: amlogic
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: atmel
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: bcm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: dove
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: fsl
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: gemini
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: imx
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: lantiq
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: mediatek
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: apr.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: boot_stats.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: cdsprm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: cmd-db.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: core_hang_detect.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: cpuss_dump.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: cx_ipeak.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: dcc_v2.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: ddr_stats.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: dfc_defs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: dfc_qmap.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: dfc_qmi.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: early_random.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: eud.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: event_timer.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: fsa4480-i2c.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: gladiator_erp.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: gladiator_hang_detect.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: glink_pkt.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: glink_probe.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: glink_ssr.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: hyp_core_ctl.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: icnss2
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: icnss.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: icnss_private.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: icnss_qmi.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: icnss_qmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: jtagv8.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: jtagv8-etm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc_events.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc-kona.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc-lagoon.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc-lito.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc_perfmon.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc_perfmon.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc-sdm845.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: llcc-slice.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: lpm-stats.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: mdt_loader.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: mem-offline.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: memory_dump_v2.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: memshare
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: microdump_collector.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: minidump_log.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: minidump_private.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_adhoc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_arb_adhoc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_arb_rpmh.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_bimc_adhoc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_bimc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_bimc_rpmh.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_client_api.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_core.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_core.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_dbg.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_dbg_rpmh.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_fabric_adhoc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_fabric_rpmh.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_noc_adhoc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_noc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_noc_rpmh.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_of_adhoc.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus/msm_bus_of.c kernel/msm-4.19/drivers/soc/qcom/msm_bus/msm_bus_of.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus/msm_bus_of.c	2024-05-28 20:55:12.816893652 -0400
+++ kernel/msm-4.19/drivers/soc/qcom/msm_bus/msm_bus_of.c	2024-05-29 22:10:12.913805649 -0400
@@ -43,6 +43,10 @@
 	int i = 0, j, ret, num_usecases = 0, num_paths, len;
 	const uint32_t *vec_arr = NULL;
 	bool mem_err = false;
+    const char *compatible = NULL;
+    const char *label = NULL;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!dev) {
 		pr_err("Error: Null device\n");
@@ -56,9 +60,16 @@
 		goto err;
 	}
 
+	of_property_read_string(of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
+	of_property_read_string(of_node, "label", &compatible);
+    printk("%s:%d, ACHEUL, label: %s", __FUNCTION__, __LINE__, label);
+
 	ret = of_property_read_string(of_node, "qcom,msm-bus,name",
 		&pdata->name);
 	if (ret) {
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, ret);
 		pr_err("Error: Client name not found\n");
 		goto err;
 	}
@@ -190,6 +201,8 @@
 	struct device_node *of_node;
 	struct msm_bus_scale_pdata *pdata = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!pdev) {
 		pr_err("Error: Null Platform device\n");
 		return NULL;
@@ -198,6 +211,7 @@
 	of_node = pdev->dev.of_node;
 	pdata = get_pdata(&pdev->dev, of_node);
 	if (!pdata) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		pr_err("client has to provide missing entry for successful registration\n");
 		return NULL;
 	}
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_of_rpmh.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_buspm_coresight_adhoc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_proxy_client.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_qnoc_adhoc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_rpmh.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_rpm_smd.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom/msm_bus: msm_bus_rules.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: msm_minidump.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: msm_performance.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: msm_tz_smmu.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: peripheral-loader.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: peripheral-loader.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qbt_handler.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qcom-geni-se.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qcom_gsbi.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qcom_ipcc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qdsp6v2
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qdss_bridge.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qdss_bridge.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qmi_encdec.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qmi_interface.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qmi_rmnet.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qmi_rmnet_i.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qmp-debugfs-client.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qpnp-pbs.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qsee_ipc_irq_bridge.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qsee_ipc_irq.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: qtee_shmbridge.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: ramdump.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: remoteqdss.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rmnet_ctl
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rmtfs_mem.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpmh.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpmh-internal.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpmh_master_stat.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpmh_master_stat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpmh-rsc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpm_master_stat.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpm-smd-debug.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rpm_stats.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: rq_stats.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: scm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: secure_buffer.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: service-locator.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: service-locator-private.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: service-notifier.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: service-notifier-private.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smcinvoke.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smcinvoke_object.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smd-rpm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smem.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smem_state.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smp2p.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smp2p_sleepstate.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: smsm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: socinfo.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: spcom.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: spm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: spss_utils.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: subsys-pil-tz.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: subsystem_notif.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: subsystem_restart.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: sysmon.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: sysmon-qmi.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: system_pm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: trace-rpmh.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: trace_secure_buffer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: watchdog_v2.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: wcnss_ctrl.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: wda_qmi.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: wlan_firmware_service_v01.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc/qcom: wlan_firmware_service_v01.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: renesas
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: rockchip
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: samsung
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: sunxi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: tegra
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: ti
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: ux500
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: versatile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: xilinx
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers/soc: zte
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: soundwire
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: spi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: spmi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: ssb
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: staging
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: target
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: tc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: tee
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: thermal
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: thunderbolt
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: tty
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: uio
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: usb
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: uwb
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: vfio
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: vhost
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: video
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: virt
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: virtio
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: visorbus
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: vlynq
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: vme
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: vservices
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: w1
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: watchdog
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: xen
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/drivers: zorro
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: firmware
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: fs
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: .get_maintainer.ignore
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: .git
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: .gitattributes
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: .gitignore
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: acpi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: asm-generic
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: clocksource
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: crypto
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: drm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: dt-bindings
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: Kbuild
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: keys
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: kvm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: 8250_pci.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: acct.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: acpi_dma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: acpi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: acpi_iort.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: acpi_pmtmr.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: adb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: adc-tm-clients.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: adfs_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: aer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: agp_backend.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: agpgart.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ahci_platform.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ahci-remap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: aio.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux/akm09911.h kernel/msm-4.19/include/linux/akm09911.h
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux/akm09911.h	1969-12-31 19:00:00.000000000 -0500
+++ kernel/msm-4.19/include/linux/akm09911.h	2024-05-29 22:10:12.933805824 -0400
@@ -0,0 +1,171 @@
+/*
+ * Definitions for akm09911 compass chip.
+ */
+#ifndef AKM09911_H
+#define AKM09911_H
+
+#include <linux/ioctl.h>
+
+/* Device specific constant values */
+#define AK09911_REG_WIA1			0x00
+#define AK09911_REG_WIA2			0x01
+#define AK09911_REG_INFO1			0x02
+#define AK09911_REG_INFO2			0x03
+#define AK09911_REG_ST1				0x10
+#define AK09911_REG_HXL				0x11
+#define AK09911_REG_HXH				0x12
+#define AK09911_REG_HYL				0x13
+#define AK09911_REG_HYH				0x14
+#define AK09911_REG_HZL				0x15
+#define AK09911_REG_HZH				0x16
+#define AK09911_REG_TMPS			0x17
+#define AK09911_REG_ST2				0x18
+#define AK09911_REG_CNTL1			0x30
+#define AK09911_REG_CNTL2			0x31
+#define AK09911_REG_CNTL3			0x32
+
+#define AK09911_FUSE_ASAX			0x60
+#define AK09911_FUSE_ASAY			0x61
+#define AK09911_FUSE_ASAZ			0x62
+
+#define AK09911_MODE_SNG_MEASURE	0x01
+#define AK09911_MODE_SELF_TEST		0x10
+#define AK09911_MODE_FUSE_ACCESS	0x1F
+#define AK09911_MODE_POWERDOWN		0x00
+#define AK09911_MODE_CONTINUOUS_10HZ	0x02 /* 10Hz */
+#define AK09911_MODE_CONTINUOUS_20HZ	0x04 /* 20Hz */
+#define AK09911_MODE_CONTINUOUS_50HZ	0x06 /* 50Hz */
+#define AK09911_MODE_CONTINUOUS_100HZ	0x08 /* 100Hz */
+#define AK09911_RESET_DATA			0x01
+
+/* ACHEUL */
+
+#define AK09911_REGS_SIZE		13
+#define AK09911_WIA1_VALUE		0x48
+#define AK09911_WIA2_VALUE		0x05
+#define AK09916_WIA2_VALUE		0x09
+#define AK09919_WIA2_VALUE		0x0E
+
+/*** Limit of factory shipment test *******************************************/
+#define TLIMIT_TN_REVISION_09911				""
+#define TLIMIT_TN_RST_WIA1_09911				"RST_WIA1"
+#define TLIMIT_LO_RST_WIA1_09911				0x48
+#define TLIMIT_HI_RST_WIA1_09911				0x48
+#define TLIMIT_TN_RST_WIA2_09911				"RST_WIA2"
+#define TLIMIT_LO_RST_WIA2_09911				0x05
+#define TLIMIT_HI_RST_WIA2_09911				0x05
+
+#define TLIMIT_TN_ASAX_09911					"ASAX"
+#define TLIMIT_LO_ASAX_09911					1
+#define TLIMIT_HI_ASAX_09911					254
+#define TLIMIT_TN_ASAY_09911					"ASAY"
+#define TLIMIT_LO_ASAY_09911					1
+#define TLIMIT_HI_ASAY_09911					254
+#define TLIMIT_TN_ASAZ_09911					"ASAZ"
+#define TLIMIT_LO_ASAZ_09911					1
+#define TLIMIT_HI_ASAZ_09911					254
+
+#define TLIMIT_TN_SNG_ST1_09911				"SNG_ST1"
+#define TLIMIT_LO_SNG_ST1_09911				1
+#define TLIMIT_HI_SNG_ST1_09911				1
+
+#define TLIMIT_TN_SNG_HX_09911				"SNG_HX"
+#define TLIMIT_LO_SNG_HX_09911				-8189
+#define TLIMIT_HI_SNG_HX_09911				8189
+
+#define TLIMIT_TN_SNG_HY_09911				"SNG_HY"
+#define TLIMIT_LO_SNG_HY_09911				-8189
+#define TLIMIT_HI_SNG_HY_09911				8189
+
+#define TLIMIT_TN_SNG_HZ_09911				"SNG_HZ"
+#define TLIMIT_LO_SNG_HZ_09911				-8189
+#define TLIMIT_HI_SNG_HZ_09911				8189
+
+#define TLIMIT_TN_SNG_ST2_09911				"SNG_ST2"
+#define TLIMIT_LO_SNG_ST2_09911				0
+#define TLIMIT_HI_SNG_ST2_09911				0
+
+#define TLIMIT_TN_SLF_ST1_09911				"SLF_ST1"
+#define TLIMIT_LO_SLF_ST1_09911				1
+#define TLIMIT_HI_SLF_ST1_09911				1
+
+#define TLIMIT_TN_SLF_RVHX_09911				"SLF_REVSHX"
+#define TLIMIT_LO_SLF_RVHX_09911				-30
+#define TLIMIT_HI_SLF_RVHX_09911				30
+
+#define TLIMIT_TN_SLF_RVHY_09911				"SLF_REVSHY"
+#define TLIMIT_LO_SLF_RVHY_09911				-30
+#define TLIMIT_HI_SLF_RVHY_09911				30
+
+#define TLIMIT_TN_SLF_RVHZ_09911				"SLF_REVSHZ"
+#define TLIMIT_LO_SLF_RVHZ_09911				-400
+#define TLIMIT_HI_SLF_RVHZ_09911				-50
+
+#define TLIMIT_TN_SLF_ST2_09911				"SLF_ST2"
+#define TLIMIT_LO_SLF_ST2_09911				0
+#define TLIMIT_HI_SLF_ST2_09911				0
+
+/* To avoid device dependency, convert to general name */
+#define AKM_I2C_NAME			"akm09911"
+#define AKM_MISCDEV_NAME		"akm09911_dev"
+#define AKM_SYSCLS_NAME			"compass"
+#define AKM_SYSDEV_NAME			"akm09911"
+#define AKM_REG_MODE			AK09911_REG_CNTL2
+#define AKM_REG_RESET			AK09911_REG_CNTL3
+#define AKM_REG_STATUS			AK09911_REG_ST1
+#define AKM_MEASURE_TIME_US		10000
+#define AKM_DRDY_IS_HIGH(x)		((x) & 0x01)
+#define AKM_DOR_IS_HIGH(x)		((x) & 0x02)
+#define AKM_SENSOR_INFO_SIZE	2
+#define AKM_SENSOR_CONF_SIZE	3
+#define AKM_SENSOR_DATA_SIZE	9
+
+#define AKM_YPR_DATA_SIZE		16
+#define AKM_RWBUF_SIZE			16
+#define AKM_REGS_SIZE			AK09911_REGS_SIZE
+#define AKM_REGS_1ST_ADDR		AK09911_REG_WIA1
+#define AKM_FUSE_1ST_ADDR		AK09911_FUSE_ASAX
+
+#define AKM_MODE_SNG_MEASURE	AK09911_MODE_SNG_MEASURE
+#define AKM_MODE_SELF_TEST		AK09911_MODE_SELF_TEST
+#define AKM_MODE_FUSE_ACCESS	AK09911_MODE_FUSE_ACCESS
+#define AKM_MODE_POWERDOWN		AK09911_MODE_POWERDOWN
+#define AKM_MODE_CONTINUOUS_10HZ	AK09911_MODE_CONTINUOUS_10HZ
+#define AKM_MODE_CONTINUOUS_20HZ	AK09911_MODE_CONTINUOUS_20HZ
+#define AKM_MODE_CONTINUOUS_50HZ	AK09911_MODE_CONTINUOUS_50HZ
+#define AKM_MODE_CONTINUOUS_100HZ	AK09911_MODE_CONTINUOUS_100HZ
+#define AKM_RESET_DATA			AK09911_RESET_DATA
+
+#define ACC_DATA_FLAG		0
+#define MAG_DATA_FLAG		1
+#define FUSION_DATA_FLAG	2
+#define AKM_NUM_SENSORS		3
+
+#define ACC_DATA_READY		(1<<(ACC_DATA_FLAG))
+#define MAG_DATA_READY		(1<<(MAG_DATA_FLAG))
+#define FUSION_DATA_READY	(1<<(FUSION_DATA_FLAG))
+
+#define AKMIO				0xA1
+
+/* IOCTLs for AKM library */
+#define ECS_IOCTL_READ				_IOWR(AKMIO, 0x01, char)
+#define ECS_IOCTL_WRITE				_IOW(AKMIO, 0x02, char)
+#define ECS_IOCTL_RESET				_IO(AKMIO, 0x03)
+#define ECS_IOCTL_SET_MODE			_IOW(AKMIO, 0x10, char)
+#define ECS_IOCTL_SET_YPR			_IOW(AKMIO, 0x11, int[AKM_YPR_DATA_SIZE])
+#define ECS_IOCTL_GET_INFO			_IOR(AKMIO, 0x20, unsigned char[AKM_SENSOR_INFO_SIZE])
+#define ECS_IOCTL_GET_CONF			_IOR(AKMIO, 0x21, unsigned char[AKM_SENSOR_CONF_SIZE])
+#define ECS_IOCTL_GET_DATA			_IOR(AKMIO, 0x22, unsigned char[AKM_SENSOR_DATA_SIZE])
+#define ECS_IOCTL_GET_OPEN_STATUS	_IOR(AKMIO, 0x23, int)
+#define ECS_IOCTL_GET_CLOSE_STATUS	_IOR(AKMIO, 0x24, int)
+#define ECS_IOCTL_GET_DELAY			_IOR(AKMIO, 0x25, long long int)
+#define ECS_IOCTL_GET_LAYOUT		_IOR(AKMIO, 0x26, char)
+#define ECS_IOCTL_GET_ACCEL			_IOR(AKMIO, 0x30, short[3])
+
+struct akm09911_platform_data {
+	char layout;
+	int gpio_DRDY;
+	int gpio_RSTN;
+};
+
+#endif
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: alarmtimer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: altera_jtaguart.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: altera_uart.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: amba
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: amd-iommu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: amifd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: amifdreg.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: android_aid.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: anon_inodes.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: a.out.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: apm_bios.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: apm-emulation.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: apple_bl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: apple-gmux.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: arch_topology.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: arm-cci.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: arm_sdei.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: arm-smccc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ascii85.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: asn1_ber_bytecode.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: asn1_decoder.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: asn1.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: assoc_array.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: assoc_array_priv.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: async.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: async_tx.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ata.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: atalk.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ata_platform.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ath9k_platform.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: atmdev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: atmel-mci.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: atmel_pdc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: atmel-ssc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: atmel_tc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: atm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: atm_suni.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: atm_tcp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: atomic.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: attribute_container.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: audit.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: auto_dev-ioctl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: auto_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: auxvec.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: average.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: avf
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: b1pcmcia.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: backing-dev-defs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: backing-dev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: backlight.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: badblocks.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: balloon_compaction.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: batterydata-lib.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bcd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bch.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bcm47xx_nvram.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bcm47xx_sprom.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bcm47xx_wdt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bcm963xx_nvram.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bcm963xx_tag.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bcma
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: binfmts.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bitfield.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bitmap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bitops.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bitrev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bits.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bit_spinlock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: blk-cgroup.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: blkdev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: blk-mq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: blk-mq-pci.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: blk-mq-rdma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: blk-mq-virtio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: blkpg.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: blktrace_api.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: blk_types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: blockgroup_lock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bluetooth-power.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bma150.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bootmem.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bottom_half.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bpf-cgroup.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bpf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bpfilter.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bpf_lirc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bpf_trace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bpf_types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bpf_verifier.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: brcmphy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bsearch.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bsg.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bsg-lib.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: btf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: btree-128.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: btree.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: btree-type.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: btrfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: buffer_head.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bug.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: build_bug.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: build-salt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: bvec.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: byteorder
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: c2port.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cache.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cacheinfo.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: can
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: capability.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cb710.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cciss_ioctl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ccp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cdev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cdrom.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ceph
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cfag12864b.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cfi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cgroup-defs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cgroup.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cgroup_rdma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cgroup_subsys.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: circ_buf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cleancache.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: clk
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: clkdev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: clk.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: clk-provider.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: clockchips.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: clock_cooling.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: clocksource.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cm4000_cs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cmdline-parser.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cn_proc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cnt32_to_63.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: coda.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: coda_psdev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: compaction.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: compat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: compat_time.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: compiler-clang.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: compiler-gcc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: compiler.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: compiler-intel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: compiler_types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: completion.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: component.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: concap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: configfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: connector.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: console.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: consolemap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: console_struct.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: const.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: container.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: context_tracking.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: context_tracking_state.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cordic.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: coredump.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: coresight-cti.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: coresight.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: coresight-pmu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: coresight-stm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: count_zeros.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cper.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpu_cooling.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpufeature.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpufreq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpufreq_times.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpuhotplug.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpuidle.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpumask.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpu_pm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpu_rmap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cpuset.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crash_core.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crash_dump.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc16.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc32c.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc32.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc32poly.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc4.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc64.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc7.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc8.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc-ccitt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc-itu-t.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crc-t10dif.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cred.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crush
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: crypto.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cryptohash.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cs5535.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ctype.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cuda.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: cyclades.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: davinci_emac.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dax.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dcache.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dca.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dccp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dcookies.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: debugfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: debug_locks.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: debugobjects.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: decompress
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: delayacct.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: delayed_call.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: delay.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dell-led.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: devcoredump.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: devfreq_cooling.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: devfreq-event.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: devfreq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: device_cgroup.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: device.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: device-mapper.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: devpts_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: diagchar.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: digsig.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dirent.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dlm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dlm_plock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dm9000.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-buf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-buf-ref.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-contiguous.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-debug.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-direct.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-direction.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dmaengine.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-fence-array.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-fence.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-iommu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-mapping-fast.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-mapping.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-noncoherent.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dmapool.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma_remapping.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dma-removed.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dmar.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dm-bufio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dm-dirty-log.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dm-io.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dm-kcopyd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dm-region-hash.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dnotify.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dns_resolver.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dqblk_qtree.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dqblk_v1.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dqblk_v2.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: drbd_genl_api.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: drbd_genl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: drbd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: drbd_limits.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ds2782_battery.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dsa
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dtlk.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dw_apb_timer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dynamic_debug.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: dynamic_queue_limits.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: earlycpio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ecm_ipa.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ecryptfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: edac.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: edd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: edma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: eeprom_93cx6.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: eeprom_93xx46.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: efi-bgrt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: efi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: efs_vh.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: eisa.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: elevator.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: elfcore-compat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: elfcore.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: elf-fdpic.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: elf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: elfnote.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: elf-randomize.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: enclosure.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: energy_model.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: err.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: errno.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: error-injection.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: errqueue.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: errseq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: esoc_client.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: etherdevice.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ethtool.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: eventfd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: eventpoll.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: evm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: exportfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: export.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ext2_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: extable.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: extcon
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: extcon.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: extcon-provider.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: f2fs_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: f75375s.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: falloc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fanotify.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fastcvpd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fault-inject.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fbcon.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fcdevice.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fcntl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fddidevice.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fdtable.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fec.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: file.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: filter.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fips.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: firewire.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: firmware
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: firmware.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: firmware-map.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fixp-arith.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: flat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: flex_array.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: flex_proportions.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fmc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fmc-sdb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: font.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fpga
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: frame.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: freezer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: frontswap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fscache-cache.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fscache.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fscrypt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fs_enet_pd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fsi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fsi-sbefifo.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fsl
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fsl_devices.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fsl-diu-fb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fsldma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fsl_hypervisor.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fsl_ifc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fsnotify_backend.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fsnotify.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fs_pin.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fs_stack.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fs_struct.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fs_uart_pd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ftrace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ftrace_irq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: futex.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: fwnode.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: gameport.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: gcd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: genalloc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: genetlink.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: genhd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: genl_magic_func.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: genl_magic_struct.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: getcpu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: gfp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: glob.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: gnss.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: goldfish.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: gpio
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: gpio_event.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: gpio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: gpio_keys.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: gpio-pxa.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hardirq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hash.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hashtable.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hdcp_qseecom.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hdlcdrv.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hdlc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hdmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hid-debug.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hiddev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hid.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hidraw.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hid-roccat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hid-sensor-hub.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hid-sensor-ids.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: highmem.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: highuid.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hil.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hil_mlc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hippidevice.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hmm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: host1x.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hpet.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hp_sdc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hrtimer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hsi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: htcpld.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: huge_mm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hugetlb_cgroup.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hugetlb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hugetlb_inline.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hw_breakpoint.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hwmon.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hwmon-sysfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hwmon-vid.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hw_random.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hwspinlock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hyperv.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: hypervisor.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i2c-algo-bit.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i2c-algo-pca.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i2c-algo-pcf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i2c-dev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i2c.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i2c-mux.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i2c-pxa.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i2c-smbus.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i3c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i8042.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: i8253.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: icmp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: icmpv6.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ide.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: idle_inject.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: idr.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ieee80211.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ieee802154.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_arp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_bridge.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_eql.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_ether.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_fddi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_frad.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_link.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_ltalk.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_macvlan.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_phonet.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_pppol2tp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_pppox.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_tap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_team.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_tun.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_tunnel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: if_vlan.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: igmp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ihex.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: iio
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ima.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: imx-media.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: in6.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: inetdevice.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: inet_diag.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: inet.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: in.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: init.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: init_ohci1394_dma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: initramfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: initrd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: init_task.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: inotify.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: input
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: input.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: input-polldev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: integrity.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: intel-iommu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: intel-pti.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: intel-svm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: interrupt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: interval_tree_generic.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: interval_tree.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: io-64-nonatomic-hi-lo.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: io-64-nonatomic-lo-hi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ioc3.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ioc4.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: iocontext.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: io.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: iomap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: io-mapping.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: iommu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: iommu-helper.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ion_kernel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: io-pgtable-fast.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: iopoll.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ioport.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ioprio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: iova.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipack.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipa.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipa_mhi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipa_odu_bridge.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipa_uc_offload.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipa_usb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipa_wdi3.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipa_wigig.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipc_logging.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipc_namespace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ip.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipmi-fru.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipmi_smi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipv6.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ipv6_route.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irqbypass.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irqchip
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irqchip.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irq_cpustat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irqdesc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irqdomain.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irqflags.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irqhandler.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irqnr.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irq_poll.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irqreturn.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irq_sim.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: irq_work.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: isa.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: isapnp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: iscsi_boot_sysfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: iscsi_ibft.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: isdn
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: isdn_divertif.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: isdn.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: isdnif.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: isdn_ppp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: isicom.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: iversion.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: jbd2.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: jhash.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: jiffies.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: journal-head.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: joystick.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: jump_label.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: jump_label_ratelimit.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: jz4740-adc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: jz4780-nemc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kallsyms.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kasan-checks.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kasan.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kbd_diacr.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kbd_kern.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kbuild.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: Kbuild.vservices
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kconfig.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kcore.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kcov.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kdb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kdebug.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kdev_t.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kernelcapi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kernel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kernel-page-flags.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kernel_stat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kernfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kern_levels.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kexec.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: keyboard.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: keycombo.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: key.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: keyreset.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: key-type.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kfifo.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kgdb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: khugepaged.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: klist.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kmemleak.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kmod.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kmsg_dump.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kobject.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kobject_ns.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kobj_map.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kprobes.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kref.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ks0108.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ks8842.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ks8851_mll.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ksm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kthread.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ktime.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kvm_host.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kvm_irqfd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kvm_para.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: kvm_types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: l2tp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lapb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: latencytop.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lcd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lcm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: led-class-flash.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: led-lm3530.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: leds-bd2802.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: leds.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: leds-lp3944.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: leds-lp3952.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: leds-pca9532.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: leds_pwm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: leds-qpnp-flash.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: leds-qpnp-flash-v2.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: leds-regulator.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: leds-tca6507.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: libata.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: libfdt_env.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: libfdt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: libgcc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: libnvdimm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: libps2.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: license.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lightnvm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: linkage.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: linux_logo.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lis3lv02d.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: list_bl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: list.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: list_lru.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: list_nulls.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: list_sort.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: livepatch.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: llc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: llist.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lockd
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lockdep.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lockref.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: log2.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: logic_pio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lru_cache.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lsm_audit.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lsm_hooks.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lz4.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: lzo.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mailbox
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mailbox_client.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mailbox_controller.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: maple.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: marvell_phy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: math64.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: max17040_battery.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mbcache.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mbus.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mc146818rtc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mc6821.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mcb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mdev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mdio-bitbang.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mdio-gpio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mdio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mdio-mux.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mei_cl_bus.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: memblock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: memcontrol.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mem_encrypt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: memfd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: memory.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: memory_hotplug.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: memory-state-time.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mempolicy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mempool.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: memremap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: memstick.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mfd
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mhi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mic_bus.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: micrel_phy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: microchipphy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: migrate.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: migrate_mode.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mii.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: miscdevice.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mISDNdsp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mISDNhw.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mISDNif.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mlx4
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mlx5
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mman.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mm-arch-hooks.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mmc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mmdebug.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mm_inline.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mmiotrace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mm_types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mm_types_task.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mmu_context.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mmu_notifier.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mmzone.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mnt_namespace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mod_devicetable.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: module.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: moduleloader.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: moduleparam.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mount.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mpage.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mpi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mpls.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mpls_iptunnel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mroute6.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mroute_base.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mroute.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msdos_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msg.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_adreno_devfreq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm-bus-board.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm-bus.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_bus_rules.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_dma_iommu_mapping.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_ext_display.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_gpi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_gsi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_hdcp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_hdmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_kgsl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_pcie.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm_rtb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: msm-sps.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mtd
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mutex.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mux
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mv643xx_eth.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mv643xx.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mv643xx_i2c.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mvebu-pmsu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: mxm-wmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: namei.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netdev_features.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netdevice.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: net_dim.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter_arp
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter_bridge
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter_bridge.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter_defs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter_ingress.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter_ipv4
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter_ipv4.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter_ipv6
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netfilter_ipv6.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: net.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netlink.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: netpoll.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfcinfo.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfs3.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfs4.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfsacl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfs_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfs_fs_i.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfs_fs_sb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfs_iostat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfs_page.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nfs_xdr.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nl802154.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nls.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: node.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nodemask.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nospec.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: notifier.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: n_r3964.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nsc_gpio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ns_common.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nsproxy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ntb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ntb_transport.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nubus.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: numa.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nvme-fc-driver.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nvme-fc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nvme.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nvmem-consumer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nvmem-provider.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nvme-rdma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: nvram.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_address.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_batterydata.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_clk.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_device.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_dma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_fdt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_gpio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_graph.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_iommu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_irq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_mdio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_net.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_pci.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_pdt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_platform.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_reserved_mem.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: of_slimbus.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: oid_registry.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: olpc-ec.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: omap-dmaengine.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: omap-dma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: omapfb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: omap-gpmc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: omap-iommu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: omap-mailbox.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: once.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: oom.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: openvswitch.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: oprofile.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: osq_lock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: overflow.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: oxu210hp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: padata.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pageblock-flags.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: page_counter.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: page_ext.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: page-flags.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: page-flags-layout.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: page_idle.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: page-isolation.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pagemap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: page_owner.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: page_ref.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pagevec.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: parman.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: parport.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: parport_pc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: parser.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pata_arasan_cf_data.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: patchkey.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: path.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pch_dma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci-acpi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci-aspm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci-ats.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci-dma-compat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci-dma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci-ecam.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci-ep-cfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci-epc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci-epf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci_hotplug.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pci_ids.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pda_power.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pe.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: percpu_counter.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: percpu-defs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: percpu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: percpu-refcount.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: percpu-rwsem.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: perf
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: perf_event.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: perf_regs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: personality.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pfk.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pfn.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pfn_t.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: phonet.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: phy
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: phy_fixed.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: phy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: phy_led_triggers.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: phylink.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pid.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pid_namespace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pim.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pinctrl
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pipe_fs_i.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pkeys.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pktcdvd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pl320-ipc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: platform_data
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: platform_device.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: plist.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pm2301_charger.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pmbus.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pm_clock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pm_domain.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pmic-voter.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pm_opp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pm_qos.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pm_runtime.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pm-trace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pmu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pm_wakeirq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pm_wakeup.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pnfs_osd_xdr.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pnp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: poison.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: poll.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: posix_acl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: posix_acl_xattr.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: posix-clock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: posix-timers.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: power
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: powercap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: power_supply.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ppp_channel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ppp-comp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ppp_defs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pps-gpio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pps_kernel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: preempt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: prefetch.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pr.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: prime_numbers.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: printk.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: processor.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: proc_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: proc_ns.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: profile.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: projid.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: property.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: psci.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: psi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: psi_types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: psp-sev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pstore.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pstore_ram.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pti.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ptp_classify.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ptp_clock_kernel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ptrace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ptr_ring.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: purgatory.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pvclock_gtod.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pwm_backlight.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pwm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pxa168_eth.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: pxa2xx_ssp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: qcom-geni-se.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: qcom_scm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: qcom_tspp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: qcrypto.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: qed
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: qnx6_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: qpnp
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: quicklist.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: quota.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: quotaops.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: radix-tree.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: raid
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: raid_class.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ramfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: random.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: range.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ras.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ratelimit.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rational.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rbtree_augmented.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rbtree.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rbtree_latch.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rculist_bl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rculist.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rculist_nulls.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rcu_node_tree.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rcupdate.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rcupdate_wait.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rcu_segcblist.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rcu_sync.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rcutiny.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rcutree.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rcuwait.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: reboot.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: reboot-mode.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: reciprocal_div.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: refcount.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: regmap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: regset.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: regulator
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: relay.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: remoteproc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: remoteproc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: reservation.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: reset
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: reset-controller.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: reset.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: resource_ext.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: resource.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: restart_block.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rfkill.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rhashtable.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rhashtable-types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ring_buffer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rio_drv.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rio_ids.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rio_regs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rmap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rndis.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rndis_ipa.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rodata_test.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: root_dev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rpmsg
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rpmsg.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rq_stats.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rslib.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rtc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rtc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rtmutex.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rtnetlink.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rtsx_common.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rtsx_pci.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rtsx_usb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rwlock_api_smp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rwlock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rwlock_types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rwsem.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: rwsem-spinlock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: s3c_adc_battery.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sa11x0-dma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sbitmap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: scatterlist.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: scc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sched
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sched_clock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sched.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: scif.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: scmi_protocol.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: scpi_protocol.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: screen_info.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sctp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: scx200_gpio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: scx200.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sdb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sde_io_util.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sde_rsc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sdla.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seccomp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: securebits.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: security.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sed-opal.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seg6_genl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seg6.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seg6_hmac.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seg6_iptunnel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seg6_local.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: selection.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: selinux.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: semaphore.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sem.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seq_buf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seq_file.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seq_file_net.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seqlock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: seqno-fence.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: serdev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: serial_8250.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: serial_bcm63xx.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: serial_core.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: serial.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: serial_max3100.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: serial_pnx8xxx.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: serial_s3c.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: serial_sci.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: serio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: set_memory.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sfi_acpi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sfi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sfp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sha256.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sh_clk.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: shdma-base.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sh_dma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sh_eth.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sh_intc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: shmem_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: shm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: show_mem_notifier.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: shrinker.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sh_timer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: signalfd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: signal.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: signal_types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: siox.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: siphash.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sirfsoc_dma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sizes.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: skb_array.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: skbuff.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: slab_def.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: slab.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: slimbus
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: slub_def.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sm501.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sm501-regs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: smc911x.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: smc91x.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: smpboot.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: smp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: smsc911x.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: smscphy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: soc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sock_diag.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: socket.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sonet.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sony-laptop.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sonypi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sort.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: soundcard.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sound.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: soundwire
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: spi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: spinlock_api_smp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: spinlock_api_up.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: spinlock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: spinlock_types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: spinlock_types_up.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: spinlock_up.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: splice.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: spmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sram.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: srcu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: srcutiny.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: srcutree.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ssb
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ssbi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stackdepot.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stackprotector.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stacktrace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: start_kernel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: statfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: static_key.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stddef.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stmmac.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stmp3xxx_rtc_wdt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stmp_device.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stop_machine.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: string.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stringhash.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: string_helpers.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: stringify.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sudmac.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sungem_phy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sunrpc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sunserialcore.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sunxi-rsb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: superhyway.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: suspend.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: svga.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sw842.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: swab.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: swait.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: swap_cgroup.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: swapfile.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: swap.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: swapops.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: swap_slots.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: swiotlb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: switchtec.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sxgbe_platform.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sync_core.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sync_file.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: synclink.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: syscalls.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: syscore_ops.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sysctl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sysfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sys.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: syslog.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sysrq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sys_soc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: sysv_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: t10-pi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: task_io_accounting.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: task_io_accounting_ops.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: taskstats_kern.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: task_work.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tboot.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tca6416_keypad.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tcp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tee_drv.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: textsearch_fsm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: textsearch.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tfrc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: thermal.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: thinkpad_acpi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: thread_info.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: threads.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: thunderbolt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tick.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ti-emif-sram.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tifm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timb_dma.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timb_gpio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: time32.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: time64.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timecounter.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: time.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timekeeper_internal.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timekeeping32.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timekeeping.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timerfd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timeriomem-rng.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timerqueue.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: timex.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ti_wilink_st.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tnum.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: topology.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: torture.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: toshiba.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tpm_command.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tpm_eventlog.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tpm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: trace_clock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: trace_events.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tracefs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: trace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tracehook.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tracepoint-defs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tracepoint.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: trace_seq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: transport_class.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tsacct_kern.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ts-nbus.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tty_driver.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tty_flip.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tty.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: tty_ldisc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: typecheck.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: types.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: u64_stats_sync.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: uaccess.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ucb1400.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ucs2_string.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: udp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: uidgid.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: uio_driver.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: uio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ulpi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: umh.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: unaligned
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: uprobes.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: usb
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: usb_bam.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: usbdevice_fs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: usb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: usb_usual.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: userfaultfd_k.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: user.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: user_namespace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: user-return-notifier.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: util_macros.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: uts.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: utsname.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: uuid.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: uwb
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: uwb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vbox_utils.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: verification.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vermagic.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vexpress.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vfio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vfs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vgaarb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vga_switcheroo.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: via-core.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: via-gpio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: via.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: via_i2c.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: videodev2.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: virtio_byteorder.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: virtio_caif.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: virtio_config.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: virtio_console.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: virtio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: virtio_net.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: virtio_ring.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: virtio_vsock.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: visorbus.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vlynq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vmacache.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vmalloc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vme.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vm_event_item.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vmpressure.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vm_sockets.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vmstat.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vmw_vmci_api.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vmw_vmci_defs.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vringh.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vt_buffer.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vt.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vtime.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: vt_kern.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: w1-gpio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: w1.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: wait_bit.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: wait.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: wakeup_reason.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: wanrouter.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: watchdog.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: wimax
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: win_minmax.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: wireless.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: wkup_m3_ipc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: wl12xx.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: wm97xx.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: wmi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: workqueue.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: writeback.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: ww_mutex.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: xarray.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: xattr.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: xxhash.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: xz.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: yam.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: z2_battery.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: zbud.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: zconf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: zlib.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: zorro.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: zpool.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: zsmalloc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: zstd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include/linux: zutil.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: math-emu
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: media
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: memory
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: microvisor
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: misc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: net
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: pcmcia
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: ras
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: rdma
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: scsi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: soc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: sound
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: target
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: trace
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: uapi
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: video
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: vservices
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/include: xen
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: init
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: ipc
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: Kbuild
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: Kconfig
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: kernel
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: lib
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: LICENSES
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: .mailmap
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: MAINTAINERS
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: mm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: net
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: README
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: samples
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: scripts
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: security
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: sound
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera: config
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_cdm
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_core
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_cpas
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_cust
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_fd
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_icp
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_isp
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_jpeg
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_lrme
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_req_mgr
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module: cam_actuator
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_core.c kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_core.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_core.c	2024-05-28 21:11:35.799594455 -0400
+++ kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_core.c	2024-05-29 22:10:12.793804596 -0400
@@ -7,6 +7,7 @@
 #include "cam_cci_core.h"
 #include "cam_cci_dev.h"
 
+#define DUMP_CCI_REGISTERS 1
 static int32_t cam_cci_convert_type_to_num_bytes(
 	enum camera_sensor_i2c_type type)
 {
@@ -192,8 +193,10 @@
 	uint32_t reg_offset = 0;
 	void __iomem *base = cci_dev->soc_info.reg_map[0].mem_base;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	CAM_INFO(CAM_CCI, "**** CCI:%d register dump ****",
-		cci_dev->soc_info->index);
+		cci_dev->soc_info.index);
 
 	/* CCI Top Registers */
 	CAM_INFO(CAM_CCI, "****CCI TOP Registers ****");
@@ -236,6 +239,7 @@
 		CAM_INFO(CAM_CCI, "offset = 0x%X value = 0x%X",
 			reg_offset, read_val);
 	}
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 }
 #endif
 
@@ -1170,6 +1174,8 @@
 	struct cam_hw_soc_info *soc_info = NULL;
 	void __iomem *base = NULL;
 
+    printk("%s:%d, ACHEUL, in", __FUNCTION__, __LINE__);
+
 	cci_dev = v4l2_get_subdevdata(sd);
 	master = c_ctrl->cci_info->cci_i2c_master;
 	read_cfg = &c_ctrl->cfg.cci_i2c_read_cfg;
@@ -1181,6 +1187,8 @@
 		return -EINVAL;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	/* Set the I2C Frequency */
 	rc = cam_cci_set_clk_param(cci_dev, c_ctrl);
 	if (rc < 0) {
@@ -1199,6 +1207,7 @@
 	 * If this call fails, don't proceed with i2c_read call. This is to
 	 * avoid overflow / underflow of queue
 	 */
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	rc = cam_cci_validate_queue(cci_dev,
 		cci_dev->cci_i2c_queue_info[master][queue].max_queue_size - 1,
 		master, queue);
@@ -1217,6 +1226,7 @@
 		goto rel_mutex_q;
 	}
 
+    printk("%s:%d, ACHEUL master: %d, queue: %d", __FUNCTION__, __LINE__, master, queue);
 	CAM_DBG(CAM_CCI, "master %d, queue %d", master, queue);
 	CAM_DBG(CAM_CCI, "set param sid 0x%x retries %d id_map %d",
 		c_ctrl->cci_info->sid, c_ctrl->cci_info->retries,
@@ -1230,13 +1240,16 @@
 		goto rel_mutex_q;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	val = CCI_I2C_LOCK_CMD;
 	rc = cam_cci_write_i2c_queue(cci_dev, val, master, queue);
 	if (rc < 0) {
+        printk("%s:%d, ACHEUL, FAILED", __FUNCTION__, __LINE__);
 		CAM_DBG(CAM_CCI, "failed rc: %d", rc);
 		goto rel_mutex_q;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (read_cfg->addr_type >= CAMERA_SENSOR_I2C_TYPE_MAX) {
 		CAM_ERR(CAM_CCI, "failed : Invalid addr type: %u",
 			read_cfg->addr_type);
@@ -1252,6 +1265,7 @@
 
 	rc = cam_cci_write_i2c_queue(cci_dev, val, master, queue);
 	if (rc < 0) {
+        printk("%s:%d, ACHEUL, FAILED", __FUNCTION__, __LINE__);
 		CAM_DBG(CAM_CCI, "failed rc: %d", rc);
 		goto rel_mutex_q;
 	}
@@ -1259,6 +1273,7 @@
 	val = CCI_I2C_READ_CMD | (read_cfg->num_byte << 4);
 	rc = cam_cci_write_i2c_queue(cci_dev, val, master, queue);
 	if (rc < 0) {
+        printk("%s:%d, ACHEUL, FAILED", __FUNCTION__, __LINE__);
 		CAM_DBG(CAM_CCI, "failed rc: %d", rc);
 		goto rel_mutex_q;
 	}
@@ -1266,6 +1281,7 @@
 	val = CCI_I2C_UNLOCK_CMD;
 	rc = cam_cci_write_i2c_queue(cci_dev, val, master, queue);
 	if (rc < 0) {
+        printk("%s:%d, ACHEUL FAILED", __FUNCTION__, __LINE__);
 		CAM_DBG(CAM_CCI, "failed rc: %d", rc);
 		goto rel_mutex_q;
 	}
@@ -1282,28 +1298,35 @@
 		"waiting_for_rd_done [exp_words: %d]",
 		((read_cfg->num_byte / 4) + 1));
 
-	rc = wait_for_completion_timeout(
-		&cci_dev->cci_master_info[master].rd_done, CCI_TIMEOUT);
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	rc = wait_for_completion_timeout(&cci_dev->cci_master_info[master].rd_done, CCI_TIMEOUT);
 	if (rc <= 0) {
+        printk("%s:%d, ACHEUL completion timeout", __FUNCTION__, __LINE__);
 #ifdef DUMP_CCI_REGISTERS
 		cam_cci_dump_registers(cci_dev, master, queue);
 #endif
-		if (rc == 0)
+		if (rc == 0) {
+            printk("%s:%d, ACHEUL timeout", __FUNCTION__, __LINE__);
 			rc = -ETIMEDOUT;
+        }
+
 		val = cam_io_r_mb(base +
 			CCI_I2C_M0_READ_BUF_LEVEL_ADDR + master * 0x100);
 		CAM_ERR(CAM_CCI,
 			"wait_for_completion_timeout rc = %d FIFO buf_lvl: 0x%x",
 			rc, val);
 		cam_cci_flush_queue(cci_dev, master);
+        printk("%s:%d, ACHEUL FAILED", __FUNCTION__, __LINE__);
 		goto rel_mutex_q;
 	} else {
+        printk("%s:%d, ACHEUL succeed", __FUNCTION__, __LINE__);
 		rc = 0;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (cci_dev->cci_master_info[master].status) {
-		CAM_ERR(CAM_CCI, "ERROR with Slave 0x%x:",
-			(c_ctrl->cci_info->sid << 1));
+        printk("%s:%d, ACHEUL error, status: 0x%04X", __FUNCTION__, __LINE__, cci_dev->cci_master_info[master].status);
+		CAM_ERR(CAM_CCI, "ERROR with Slave 0x%x:", (c_ctrl->cci_info->sid << 1));
 		rc = -EINVAL;
 		cci_dev->cci_master_info[master].status = 0;
 		goto rel_mutex_q;
@@ -1320,6 +1343,7 @@
 		goto rel_mutex_q;
 	}
 	index = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	CAM_DBG(CAM_CCI, "index %d num_type %d", index, read_cfg->num_byte);
 	first_byte = 0;
 	while (read_words > 0) {
@@ -1341,6 +1365,7 @@
 		}
 		read_words--;
 	}
+
 rel_mutex_q:
 	mutex_unlock(&cci_dev->cci_master_info[master].mutex_q[queue]);
 
@@ -1348,6 +1373,8 @@
 	if (--cci_dev->cci_master_info[master].freq_ref_cnt == 0)
 		up(&cci_dev->cci_master_info[master].master_sem);
 	spin_unlock(&cci_dev->cci_master_info[master].freq_cnt_lock);
+
+    printk("%s:%d, ACHEUL, out: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -1499,6 +1526,8 @@
 	struct cam_cci_read_cfg *read_cfg = NULL;
 	uint16_t read_bytes = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!sd || !c_ctrl) {
 		CAM_ERR(CAM_CCI, "sd %pK c_ctrl %pK", sd, c_ctrl);
 		return -EINVAL;
@@ -1544,6 +1573,7 @@
 	mutex_unlock(&cci_dev->cci_master_info[master].mutex_q[QUEUE_1]);
 
 	CAM_DBG(CAM_CCI, "Bytes to read %u", read_bytes);
+    printk("%s:%d, ACHEUL bytes to read: %u", __FUNCTION__, __LINE__, read_bytes);
 	do {
 		if (read_bytes >= CCI_I2C_MAX_BYTE_COUNT)
 			read_cfg->num_byte = CCI_I2C_MAX_BYTE_COUNT;
@@ -1574,6 +1604,7 @@
 
 ERROR:
 	cci_dev->is_burst_read = false;
+    printk("%s:%d, ACHEUL out: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci: cam_cci_core.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci: cam_cci_dev.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci: cam_cci_dev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci: cam_cci_hwreg.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci: cam_cci_soc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci: cam_cci_soc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_cci: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module: cam_csiphy
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module: cam_eeprom
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module: cam_flash
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module: cam_hdmi_bdg
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module: cam_ois
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_res_mgr: cam_res_mgr_api.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_res_mgr/cam_res_mgr.c kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_res_mgr/cam_res_mgr.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_res_mgr/cam_res_mgr.c	2024-05-28 21:11:35.803594498 -0400
+++ kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_res_mgr/cam_res_mgr.c	2024-05-29 22:10:12.817804807 -0400
@@ -549,6 +549,8 @@
 	bool found = false;
 	struct cam_gpio_res *gpio_res = NULL;
 
+    printk("%s:%dm ACHEUL settings GPIO: %d, value: %d", __FUNCTION__, __LINE__, gpio, value);
+
 	if (cam_res && cam_res->shared_gpio_enabled) {
 		mutex_lock(&cam_res->gpio_res_lock);
 		list_for_each_entry(gpio_res, &cam_res->gpio_res_list, list) {
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_res_mgr: cam_res_mgr_private.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_res_mgr: Makefile
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c	2024-05-28 21:11:35.803594498 -0400
+++ kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c	2024-05-29 22:10:12.805804701 -0400
@@ -708,6 +708,11 @@
 		&s_ctrl->sensordata->power_info;
 	int rc = 0;
 
+    printk("==============================================");
+    printk("%s:%d, ACHEUL FIXME! DISABLED", __FUNCTION__, __LINE__);
+    printk("==============================================");
+    return;
+
 	if ((s_ctrl->sensor_state == CAM_SENSOR_INIT) &&
 		(s_ctrl->is_probe_succeed == 0))
 		return;
@@ -747,9 +752,20 @@
 	uint32_t chipid = 0;
 	struct cam_camera_slave_info *slave_info;
 
+    printk("========================================");
+    printk("%s:%d, ACHEUL, in sensor id: 0x%04X, slave address: 0x%04X, slot: %d",
+           __FUNCTION__,
+          __LINE__,
+          s_ctrl->sensordata->slave_info.sensor_id,
+          s_ctrl->sensordata->slave_info.sensor_slave_addr,
+          s_ctrl->soc_info.index);
+    printk("========================================");
+
 	slave_info = &(s_ctrl->sensordata->slave_info);
 
 	if (!slave_info) {
+        printk("%s:%d, ACHEUL, not slave info", __FUNCTION__, __LINE__);
+
 		CAM_ERR(CAM_SENSOR, " failed: %pK",
 			 slave_info);
 		return -EINVAL;
@@ -762,6 +778,7 @@
 		struct cam_sensor_i2c_reg_array m_i2cWriteRegArray;
 		uint32_t l_chipid = 0;
 
+        printk("%s:%d, ACHEUL, LT6911UXC_SENSOR_ID", __FUNCTION__, __LINE__);
 		// Initialize
 		m_i2cWriteRegArray.reg_addr = 0;
 		m_i2cWriteRegArray.reg_data = 0;
@@ -820,6 +837,7 @@
 		return rc;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	rc = camera_io_dev_read(
 		&(s_ctrl->io_master_info),
 		slave_info->sensor_id_reg_addr,
@@ -827,14 +845,17 @@
 		s_ctrl->sensor_probe_addr_type,
 		s_ctrl->sensor_probe_data_type);
 
-	CAM_DBG(CAM_SENSOR, "read id: 0x%x expected id 0x%x:",
-		chipid, slave_info->sensor_id);
+	printk("%s:%d, read id: 0x%x expected id 0x%x:",
+            __FUNCTION__, __LINE__,
+		    chipid, slave_info->sensor_id);
 
 	if (cam_sensor_id_by_mask(s_ctrl, chipid) != slave_info->sensor_id) {
 		CAM_WARN(CAM_SENSOR, "read id: 0x%x expected id 0x%x:",
 				chipid, slave_info->sensor_id);
 		return -ENODEV;
 	}
+
+    printk("%s:%d, ACHEUL, out: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -843,13 +864,21 @@
 {
 	int rc = 0, pkt_opcode = 0;
 	struct cam_control *cmd = (struct cam_control *)arg;
-	struct cam_sensor_power_ctrl_t *power_info =
-		&s_ctrl->sensordata->power_info;
+	struct cam_sensor_power_ctrl_t *power_info = &s_ctrl->sensordata->power_info;
+
 	if (!s_ctrl || !arg) {
 		CAM_ERR(CAM_SENSOR, "s_ctrl is NULL");
 		return -EINVAL;
 	}
 
+    printk("=============================================================================");
+    printk("%s:%d, ACHEUL, in sensor id: 0x%04X, slave address: 0x%04X, slot: %d",
+           __FUNCTION__,
+          __LINE__,
+          s_ctrl->sensordata->slave_info.sensor_id,
+          s_ctrl->sensordata->slave_info.sensor_slave_addr,
+          s_ctrl->soc_info.index);
+
 	if (cmd->op_code != CAM_SENSOR_PROBE_CMD) {
 		if (cmd->handle_type != CAM_HANDLE_USER_POINTER) {
 			CAM_ERR(CAM_SENSOR, "Invalid handle type: %d",
@@ -860,246 +889,286 @@
 
 	mutex_lock(&(s_ctrl->cam_sensor_mutex));
 	switch (cmd->op_code) {
-	case CAM_SENSOR_PROBE_CMD: {
-		if (s_ctrl->is_probe_succeed == 1) {
-			CAM_ERR(CAM_SENSOR,
-				"Already Sensor Probed in the slot");
-			break;
-		}
+	    case CAM_SENSOR_PROBE_CMD: {
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD", __FUNCTION__, __LINE__);
+            if (s_ctrl->is_probe_succeed == 1) {
+                CAM_ERR(CAM_SENSOR,
+                    "Already Sensor Probed in the slot");
+                break;
+            }
 
-		if (cmd->handle_type ==
-			CAM_HANDLE_MEM_HANDLE) {
-			rc = cam_handle_mem_ptr(cmd->handle, s_ctrl);
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");
-				goto release_mutex;
-			}
-		} else {
-			CAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",
-				 cmd->handle_type);
-			rc = -EINVAL;
-			goto release_mutex;
-		}
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD", __FUNCTION__, __LINE__);
+            if (cmd->handle_type ==
+                CAM_HANDLE_MEM_HANDLE) {
+                rc = cam_handle_mem_ptr(cmd->handle, s_ctrl);
+                if (rc < 0) {
+                    CAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");
+                    goto release_mutex;
+                }
+            } else {
+                CAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",
+                     cmd->handle_type);
+                rc = -EINVAL;
+                goto release_mutex;
+            }
 
-		/* Parse and fill vreg params for powerup settings */
-		rc = msm_camera_fill_vreg_params(
-			&s_ctrl->soc_info,
-			s_ctrl->sensordata->power_info.power_setting,
-			s_ctrl->sensordata->power_info.power_setting_size);
-		if (rc < 0) {
-			CAM_ERR(CAM_SENSOR,
-				"Fail in filling vreg params for PUP rc %d",
-				 rc);
-			goto free_power_settings;
-		}
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD", __FUNCTION__, __LINE__);
+            /* Parse and fill vreg params for powerup settings */
+            rc = msm_camera_fill_vreg_params(
+                &s_ctrl->soc_info,
+                s_ctrl->sensordata->power_info.power_setting,
+                s_ctrl->sensordata->power_info.power_setting_size);
+
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD", __FUNCTION__, __LINE__);
+            if (rc < 0) {
+                CAM_ERR(CAM_SENSOR,
+                    "Fail in filling vreg params for PUP rc %d",
+                     rc);
+                goto free_power_settings;
+            }
 
-		/* Parse and fill vreg params for powerdown settings*/
-		rc = msm_camera_fill_vreg_params(
-			&s_ctrl->soc_info,
-			s_ctrl->sensordata->power_info.power_down_setting,
-			s_ctrl->sensordata->power_info.power_down_setting_size);
-		if (rc < 0) {
-			CAM_ERR(CAM_SENSOR,
-				"Fail in filling vreg params for PDOWN rc %d",
-				 rc);
-			goto free_power_settings;
-		}
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD", __FUNCTION__, __LINE__);
+            /* Parse and fill vreg params for powerdown settings*/
+            rc = msm_camera_fill_vreg_params(
+                &s_ctrl->soc_info,
+                s_ctrl->sensordata->power_info.power_down_setting,
+                s_ctrl->sensordata->power_info.power_down_setting_size);
+            if (rc < 0) {
+                CAM_ERR(CAM_SENSOR,
+                    "Fail in filling vreg params for PDOWN rc %d",
+                     rc);
+                goto free_power_settings;
+            }
 
-		/* Power up and probe sensor */
-		rc = cam_sensor_power_up(s_ctrl);
-		if (rc < 0) {
-			CAM_ERR(CAM_SENSOR, "power up failed");
-			goto free_power_settings;
-		}
-		if (s_ctrl->i2c_data.poweron_reg_settings.is_settings_valid) {
-           
-			rc = cam_sensor_apply_settings(s_ctrl, 0,
-				CAM_SENSOR_PACKET_OPCODE_SENSOR_POWERON_REG);
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR, "PowerOn REG_WR failed");
-				goto free_power_settings;
-			}
-		    if (s_ctrl->sensordata->slave_info.sensor_id == LT6911UXC_SENSOR_ID) {
-				      cam_hdmi_bdg_set_cam_ctrl(s_ctrl);
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD", __FUNCTION__, __LINE__);
+            /* Power up and probe sensor */
+            rc = cam_sensor_power_up(s_ctrl);
+            if (rc < 0) {
+                CAM_ERR(CAM_SENSOR, "power up failed");
+                goto free_power_settings;
             }
-		}
 
-		/* Match sensor ID */
-		s_ctrl->is_always_on = 0;
-		rc = cam_sensor_match_id(s_ctrl);
-		if (rc < 0) {
-			cam_sensor_power_down(s_ctrl);
-			msleep(20);
-			goto free_power_settings;
-		}
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD, power on: %d", __FUNCTION__, __LINE__, s_ctrl->i2c_data.poweron_reg_settings.is_settings_valid);
+            if (s_ctrl->i2c_data.poweron_reg_settings.is_settings_valid) {
+
+                printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD apply power on reg", __FUNCTION__, __LINE__);
+                rc = cam_sensor_apply_settings(s_ctrl, 0, CAM_SENSOR_PACKET_OPCODE_SENSOR_POWERON_REG);
+                if (rc < 0) {
+                    CAM_ERR(CAM_SENSOR, "PowerOn REG_WR failed");
+                    goto free_power_settings;
+                }
+                if (s_ctrl->sensordata->slave_info.sensor_id == LT6911UXC_SENSOR_ID) {
+                          cam_hdmi_bdg_set_cam_ctrl(s_ctrl);
+                }
+            }
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD", __FUNCTION__, __LINE__);
+
+            /* Match sensor ID */
+            s_ctrl->is_always_on = 0;
+            rc = cam_sensor_match_id(s_ctrl);
+            if (rc < 0) {
+                cam_sensor_power_down(s_ctrl);
+                msleep(20);
+                goto free_power_settings;
+            }
+
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD, power off: %d", __FUNCTION__, __LINE__, s_ctrl->i2c_data.poweroff_reg_settings.is_settings_valid);
+            if (s_ctrl->i2c_data.poweroff_reg_settings.is_settings_valid && !rc) {
+                printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD apply power off reg", __FUNCTION__, __LINE__);
+                rc = cam_sensor_apply_settings(s_ctrl, 0,
+                    CAM_SENSOR_PACKET_OPCODE_SENSOR_POWEROFF_REG);
+                s_ctrl->is_always_on = 1;
+                if (rc < 0) {
+                    CAM_ERR(CAM_SENSOR, "PowerOff REG_WR failed");
+                    goto free_power_settings;
+                }
+            }
+
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD, always on %d", __FUNCTION__, __LINE__, s_ctrl->is_always_on);
+            if (s_ctrl->is_always_on == 0) {
+
+                printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD, powering off", __FUNCTION__, __LINE__);
+                rc = cam_sensor_power_down(s_ctrl);
+                if (rc < 0) {
+                    CAM_ERR(CAM_SENSOR,
+                            "fail in Sensor Power Down");
+                    goto free_power_settings;
+                }
+            }
+
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD", __FUNCTION__, __LINE__);
+            CAM_INFO(CAM_SENSOR,
+                "Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",
+                s_ctrl->soc_info.index,
+                s_ctrl->sensordata->slave_info.sensor_slave_addr,
+                s_ctrl->sensordata->slave_info.sensor_id);
+
+            cam_sensor_free_power_reg_rsc(s_ctrl);
+            /*
+             * Set probe succeeded flag to 1 so that no other camera shall
+             * probed on this slot
+             */
+            s_ctrl->is_probe_succeed = 1;
+            s_ctrl->sensor_state = CAM_SENSOR_INIT;
+
+            if (s_ctrl->sensordata->slave_info.sensor_id == LT6911UXC_SENSOR_ID) {
+                 rc = cam_hdmi_bdg_upgrade_firmware();
+                 CAM_INFO(CAM_SENSOR,"LT6911 firmare  upgrade status: %d",rc);
+            }
+
+            printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD", __FUNCTION__, __LINE__);
+	    }
+
+        printk("%s:%d, ACHEUL, CAM_SENSOR_PROBE_CMD Success, sensor: 0x%04X, slave addr: 0x%04X",
+                __FUNCTION__, __LINE__,
+                s_ctrl->sensordata->slave_info.sensor_id,
+                s_ctrl->sensordata->slave_info.sensor_slave_addr);
 
-		if (s_ctrl->i2c_data.poweroff_reg_settings.is_settings_valid
-			&& !rc) {
-			rc = cam_sensor_apply_settings(s_ctrl, 0,
-				CAM_SENSOR_PACKET_OPCODE_SENSOR_POWEROFF_REG);
-			s_ctrl->is_always_on = 1;
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR, "PowerOff REG_WR failed");
-				goto free_power_settings;
-			}
-		}
 
-		if (s_ctrl->is_always_on == 0) {
-			rc = cam_sensor_power_down(s_ctrl);
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR,
-						"fail in Sensor Power Down");
-				goto free_power_settings;
-			}
-		}
 
-		CAM_INFO(CAM_SENSOR,
-			"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",
-			s_ctrl->soc_info.index,
-			s_ctrl->sensordata->slave_info.sensor_slave_addr,
-			s_ctrl->sensordata->slave_info.sensor_id);
-
-		cam_sensor_free_power_reg_rsc(s_ctrl);
-		/*
-		 * Set probe succeeded flag to 1 so that no other camera shall
-		 * probed on this slot
-		 */
-		s_ctrl->is_probe_succeed = 1;
-		s_ctrl->sensor_state = CAM_SENSOR_INIT;
-		
-		if (s_ctrl->sensordata->slave_info.sensor_id == LT6911UXC_SENSOR_ID) {
-	         rc = cam_hdmi_bdg_upgrade_firmware();
-		     CAM_INFO(CAM_SENSOR,"LT6911 firmare  upgrade status: %d",rc);
-		}
-		
-	}
 		break;
 	case CAM_ACQUIRE_DEV: {
-		struct cam_sensor_acquire_dev sensor_acq_dev;
-		struct cam_create_dev_hdl bridge_params;
-
-		if ((s_ctrl->is_probe_succeed == 0) ||
-			(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {
-			CAM_WARN(CAM_SENSOR,
-				"Not in right state to aquire %d， probe %d",
-				s_ctrl->sensor_state, s_ctrl->is_probe_succeed);
-			rc = -EINVAL;
-			goto release_mutex;
-		}
+            struct cam_sensor_acquire_dev sensor_acq_dev;
+            struct cam_create_dev_hdl bridge_params;
+            printk("%s:%d, ACHEUL, CAM_ACQUIRE_DEV", __FUNCTION__, __LINE__);
+
+            if ((s_ctrl->is_probe_succeed == 0) ||
+                (s_ctrl->sensor_state != CAM_SENSOR_INIT)) {
+                CAM_WARN(CAM_SENSOR,
+                    "Not in right state to aquire %d， probe %d",
+                    s_ctrl->sensor_state, s_ctrl->is_probe_succeed);
+                rc = -EINVAL;
+                goto release_mutex;
+            }
 
-		if (s_ctrl->bridge_intf.device_hdl != -1) {
-			CAM_ERR(CAM_SENSOR, "Device is already acquired");
-			rc = -EINVAL;
-			goto release_mutex;
-		}
-		rc = copy_from_user(&sensor_acq_dev,
-			u64_to_user_ptr(cmd->handle),
-			sizeof(sensor_acq_dev));
-		if (rc < 0) {
-			CAM_ERR(CAM_SENSOR, "Failed Copying from user");
-			goto release_mutex;
-		}
+            if (s_ctrl->bridge_intf.device_hdl != -1) {
+                CAM_ERR(CAM_SENSOR, "Device is already acquired");
+                rc = -EINVAL;
+                goto release_mutex;
+            }
+            rc = copy_from_user(&sensor_acq_dev,
+                u64_to_user_ptr(cmd->handle),
+                sizeof(sensor_acq_dev));
+            if (rc < 0) {
+                CAM_ERR(CAM_SENSOR, "Failed Copying from user");
+                goto release_mutex;
+            }
 
-		bridge_params.session_hdl = sensor_acq_dev.session_handle;
-		bridge_params.ops = &s_ctrl->bridge_intf.ops;
-		bridge_params.v4l2_sub_dev_flag = 0;
-		bridge_params.media_entity_flag = 0;
-		bridge_params.priv = s_ctrl;
-
-		sensor_acq_dev.device_handle =
-			cam_create_device_hdl(&bridge_params);
-		if (sensor_acq_dev.device_handle <= 0) {
-			rc = -EFAULT;
-			CAM_ERR(CAM_SENSOR, "Can not create device handle");
-			goto release_mutex;
-		}
-		s_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;
-		s_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;
+            bridge_params.session_hdl = sensor_acq_dev.session_handle;
+            bridge_params.ops = &s_ctrl->bridge_intf.ops;
+            bridge_params.v4l2_sub_dev_flag = 0;
+            bridge_params.media_entity_flag = 0;
+            bridge_params.priv = s_ctrl;
+
+            sensor_acq_dev.device_handle =
+                cam_create_device_hdl(&bridge_params);
+            if (sensor_acq_dev.device_handle <= 0) {
+                rc = -EFAULT;
+                CAM_ERR(CAM_SENSOR, "Can not create device handle");
+                goto release_mutex;
+            }
+            s_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;
+            s_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;
 
-		CAM_DBG(CAM_SENSOR, "Device Handle: %d",
-			sensor_acq_dev.device_handle);
-		if (copy_to_user(u64_to_user_ptr(cmd->handle),
-			&sensor_acq_dev,
-			sizeof(struct cam_sensor_acquire_dev))) {
-			CAM_ERR(CAM_SENSOR, "Failed Copy to User");
-			rc = -EFAULT;
-			goto release_mutex;
-		}
+            CAM_DBG(CAM_SENSOR, "Device Handle: %d",
+                sensor_acq_dev.device_handle);
+            if (copy_to_user(u64_to_user_ptr(cmd->handle),
+                &sensor_acq_dev,
+                sizeof(struct cam_sensor_acquire_dev))) {
+                CAM_ERR(CAM_SENSOR, "Failed Copy to User");
+                rc = -EFAULT;
+                goto release_mutex;
+            }
 
-		if (!s_ctrl->is_always_on) {
-			rc = cam_sensor_power_up(s_ctrl);
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR, "Sensor Power up failed");
-				goto release_mutex;
-			}
-		}
+            if (!s_ctrl->is_always_on) {
+                rc = cam_sensor_power_up(s_ctrl);
+                if (rc < 0) {
+                    CAM_ERR(CAM_SENSOR, "Sensor Power up failed");
+                    goto release_mutex;
+                }
+            }
 
-		s_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;
-		s_ctrl->last_flush_req = 0;
-		CAM_INFO(CAM_SENSOR,
-			"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",
-			s_ctrl->sensordata->slave_info.sensor_id,
-			s_ctrl->sensordata->slave_info.sensor_slave_addr);
-	}
+            printk("%s:%d, ACHEUL, CAM_ACQUIRE_DEV Success, sensor: 0x%04X, slave addr: 0x%04X",
+                    __FUNCTION__, __LINE__,
+			        s_ctrl->sensordata->slave_info.sensor_id,
+			        s_ctrl->sensordata->slave_info.sensor_slave_addr);
+
+            s_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;
+            s_ctrl->last_flush_req = 0;
+            CAM_INFO(CAM_SENSOR,
+                "CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",
+                s_ctrl->sensordata->slave_info.sensor_id,
+                s_ctrl->sensordata->slave_info.sensor_slave_addr);
+	    }
 		break;
 	case CAM_RELEASE_DEV: {
-		if ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||
-			(s_ctrl->sensor_state == CAM_SENSOR_START)) {
-			rc = -EINVAL;
-			CAM_WARN(CAM_SENSOR,
-			"Not in right state to release : %d",
-			s_ctrl->sensor_state);
-			goto release_mutex;
-		}
+            printk("%s:%d, ACHEUL, CAM_RELEASE_DEV", __FUNCTION__, __LINE__);
+            if ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||
+                (s_ctrl->sensor_state == CAM_SENSOR_START)) {
+                rc = -EINVAL;
+                CAM_WARN(CAM_SENSOR,
+                "Not in right state to release : %d",
+                s_ctrl->sensor_state);
+                goto release_mutex;
+            }
 
-		if (s_ctrl->bridge_intf.link_hdl != -1) {
-			CAM_ERR(CAM_SENSOR,
-				"Device [%d] still active on link 0x%x",
-				s_ctrl->sensor_state,
-				s_ctrl->bridge_intf.link_hdl);
-			rc = -EAGAIN;
-			goto release_mutex;
-		}
+            if (s_ctrl->bridge_intf.link_hdl != -1) {
+                CAM_ERR(CAM_SENSOR,
+                    "Device [%d] still active on link 0x%x",
+                    s_ctrl->sensor_state,
+                    s_ctrl->bridge_intf.link_hdl);
+                rc = -EAGAIN;
+                goto release_mutex;
+            }
 
-		if (!s_ctrl->is_always_on) {
-			rc = cam_sensor_power_down(s_ctrl);
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR, "Sensor Power Down failed");
-				goto release_mutex;
-			}
-		}
+            if (!s_ctrl->is_always_on) {
+                rc = cam_sensor_power_down(s_ctrl);
+                if (rc < 0) {
+                    CAM_ERR(CAM_SENSOR, "Sensor Power Down failed");
+                    goto release_mutex;
+                }
+            }
 
-		cam_sensor_release_per_frame_resource(s_ctrl);
-		cam_sensor_release_stream_rsc(s_ctrl);
-		if (s_ctrl->bridge_intf.device_hdl == -1) {
-			CAM_ERR(CAM_SENSOR,
-				"Invalid Handles: link hdl: %d device hdl: %d",
-				s_ctrl->bridge_intf.device_hdl,
-				s_ctrl->bridge_intf.link_hdl);
-			rc = -EINVAL;
-			goto release_mutex;
-		}
-		rc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);
-		if (rc < 0)
-			CAM_ERR(CAM_SENSOR,
-				"failed in destroying the device hdl");
-		s_ctrl->bridge_intf.device_hdl = -1;
-		s_ctrl->bridge_intf.link_hdl = -1;
-		s_ctrl->bridge_intf.session_hdl = -1;
+            cam_sensor_release_per_frame_resource(s_ctrl);
+            cam_sensor_release_stream_rsc(s_ctrl);
+            if (s_ctrl->bridge_intf.device_hdl == -1) {
+                CAM_ERR(CAM_SENSOR,
+                    "Invalid Handles: link hdl: %d device hdl: %d",
+                    s_ctrl->bridge_intf.device_hdl,
+                    s_ctrl->bridge_intf.link_hdl);
+                rc = -EINVAL;
+                goto release_mutex;
+            }
+            rc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);
+            if (rc < 0)
+                CAM_ERR(CAM_SENSOR,
+                    "failed in destroying the device hdl");
+            s_ctrl->bridge_intf.device_hdl = -1;
+            s_ctrl->bridge_intf.link_hdl = -1;
+            s_ctrl->bridge_intf.session_hdl = -1;
+
+            s_ctrl->sensor_state = CAM_SENSOR_INIT;
+            CAM_INFO(CAM_SENSOR,
+                "CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",
+                s_ctrl->sensordata->slave_info.sensor_id,
+                s_ctrl->sensordata->slave_info.sensor_slave_addr);
+            s_ctrl->streamon_count = 0;
+            s_ctrl->streamoff_count = 0;
+            s_ctrl->last_flush_req = 0;
 
-		s_ctrl->sensor_state = CAM_SENSOR_INIT;
-		CAM_INFO(CAM_SENSOR,
-			"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",
+        }
+
+        printk("%s:%d, ACHEUL, CAM_RELEASE_DEV Success, sensor: 0x%04X, slave addr: 0x%04X",
+              __FUNCTION__, __LINE__,
 			s_ctrl->sensordata->slave_info.sensor_id,
 			s_ctrl->sensordata->slave_info.sensor_slave_addr);
-		s_ctrl->streamon_count = 0;
-		s_ctrl->streamoff_count = 0;
-		s_ctrl->last_flush_req = 0;
-	}
+
 		break;
 	case CAM_QUERY_CAP: {
 		struct  cam_sensor_query_cap sensor_cap;
 
+        printk("%s:%d, ACHEUL, CAM_QUERY_CAP", __FUNCTION__, __LINE__);
+
 		cam_sensor_query_cap(s_ctrl, &sensor_cap);
 		if (copy_to_user(u64_to_user_ptr(cmd->handle),
 			&sensor_cap, sizeof(struct  cam_sensor_query_cap))) {
@@ -1107,9 +1176,16 @@
 			rc = -EFAULT;
 			goto release_mutex;
 		}
+
+        printk("%s:%d, ACHEUL, CAM_QUERY_CAP Success, sensor: 0x%04X, slave addr: 0x%04X",
+              __FUNCTION__, __LINE__,
+			s_ctrl->sensordata->slave_info.sensor_id,
+			s_ctrl->sensordata->slave_info.sensor_slave_addr);
+
 		break;
 	}
 	case CAM_START_DEV: {
+        printk("%s:%d, ACHEUL, CAM_START_DEV", __FUNCTION__, __LINE__);
 		if ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||
 			(s_ctrl->sensor_state == CAM_SENSOR_START)) {
 			rc = -EINVAL;
@@ -1130,6 +1206,12 @@
 			}
 		}
 		s_ctrl->sensor_state = CAM_SENSOR_START;
+
+        printk("%s:%d, ACHEUL, CAM_START_DEV Success, sensor: 0x%04X, slave addr: 0x%04X",
+              __FUNCTION__, __LINE__,
+			s_ctrl->sensordata->slave_info.sensor_id,
+			s_ctrl->sensordata->slave_info.sensor_slave_addr);
+
 		CAM_INFO(CAM_SENSOR,
 			"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",
 			s_ctrl->sensordata->slave_info.sensor_id,
@@ -1137,6 +1219,7 @@
 	}
 		break;
 	case CAM_STOP_DEV: {
+        printk("%s:%d, ACHEUL, CAM_STOP_DEV", __FUNCTION__, __LINE__);
 		if (s_ctrl->sensor_state != CAM_SENSOR_START) {
 			rc = -EINVAL;
 			CAM_WARN(CAM_SENSOR,
@@ -1165,6 +1248,8 @@
 	}
 		break;
 	case CAM_CONFIG_DEV: {
+
+        printk("%s:%d, ACHEUL, CAM_CONFIG_DEV", __FUNCTION__, __LINE__);
 		rc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);
 		if (rc < 0) {
 			CAM_ERR(CAM_SENSOR, "Failed i2c pkt parse: %d", rc);
@@ -1248,6 +1333,11 @@
 			}
 		}
 
+        printk("%s:%d, ACHEUL, CAM_CONFIG_DEV, sensor: 0x%04X, slave addr: 0x%04X",
+              __FUNCTION__, __LINE__,
+			s_ctrl->sensordata->slave_info.sensor_id,
+			s_ctrl->sensordata->slave_info.sensor_slave_addr);
+
 		CAM_DBG(CAM_SENSOR,
 			"CAM_CONFIG_DEV done sensor_id:0x%x,sensor_slave_addr:0x%x",
 			s_ctrl->sensordata->slave_info.sensor_id,
@@ -1262,6 +1352,8 @@
 
 release_mutex:
 	mutex_unlock(&(s_ctrl->cam_sensor_mutex));
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__);
+    printk("=============================================================================");
 	return rc;
 
 free_power_settings:
@@ -1273,6 +1365,8 @@
 	power_info->power_setting_size = 0;
 	cam_sensor_free_power_reg_rsc(s_ctrl);
 	mutex_unlock(&(s_ctrl->cam_sensor_mutex));
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__);
+    printk("=============================================================================");
 	return rc;
 }
 
@@ -1333,14 +1427,17 @@
 int cam_sensor_power(struct v4l2_subdev *sd, int on)
 {
 	struct cam_sensor_ctrl_t *s_ctrl = v4l2_get_subdevdata(sd);
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	mutex_lock(&(s_ctrl->cam_sensor_mutex));
 	if (!on && s_ctrl->sensor_state == CAM_SENSOR_START) {
+        printk("%s:%d, ACHEUL not on", __FUNCTION__, __LINE__);
 		cam_sensor_power_down(s_ctrl);
 		s_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;
 	}
 	mutex_unlock(&(s_ctrl->cam_sensor_mutex));
 
+    printk("%s:%d, ACHEUL out", __FUNCTION__, __LINE__);
 	return 0;
 }
 
@@ -1351,6 +1448,8 @@
 	struct cam_camera_slave_info *slave_info;
 	struct cam_hw_soc_info *soc_info;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!s_ctrl) {
 		CAM_ERR(CAM_SENSOR, "failed: %pK", s_ctrl);
 		return -EINVAL;
@@ -1367,8 +1466,7 @@
 	soc_info = &s_ctrl->soc_info;
 
 	if (s_ctrl->bob_pwm_switch) {
-		rc = cam_sensor_bob_pwm_mode_switch(soc_info,
-			s_ctrl->bob_reg_index, true);
+		rc = cam_sensor_bob_pwm_mode_switch(soc_info, s_ctrl->bob_reg_index, true);
 		if (rc) {
 			CAM_WARN(CAM_SENSOR,
 			"BoB PWM setup failed rc: %d", rc);
@@ -1383,9 +1481,11 @@
 	}
 
 	rc = camera_io_init(&(s_ctrl->io_master_info));
-	if (rc < 0)
+	if (rc < 0){
 		CAM_ERR(CAM_SENSOR, "cci_init failed: rc: %d", rc);
+    }
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -1395,6 +1495,11 @@
 	struct cam_hw_soc_info *soc_info;
 	int rc = 0;
 
+    printk("==============================================");
+    printk("%s:%d, ACHEUL FIXME! DISABLED", __FUNCTION__, __LINE__);
+    printk("==============================================");
+    return 0;
+
 	if (!s_ctrl) {
 		CAM_ERR(CAM_SENSOR, "failed: s_ctrl %pK", s_ctrl);
 		return -EINVAL;
@@ -1425,6 +1530,7 @@
 
 	camera_io_release(&(s_ctrl->io_master_info));
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor: cam_sensor_core.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor: cam_sensor_dev.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor: cam_sensor_dev.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor: cam_sensor_soc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor: cam_sensor_soc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io: cam_sensor_cci_i2c.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io: cam_sensor_i2c.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.c kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.c	2024-05-28 21:11:35.803594498 -0400
+++ kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.c	2024-05-29 22:10:12.813804772 -0400
@@ -73,20 +73,29 @@
 		return -EINVAL;
 	}
 
+    printk("%s:%d, ACHEUL address type: %d, data type: %d, address: 0x%04X", __FUNCTION__, __LINE__, addr_type, data_type, addr);
+
 	if (io_master_info->master_type == CCI_MASTER) {
+
+        printk("%s:%d, ACHEUL CCI_MASTER", __FUNCTION__, __LINE__);
 		return cam_cci_i2c_read(io_master_info->cci_client,
 			addr, data, addr_type, data_type);
 	} else if (io_master_info->master_type == I2C_MASTER) {
+        printk("%s:%d, ACHEUL I2C_MASTER", __FUNCTION__, __LINE__);
 		return cam_qup_i2c_read(io_master_info->client,
 			addr, data, addr_type, data_type);
 	} else if (io_master_info->master_type == SPI_MASTER) {
+        printk("%s:%d, ACHEUL SPI_MASTER", __FUNCTION__, __LINE__);
 		return cam_spi_read(io_master_info,
 			addr, data, addr_type, data_type);
 	} else {
+        printk("%s:%d, ACHEUL invalid type", __FUNCTION__, __LINE__);
 		CAM_ERR(CAM_SENSOR, "Invalid Comm. Master:%d",
 			io_master_info->master_type);
 		return -EINVAL;
 	}
+
+    printk("%s:%d, ACHEUL data: 0x%04X", __FUNCTION__, __LINE__, *data);
 	return 0;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io: cam_sensor_io.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io: cam_sensor_qup_i2c.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io: cam_sensor_spi.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io: cam_sensor_spi.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_io: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils: cam_sensor_cmn_header.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c	2024-05-28 21:11:35.803594498 -0400
+++ kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c	2024-05-29 22:10:12.801804666 -0400
@@ -1483,6 +1483,8 @@
 	struct cam_soc_gpio_data *gconf = NULL;
 	struct msm_camera_gpio_num_info *gpio_num_info = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!soc_info->dev) {
 		CAM_ERR(CAM_SENSOR, "device node NULL");
 		return -EINVAL;
@@ -1528,6 +1530,7 @@
 				gconf->cam_gpio_common_tbl[val].gpio;
 		gpio_num_info->valid[SENSOR_VANA] = 1;
 
+        printk("%s:%d, gpio-vana %d", __FUNCTION__, __LINE__, gpio_num_info->gpio_num[SENSOR_VANA]);
 		CAM_DBG(CAM_SENSOR, "gpio-vana %d",
 			gpio_num_info->gpio_num[SENSOR_VANA]);
 	}
@@ -1545,6 +1548,7 @@
 			gconf->cam_gpio_common_tbl[val].gpio;
 		gpio_num_info->valid[SENSOR_VIO] = 1;
 
+        printk("%s:%d, gpio-vio %d", __FUNCTION__, __LINE__, gpio_num_info->gpio_num[SENSOR_VIO]);
 		CAM_DBG(CAM_SENSOR, "gpio-vio %d",
 			gpio_num_info->gpio_num[SENSOR_VIO]);
 	}
@@ -1563,6 +1567,7 @@
 			gconf->cam_gpio_common_tbl[val].gpio;
 		gpio_num_info->valid[SENSOR_VAF] = 1;
 
+        printk("%s:%d, gpio-vaf %d", __FUNCTION__, __LINE__, gpio_num_info->gpio_num[SENSOR_VAF]);
 		CAM_DBG(CAM_SENSOR, "gpio-vaf %d",
 			gpio_num_info->gpio_num[SENSOR_VAF]);
 	}
@@ -1581,6 +1586,7 @@
 			gconf->cam_gpio_common_tbl[val].gpio;
 		gpio_num_info->valid[SENSOR_VDIG] = 1;
 
+        printk("%s:%d, gpio-vdig %d", __FUNCTION__, __LINE__, gpio_num_info->gpio_num[SENSOR_VDIG]);
 		CAM_DBG(CAM_SENSOR, "gpio-vdig %d",
 				gpio_num_info->gpio_num[SENSOR_VDIG]);
 	}
@@ -1599,6 +1605,7 @@
 			gconf->cam_gpio_common_tbl[val].gpio;
 		gpio_num_info->valid[SENSOR_RESET] = 1;
 
+        printk("%s:%d, gpio-reset %d", __FUNCTION__, __LINE__, gpio_num_info->gpio_num[SENSOR_RESET]);
 		CAM_DBG(CAM_SENSOR, "gpio-reset %d",
 			gpio_num_info->gpio_num[SENSOR_RESET]);
 	}
@@ -1618,6 +1625,7 @@
 			gconf->cam_gpio_common_tbl[val].gpio;
 		gpio_num_info->valid[SENSOR_STANDBY] = 1;
 
+        printk("%s:%d, gpio-standby %d", __FUNCTION__, __LINE__, gpio_num_info->gpio_num[SENSOR_STANDBY]);
 		CAM_DBG(CAM_SENSOR, "gpio-standby %d",
 			gpio_num_info->gpio_num[SENSOR_STANDBY]);
 	}
@@ -1637,6 +1645,7 @@
 			gconf->cam_gpio_common_tbl[val].gpio;
 		gpio_num_info->valid[SENSOR_VAF_PWDM] = 1;
 
+        printk("%s:%d, gpio-af-pwdm %d", __FUNCTION__, __LINE__, gpio_num_info->gpio_num[SENSOR_VAF_PWDM]);
 		CAM_DBG(CAM_SENSOR, "gpio-af-pwdm %d",
 			gpio_num_info->gpio_num[SENSOR_VAF_PWDM]);
 	}
@@ -1656,6 +1665,7 @@
 			gconf->cam_gpio_common_tbl[val].gpio;
 		gpio_num_info->valid[SENSOR_CUSTOM_GPIO1] = 1;
 
+        printk("%s:%d, gpio-custom1 %d", __FUNCTION__, __LINE__, gpio_num_info->gpio_num[SENSOR_CUSTOM_GPIO1]);
 		CAM_DBG(CAM_SENSOR, "gpio-custom1 %d",
 			gpio_num_info->gpio_num[SENSOR_CUSTOM_GPIO1]);
 	}
@@ -1675,12 +1685,14 @@
 			gconf->cam_gpio_common_tbl[val].gpio;
 		gpio_num_info->valid[SENSOR_CUSTOM_GPIO2] = 1;
 
+        printk("%s:%d, gpio-custom2 %d", __FUNCTION__, __LINE__, gpio_num_info->gpio_num[SENSOR_CUSTOM_GPIO2]);
 		CAM_DBG(CAM_SENSOR, "gpio-custom2 %d",
 			gpio_num_info->gpio_num[SENSOR_CUSTOM_GPIO2]);
 	} else {
 		rc = 0;
 	}
 
+    printk("%s:%d, ACHEUL: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 
 free_gpio_info:
@@ -1746,6 +1758,7 @@
 		return 0;
 	}
 
+	printk("%s:%d, ACHEUL eq type: %d, config: %d, valid GPIO: %d, gpio num: %d", __FUNCTION__, __LINE__, seq_type, val, gpio_num_info->valid[gpio_offset], gpio_num_info->gpio_num[gpio_offset]);
 	CAM_DBG(CAM_SENSOR, "Seq type: %d, config: %d", seq_type, val);
 
 	gpio_offset = seq_type;
@@ -1821,6 +1834,8 @@
 	struct cam_sensor_power_setting *power_setting = NULL;
 	struct msm_camera_gpio_num_info *gpio_num_info = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	CAM_DBG(CAM_SENSOR, "Enter");
 	if (!ctrl) {
 		CAM_ERR(CAM_SENSOR, "Invalid ctrl handle");
@@ -1886,6 +1901,7 @@
 
 		switch (power_setting->seq_type) {
 		case SENSOR_MCLK:
+            printk("%s:%d, ACHEUL, SENSOR_MCLK", __FUNCTION__, __LINE__);
 			if (power_setting->seq_val >= soc_info->num_clk) {
 				CAM_ERR(CAM_SENSOR, "clk index %d >= max %u",
 					power_setting->seq_val,
@@ -1953,6 +1969,12 @@
 		case SENSOR_STANDBY:
 		case SENSOR_CUSTOM_GPIO1:
 		case SENSOR_CUSTOM_GPIO2:
+
+            if (power_setting->seq_type == SENSOR_RESET       ) printk("%s:%d, ACHEUL, SENSOR_RESET"       , __FUNCTION__, __LINE__);
+            if (power_setting->seq_type == SENSOR_STANDBY     ) printk("%s:%d, ACHEUL, SENSOR_STANDBY"     , __FUNCTION__, __LINE__);
+            if (power_setting->seq_type == SENSOR_CUSTOM_GPIO1) printk("%s:%d, ACHEUL, SENSOR_CUSTOM_GPIO1", __FUNCTION__, __LINE__);
+            if (power_setting->seq_type == SENSOR_CUSTOM_GPIO2) printk("%s:%d, ACHEUL, SENSOR_CUSTOM_GPIO2", __FUNCTION__, __LINE__);
+
 			if (no_gpio) {
 				CAM_ERR(CAM_SENSOR, "request gpio failed");
 				goto power_up_failed;
@@ -1961,6 +1983,9 @@
 				CAM_ERR(CAM_SENSOR, "Invalid gpio_num_info");
 				goto power_up_failed;
 			}
+
+            printk("%s:%d, ACHEUL, type: %d, GPIO: %d, config_val: 0x%04X", __FUNCTION__, __LINE__, power_setting->seq_type, gpio_num_info->gpio_num [power_setting->seq_type], power_setting->config_val);
+
 			CAM_DBG(CAM_SENSOR, "gpio set val %d",
 				gpio_num_info->gpio_num
 				[power_setting->seq_type]);
@@ -1982,8 +2007,19 @@
 		case SENSOR_VAF_PWDM:
 		case SENSOR_CUSTOM_REG1:
 		case SENSOR_CUSTOM_REG2:
-			if (power_setting->seq_val == INVALID_VREG)
+
+            if (power_setting->seq_type == SENSOR_VANA       ) printk("%s:%d, ACHEUL, SENSOR_VANA"       , __FUNCTION__, __LINE__);
+            if (power_setting->seq_type == SENSOR_VDIG       ) printk("%s:%d, ACHEUL, SENSOR_VDIG"       , __FUNCTION__, __LINE__);
+            if (power_setting->seq_type == SENSOR_VIO        ) printk("%s:%d, ACHEUL, SENSOR_VIO"        , __FUNCTION__, __LINE__);
+            if (power_setting->seq_type == SENSOR_VAF        ) printk("%s:%d, ACHEUL, SENSOR_VAF"        , __FUNCTION__, __LINE__);
+            if (power_setting->seq_type == SENSOR_VAF_PWDM   ) printk("%s:%d, ACHEUL, SENSOR_VAF_PWDM"   , __FUNCTION__, __LINE__);
+            if (power_setting->seq_type == SENSOR_CUSTOM_REG1) printk("%s:%d, ACHEUL, SENSOR_CUSTOM_REG1", __FUNCTION__, __LINE__);
+            if (power_setting->seq_type == SENSOR_CUSTOM_REG2) printk("%s:%d, ACHEUL, SENSOR_CUSTOM_REG2", __FUNCTION__, __LINE__);
+
+			if (power_setting->seq_val == INVALID_VREG) {
+                printk("%s:%d, ACHEUL invalid reg", __FUNCTION__, __LINE__);
 				break;
+            }
 
 			if (power_setting->seq_val >= CAM_VREG_MAX) {
 				CAM_ERR(CAM_SENSOR, "vreg index %d >= max %d",
@@ -1992,6 +2028,8 @@
 				goto power_up_failed;
 			}
 			if (power_setting->seq_val < num_vreg) {
+                printk("%s:%d, ACHEUL enabling regulator", __FUNCTION__, __LINE__);
+
 				CAM_DBG(CAM_SENSOR, "Enable Regulator");
 				vreg_idx = power_setting->seq_val;
 
@@ -2057,9 +2095,11 @@
 		CAM_ERR(CAM_SENSOR,
 			"Failed to post init shared pinctrl");
 
+    printk("%s:%d, ACHEUL, out OK", __FUNCTION__, __LINE__);
 	return 0;
 power_up_failed:
 	CAM_ERR(CAM_SENSOR, "failed");
+    printk("%s:%d, ACHEUL, FAILED", __FUNCTION__, __LINE__);
 	for (index--; index >= 0; index--) {
 		CAM_DBG(CAM_SENSOR, "index %d",  index);
 		power_setting = &ctrl->power_setting[index];
@@ -2167,6 +2207,7 @@
 
 	cam_sensor_util_request_gpio_table(soc_info, 0);
 
+    printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -2199,6 +2240,7 @@
 	struct cam_sensor_power_setting *ps = NULL;
 	struct msm_camera_gpio_num_info *gpio_num_info = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	CAM_DBG(CAM_SENSOR, "Enter");
 	if (!ctrl || !soc_info) {
 		CAM_ERR(CAM_SENSOR, "failed ctrl %pK",  ctrl);
@@ -2350,5 +2392,6 @@
 
 	cam_sensor_util_request_gpio_table(soc_info, 0);
 
+    printk("%s:%d, ACHEUL out", __FUNCTION__, __LINE__);
 	return 0;
 }
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils: cam_sensor_util.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers/cam_sensor_module: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_smmu
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_sync
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: cam_utils
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera/drivers: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera: .git
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera: include
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/camera: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display: config
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display: .git
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_audio.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_audio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_aux.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_aux.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_catalog.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_catalog.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_catalog_v200.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_catalog_v420.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_ctrl.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_ctrl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_debug.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_debug.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp/dp_display.c kernel/msm-4.19/techpack/display/msm/dp/dp_display.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp/dp_display.c	2024-05-28 21:11:35.859595109 -0400
+++ kernel/msm-4.19/techpack/display/msm/dp/dp_display.c	2024-05-29 22:10:12.749804210 -0400
@@ -3106,6 +3106,8 @@
 	int rc = 0;
 	struct dp_display_private *dp;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!pdev || !pdev->dev.of_node) {
 		DP_ERR("pdev not found\n");
 		rc = -ENODEV;
@@ -3114,6 +3116,7 @@
 
 	dp = devm_kzalloc(&pdev->dev, sizeof(*dp), GFP_KERNEL);
 	if (!dp) {
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 		rc = -ENOMEM;
 		goto bail;
 	}
@@ -3133,6 +3136,7 @@
 
 	rc = dp_display_create_workqueue(dp);
 	if (rc) {
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 		DP_ERR("Failed to create workqueue\n");
 		goto error;
 	}
@@ -3183,10 +3187,12 @@
 		goto error;
 	}
 
+    printk("%s:%d, ACHEUL, OK", __FUNCTION__, __LINE__);
 	return 0;
 error:
 	devm_kfree(&pdev->dev, dp);
 bail:
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_display.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_drm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_drm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_gpio_hpd.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_gpio_hpd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_hdcp2p2.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_hpd.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_hpd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_link.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_link.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_lphw_hpd.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_lphw_hpd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_mst_drm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_panel.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_panel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_parser.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_parser.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_power.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_power.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_reg.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_usbpd.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dp: dp_usbpd.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_catalog.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_catalog.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_clk.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_clk_manager.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_ctrl.c kernel/msm-4.19/techpack/display/msm/dsi/dsi_ctrl.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_ctrl.c	2024-05-28 21:11:35.863595152 -0400
+++ kernel/msm-4.19/techpack/display/msm/dsi/dsi_ctrl.c	2024-05-29 22:10:12.785804526 -0400
@@ -492,31 +492,44 @@
 				  u32 op_state)
 {
 	struct dsi_ctrl_state_info *state = &dsi_ctrl->current_state;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	switch (op) {
 	case DSI_CTRL_OP_POWER_STATE_CHANGE:
+        printk("%s:%d, ACHEUL, DSI_CTRL_OP_POWER_STATE_CHANGE", __FUNCTION__, __LINE__);
 		state->power_state = op_state;
 		break;
 	case DSI_CTRL_OP_CMD_ENGINE:
+        printk("%s:%d, ACHEUL, DSI_CTRL_OP_CMD_ENGINE", __FUNCTION__, __LINE__);
 		state->cmd_engine_state = op_state;
 		break;
 	case DSI_CTRL_OP_VID_ENGINE:
+        printk("%s:%d, ACHEUL, DSI_CTRL_OP_VID_ENGINE", __FUNCTION__, __LINE__);
 		state->vid_engine_state = op_state;
 		break;
 	case DSI_CTRL_OP_HOST_ENGINE:
+        printk("%s:%d, ACHEUL, DSI_CTRL_OP_HOST_ENGINE", __FUNCTION__, __LINE__);
 		state->controller_state = op_state;
 		break;
 	case DSI_CTRL_OP_HOST_INIT:
+        printk("%s:%d, ACHEUL, DSI_CTRL_OP_HOST_INIT", __FUNCTION__, __LINE__);
 		state->host_initialized = (op_state == 1) ? true : false;
 		break;
 	case DSI_CTRL_OP_TPG:
+        printk("%s:%d, ACHEUL, DSI_CTRL_OP_TPG", __FUNCTION__, __LINE__);
 		state->tpg_enabled = (op_state == 1) ? true : false;
 		break;
 	case DSI_CTRL_OP_CMD_TX:
+        printk("%s:%d, ACHEUL, DSI_CTRL_OP_CMD_TX", __FUNCTION__, __LINE__);
+        break;
 	case DSI_CTRL_OP_PHY_SW_RESET:
+        printk("%s:%d, ACHEUL, DSI_CTRL_OP_PHY_SW_RESET", __FUNCTION__, __LINE__);
+        break;
 	default:
+        printk("%s:%d, ACHEUL, unknown state", __FUNCTION__, __LINE__);
 		break;
 	}
+    printk("%s:%d, ACHEUL, out", __FUNCTION__, __LINE__);
 }
 
 static int dsi_ctrl_init_regmap(struct platform_device *pdev,
@@ -807,9 +820,12 @@
 	int rc = 0;
 	struct dsi_ctrl_bus_scale_info *bus = &ctrl->axi_bus_info;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	bus->bus_scale_table = msm_bus_cl_get_pdata(pdev);
 	if (IS_ERR_OR_NULL(bus->bus_scale_table)) {
 		rc = PTR_ERR(bus->bus_scale_table);
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		DSI_CTRL_DEBUG(ctrl, "msm_bus_cl_get_pdata() failed, rc = %d\n",
 				rc);
 		bus->bus_scale_table = NULL;
@@ -819,9 +835,11 @@
 	bus->bus_handle = msm_bus_scale_register_client(bus->bus_scale_table);
 	if (!bus->bus_handle) {
 		rc = -EINVAL;
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		DSI_CTRL_ERR(ctrl, "failed to register axi bus client\n");
 	}
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -1376,6 +1394,8 @@
 	u32 cnt = 0;
 	u8 *cmdbuf;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	/* Select the tx mode to transfer the command */
 	dsi_message_setup_tx_mode(dsi_ctrl, msg->tx_len, flags);
 
@@ -1473,6 +1493,7 @@
 error:
 	if (buffer)
 		devm_kfree(&dsi_ctrl->pdev->dev, buffer);
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -1915,25 +1936,41 @@
 	const struct of_device_id *id;
 	enum dsi_ctrl_version version;
 	int rc = 0;
+    const char *compatible = NULL;
+    const char *label = NULL;
+
+    printk("%s:%d, ACHEUL, in", __FUNCTION__, __LINE__);
 
 	id = of_match_node(msm_dsi_of_match, pdev->dev.of_node);
-	if (!id)
+	if (!id){
+        printk("%s:%d, ACHEUL, error, no id", __FUNCTION__, __LINE__);
 		return -ENODEV;
+    }
 
 	version = *(enum dsi_ctrl_version *)id->data;
 
 	item = devm_kzalloc(&pdev->dev, sizeof(*item), GFP_KERNEL);
-	if (!item)
+	if (!item){
+        printk("%s:%d, ACHEUL, error, no mem", __FUNCTION__, __LINE__);
 		return -ENOMEM;
+    }
 
 	dsi_ctrl = devm_kzalloc(&pdev->dev, sizeof(*dsi_ctrl), GFP_KERNEL);
-	if (!dsi_ctrl)
+	if (!dsi_ctrl){
+        printk("%s:%d, ACHEUL, error, no mem", __FUNCTION__, __LINE__);
 		return -ENOMEM;
+    }
 
 	dsi_ctrl->version = version;
 	dsi_ctrl->irq_info.irq_num = -1;
 	dsi_ctrl->irq_info.irq_stat_mask = 0x0;
 
+    of_property_read_string(pdev->dev.of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
+    of_property_read_string(pdev->dev.of_node, "label", &compatible);
+    printk("%s:%d, ACHEUL, label: %s", __FUNCTION__, __LINE__, label);
+
 	INIT_WORK(&dsi_ctrl->dma_cmd_wait, dsi_ctrl_dma_cmd_wait_for_done);
 	atomic_set(&dsi_ctrl->dma_irq_trig, 0);
 
@@ -1975,10 +2012,13 @@
 		goto fail_supplies;
 	}
 
+    printk("%s:%d, ACHEUL, calling dsi_ctrl_axi_bus_client_init", __FUNCTION__, __LINE__);
 	rc = dsi_ctrl_axi_bus_client_init(pdev, dsi_ctrl);
-	if (rc)
-		DSI_CTRL_DEBUG(dsi_ctrl, "failed to init axi bus client, rc = %d\n",
-				rc);
+	if (rc){
+        printk("%s:%d, ACHEUL, error: %d", __FUNCTION__, __LINE__, rc);
+		DSI_CTRL_DEBUG(dsi_ctrl, "failed to init axi bus client, rc = %d\n", rc);
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+    }
 
 	if (dsi_ctrl->hw.ops.map_mdp_regs)
 		dsi_ctrl->hw.ops.map_mdp_regs(pdev, &dsi_ctrl->hw);
@@ -1996,6 +2036,7 @@
 	platform_set_drvdata(pdev, dsi_ctrl);
 	DSI_CTRL_INFO(dsi_ctrl, "Probe successful\n");
 
+    printk("%s:%d, ACHEUL, out, OK", __FUNCTION__, __LINE__);
 	return 0;
 
 fail_supplies:
@@ -2003,6 +2044,7 @@
 fail_clks:
 	(void)dsi_ctrl_clocks_deinit(dsi_ctrl);
 fail:
+    printk("%s:%d, ACHEUL, out, error: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -3464,6 +3506,8 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!dsi_ctrl || (state >= DSI_CTRL_ENGINE_MAX)) {
 		DSI_CTRL_ERR(dsi_ctrl, "Invalid params\n");
 		return -EINVAL;
@@ -3482,6 +3526,7 @@
 	dsi_ctrl_update_state(dsi_ctrl, DSI_CTRL_OP_HOST_ENGINE, state);
 error:
 	mutex_unlock(&dsi_ctrl->ctrl_lock);
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_hw_1_4.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_hw_2_0.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_hw_2_2.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_hw_cmn.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_hw.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_ctrl_reg.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_defs.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_display.c kernel/msm-4.19/techpack/display/msm/dsi/dsi_display.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_display.c	2024-05-28 21:11:35.867595196 -0400
+++ kernel/msm-4.19/techpack/display/msm/dsi/dsi_display.c	2024-05-29 22:10:12.773804421 -0400
@@ -34,6 +34,7 @@
 
 #define DSI_CLOCK_BITRATE_RADIX 10
 #define MAX_TE_SOURCE_ID  2
+#define CONFIG_DEBUG_FS 1
 
 static char dsi_display_primary[MAX_CMDLINE_PARAM_LEN];
 static char dsi_display_secondary[MAX_CMDLINE_PARAM_LEN];
@@ -53,6 +54,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return;
 
@@ -72,19 +74,20 @@
 	enum dsi_clk_gate_type clk_selection;
 	enum dsi_clk_gate_type const default_clk_select = PIXEL_CLK | DSI_PHY;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (display->panel->host_config.force_hs_clk_lane) {
-		DSI_DEBUG("no dsi clock gating for continuous clock mode\n");
+		printk("no dsi clock gating for continuous clock mode\n");
 		return 0;
 	}
 
 	mctrl = &display->ctrl[display->clk_master_idx];
 	if (!mctrl) {
-		DSI_ERR("Invalid controller\n");
+		printk("Invalid controller\n");
 		return -EINVAL;
 	}
 
@@ -100,14 +103,14 @@
 		clk_selection = 0;
 	}
 
-	DSI_DEBUG("%s clock gating Byte:%s Pixel:%s PHY:%s\n",
+	printk("%s clock gating Byte:%s Pixel:%s PHY:%s\n",
 		enable ? "Enabling" : "Disabling",
 		clk_selection & BYTE_CLK ? "yes" : "no",
 		clk_selection & PIXEL_CLK ? "yes" : "no",
 		clk_selection & DSI_PHY ? "yes" : "no");
 	rc = dsi_ctrl_config_clk_gating(mctrl->ctrl, enable, clk_selection);
 	if (rc) {
-		DSI_ERR("[%s] failed to %s clk gating for clocks %d, rc=%d\n",
+		printk("[%s] failed to %s clk gating for clocks %d, rc=%d\n",
 				display->name, enable ? "enable" : "disable",
 				clk_selection, rc);
 		return rc;
@@ -125,7 +128,7 @@
 		rc = dsi_ctrl_config_clk_gating(ctrl->ctrl, enable,
 				clk_selection);
 		if (rc) {
-			DSI_ERR("[%s] failed to %s clk gating for clocks %d, rc=%d\n",
+			printk("[%s] failed to %s clk gating for clocks %d, rc=%d\n",
 				display->name, enable ? "enable" : "disable",
 				clk_selection, rc);
 			return rc;
@@ -141,6 +144,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return;
 
@@ -157,6 +161,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return;
 
@@ -174,6 +179,7 @@
 {
 	int l, t, r, b;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!r1 || !r2 || !result)
 		return;
 
@@ -201,6 +207,7 @@
 	u64 bl_temp;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (dsi_display == NULL || dsi_display->panel == NULL)
 		return -EINVAL;
 
@@ -221,24 +228,24 @@
 	bl_scale_sv = panel->bl_config.bl_scale_sv;
 	bl_temp = (u32)bl_temp * bl_scale_sv / MAX_SV_BL_SCALE_LEVEL;
 
-	DSI_DEBUG("bl_scale = %u, bl_scale_sv = %u, bl_lvl = %u\n",
+	printk("bl_scale = %u, bl_scale_sv = %u, bl_lvl = %u\n",
 		bl_scale, bl_scale_sv, (u32)bl_temp);
 	rc = dsi_display_clk_ctrl(dsi_display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI core clocks, rc=%d\n",
 		       dsi_display->name, rc);
 		goto error;
 	}
 
 	rc = dsi_panel_set_backlight(panel, (u32)bl_temp);
 	if (rc)
-		DSI_ERR("unable to set backlight\n");
+		printk("unable to set backlight\n");
 
 	rc = dsi_display_clk_ctrl(dsi_display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_OFF);
 	if (rc) {
-		DSI_ERR("[%s] failed to disable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to disable DSI core clocks, rc=%d\n",
 		       dsi_display->name, rc);
 		goto error;
 	}
@@ -254,6 +261,7 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 	mutex_lock(&m_ctrl->ctrl->ctrl_lock);
 
@@ -264,7 +272,7 @@
 
 	rc = dsi_ctrl_set_cmd_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+		printk("[%s] failed to enable cmd engine, rc=%d\n",
 		       display->name, rc);
 		goto done;
 	}
@@ -277,7 +285,7 @@
 		rc = dsi_ctrl_set_cmd_engine_state(ctrl->ctrl,
 						   DSI_CTRL_ENGINE_ON);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+			printk("[%s] failed to enable cmd engine, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_master;
 		}
@@ -298,11 +306,12 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 	mutex_lock(&m_ctrl->ctrl->ctrl_lock);
 
 	if (display->cmd_engine_refcount == 0) {
-		DSI_ERR("[%s] Invalid refcount\n", display->name);
+		printk("[%s] Invalid refcount\n", display->name);
 		goto done;
 	} else if (display->cmd_engine_refcount > 1) {
 		display->cmd_engine_refcount--;
@@ -317,13 +326,13 @@
 		rc = dsi_ctrl_set_cmd_engine_state(ctrl->ctrl,
 						   DSI_CTRL_ENGINE_OFF);
 		if (rc)
-			DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+			printk("[%s] failed to enable cmd engine, rc=%d\n",
 			       display->name, rc);
 	}
 
 	rc = dsi_ctrl_set_cmd_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_OFF);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+		printk("[%s] failed to enable cmd engine, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -341,8 +350,9 @@
 	struct dsi_display_ctrl *display_ctrl;
 	int rc, cnt;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!cb_data) {
-		DSI_ERR("aspace cb called with invalid cb_data\n");
+		printk("aspace cb called with invalid cb_data\n");
 		return;
 	}
 	display = (struct dsi_display *)cb_data;
@@ -365,7 +375,7 @@
 		rc = msm_gem_get_iova(display->tx_cmd_buf,
 				display->aspace, &(display->cmd_buffer_iova));
 		if (rc) {
-			DSI_ERR("failed to get the iova rc %d\n", rc);
+			printk("failed to get the iova rc %d\n", rc);
 			goto end;
 		}
 
@@ -373,7 +383,7 @@
 			(void *) msm_gem_get_vaddr(display->tx_cmd_buf);
 
 		if (IS_ERR_OR_NULL(display->vaddr)) {
-			DSI_ERR("failed to get va rc %d\n", rc);
+			printk("failed to get va rc %d\n", rc);
 			goto end;
 		}
 	}
@@ -412,7 +422,7 @@
 					bool enable)
 {
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return;
 	}
 
@@ -435,13 +445,13 @@
 
 	pdev = display->pdev;
 	if (!pdev) {
-		DSI_ERR("invalid platform device\n");
+		printk("invalid platform device\n");
 		return;
 	}
 
 	dev = &pdev->dev;
 	if (!dev) {
-		DSI_ERR("invalid device\n");
+		printk("invalid device\n");
 		return;
 	}
 
@@ -460,7 +470,7 @@
 			      IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 			      "TE_GPIO", display);
 	if (rc) {
-		DSI_ERR("TE request_irq failed for ESD rc:%d\n", rc);
+		printk("TE request_irq failed for ESD rc:%d\n", rc);
 		irq_clear_status_flags(te_irq, IRQ_DISABLE_UNLAZY);
 		goto error;
 	}
@@ -483,12 +493,13 @@
 	int rc = 0, cnt = 0;
 	struct dsi_display_ctrl *display_ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display->tx_cmd_buf = msm_gem_new(display->drm_dev,
 			SZ_4K,
 			MSM_BO_UNCACHED);
 
 	if ((display->tx_cmd_buf) == NULL) {
-		DSI_ERR("Failed to allocate cmd tx buf memory\n");
+		printk("Failed to allocate cmd tx buf memory\n");
 		rc = -ENOMEM;
 		goto error;
 	}
@@ -498,7 +509,7 @@
 	display->aspace = msm_gem_smmu_address_space_get(
 			display->drm_dev, MSM_SMMU_DOMAIN_UNSECURE);
 	if (!display->aspace) {
-		DSI_ERR("failed to get aspace\n");
+		printk("failed to get aspace\n");
 		rc = -EINVAL;
 		goto free_gem;
 	}
@@ -506,21 +517,21 @@
 	rc = msm_gem_address_space_register_cb(display->aspace,
 			dsi_display_aspace_cb_locked, (void *)display);
 	if (rc) {
-		DSI_ERR("failed to register callback %d\n", rc);
+		printk("failed to register callback %d\n", rc);
 		goto free_gem;
 	}
 
 	rc = msm_gem_get_iova(display->tx_cmd_buf, display->aspace,
 				&(display->cmd_buffer_iova));
 	if (rc) {
-		DSI_ERR("failed to get the iova rc %d\n", rc);
+		printk("failed to get the iova rc %d\n", rc);
 		goto free_aspace_cb;
 	}
 
 	display->vaddr =
 		(void *) msm_gem_get_vaddr(display->tx_cmd_buf);
 	if (IS_ERR_OR_NULL(display->vaddr)) {
-		DSI_ERR("failed to get va rc %d\n", rc);
+		printk("failed to get va rc %d\n", rc);
 		rc = -EINVAL;
 		goto put_iova;
 	}
@@ -556,6 +567,7 @@
 	int group = 0, count = 0;
 	struct drm_panel_esd_config *config;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!panel)
 		return false;
 
@@ -595,15 +607,16 @@
 	int rc = 0;
 	u32 val = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	pdev = display->pdev;
 	if (!pdev) {
-		DSI_ERR("Invalid platform device\n");
+		printk("Invalid platform device\n");
 		return;
 	}
 
 	dev = &pdev->dev;
 	if (!dev) {
-		DSI_ERR("Invalid platform device\n");
+		printk("Invalid platform device\n");
 		return;
 	}
 
@@ -618,7 +631,7 @@
 			"qcom,panel-te-source", &val);
 
 	if (rc || (val  > MAX_TE_SOURCE_ID)) {
-		DSI_ERR("invalid vsync source selection\n");
+		printk("invalid vsync source selection\n");
 		val = 0;
 	}
 
@@ -633,6 +646,7 @@
 	struct dsi_cmd_desc *cmds;
 	u32 flags = 0;
 
+    printk("%s:%d, ACHEUL, panel name: %s", __FUNCTION__, __LINE__, panel->name);
 	if (!panel || !ctrl || !ctrl->ctrl)
 		return -EINVAL;
 
@@ -663,7 +677,7 @@
 		cmds[i].msg.rx_len = config->status_cmds_rlen[i];
 		rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &cmds[i].msg, &flags);
 		if (rc <= 0) {
-			DSI_ERR("rx cmd transfer failed rc=%d\n", rc);
+			printk("rx cmd transfer failed rc=%d\n", rc);
 			return rc;
 		}
 
@@ -672,6 +686,7 @@
 		start += lenp[i];
 	}
 
+    printk("%s:%d, ACHEUL, panel name: %s, rc: %d", __FUNCTION__, __LINE__, panel->name, rc);
 	return rc;
 }
 
@@ -680,6 +695,7 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL, panel name: %s", __FUNCTION__, __LINE__, panel->name);
 	rc = dsi_display_read_status(ctrl, panel);
 	if (rc <= 0) {
 		goto exit;
@@ -696,6 +712,7 @@
 	}
 
 exit:
+    printk("%s:%d, ACHEUL, panel name: %s, rc: %d", __FUNCTION__, __LINE__, panel->name, rc);
 	return rc;
 }
 
@@ -704,27 +721,28 @@
 	int rc = 0, i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
-	DSI_DEBUG(" ++\n");
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	printk(" ++\n");
 
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 
 	if (display->tx_cmd_buf == NULL) {
 		rc = dsi_host_alloc_cmd_tx_buffer(display);
 		if (rc) {
-			DSI_ERR("failed to allocate cmd tx buffer memory\n");
+			printk("failed to allocate cmd tx buffer memory\n");
 			goto done;
 		}
 	}
 
 	rc = dsi_display_cmd_engine_enable(display);
 	if (rc) {
-		DSI_ERR("cmd engine enable failed\n");
+		printk("cmd engine enable failed\n");
 		return -EPERM;
 	}
 
 	rc = dsi_display_validate_status(m_ctrl, display->panel);
 	if (rc <= 0) {
-		DSI_ERR("[%s] read status failed on master,rc=%d\n",
+		printk("[%s] read status failed on master,rc=%d\n",
 		       display->name, rc);
 		goto exit;
 	}
@@ -739,14 +757,16 @@
 
 		rc = dsi_display_validate_status(ctrl, display->panel);
 		if (rc <= 0) {
-			DSI_ERR("[%s] read status failed on slave,rc=%d\n",
+			printk("[%s] read status failed on slave,rc=%d\n",
 			       display->name, rc);
 			goto exit;
 		}
 	}
 exit:
+    printk("%s:%d, ACHEUL, error, disabling command engine", __FUNCTION__, __LINE__);
 	dsi_display_cmd_engine_disable(display);
 done:
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -754,7 +774,8 @@
 {
 	int rc = 0;
 
-	DSI_DEBUG(" ++\n");
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	printk(" ++\n");
 	/* TODO: trigger SW BTA and wait for acknowledgment */
 
 	return rc;
@@ -765,12 +786,13 @@
 	int rc = 1;
 	int const esd_te_timeout = msecs_to_jiffies(3*20);
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	dsi_display_change_te_irq_status(display, true);
 
 	reinit_completion(&display->esd_te_gate);
 	if (!wait_for_completion_timeout(&display->esd_te_gate,
 				esd_te_timeout)) {
-		DSI_ERR("TE check failed\n");
+		printk("TE check failed\n");
 		rc = -EINVAL;
 	}
 
@@ -788,15 +810,18 @@
 	int rc = 0x1, ret;
 	u32 mask;
 
-	if (!dsi_display || !dsi_display->panel)
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	if (!dsi_display || !dsi_display->panel){
+        printk("%s:%d, ACHEUL, failed", __FUNCTION__, __LINE__);
 		return -EINVAL;
+    }
 
 	panel = dsi_display->panel;
 
 	dsi_panel_acquire_panel_lock(panel);
 
 	if (!panel->panel_initialized) {
-		DSI_DEBUG("Panel not initialized\n");
+		printk("Panel not initialized\n");
 		goto release_panel_lock;
 	}
 
@@ -863,6 +888,7 @@
 	dsi_panel_release_panel_lock(panel);
 	SDE_EVT32(SDE_EVTLOG_FUNC_EXIT, rc);
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -871,6 +897,7 @@
 {
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	memset(cmd, 0x00, sizeof(*cmd));
 	cmd->msg.type = cmd_buf[0];
 	cmd->last_command = (cmd_buf[1] == 1);
@@ -881,7 +908,7 @@
 	cmd->msg.tx_len = ((cmd_buf[5] << 8) | (cmd_buf[6]));
 
 	if (cmd->msg.tx_len > payload_len) {
-		DSI_ERR("Incorrect payload length tx_len %zu, payload_len %d\n",
+		printk("Incorrect payload length tx_len %zu, payload_len %d\n",
 		       cmd->msg.tx_len, payload_len);
 		return -EINVAL;
 	}
@@ -902,12 +929,15 @@
 	struct dsi_display_ctrl *ctrl;
 	int i, rc = -EINVAL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, dsi_display) {
 		ctrl = &dsi_display->ctrl[i];
 		rc = dsi_ctrl_get_host_engine_init_state(ctrl->ctrl, state);
 		if (rc)
 			break;
 	}
+
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -921,17 +951,18 @@
 	int rc = 0;
 	bool state = false;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!dsi_display || !cmd_buf) {
-		DSI_ERR("[DSI] invalid params\n");
+		printk("[DSI] invalid params\n");
 		return -EINVAL;
 	}
 
-	DSI_DEBUG("[DSI] Display command transfer\n");
+	printk("[DSI] Display command transfer\n");
 
 	rc = dsi_display_cmd_prepare(cmd_buf, cmd_buf_len,
 			&cmd, cmd_payload, MAX_CMD_PAYLOAD_SIZE);
 	if (rc) {
-		DSI_ERR("[DSI] command prepare failed. rc %d\n", rc);
+		printk("[DSI] command prepare failed. rc %d\n", rc);
 		return rc;
 	}
 
@@ -949,7 +980,7 @@
 		goto end;
 	}
 	if (rc || !state) {
-		DSI_ERR("[DSI] Invalid host state %d rc %d\n",
+		printk("[DSI] Invalid host state %d rc %d\n",
 				state, rc);
 		rc = -EPERM;
 		goto end;
@@ -959,6 +990,8 @@
 			&cmd.msg);
 end:
 	mutex_unlock(&dsi_display->display_lock);
+
+    printk("%s:%d, ACHEUL: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -968,6 +1001,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->panel->host_config.force_hs_clk_lane)
 		return;
 
@@ -996,6 +1030,7 @@
 	int rc = 0;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -EINVAL;
 
@@ -1005,7 +1040,7 @@
 		ctrl = &dsi_display->ctrl[i];
 		rc = dsi_ctrl_soft_reset(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("[%s] failed to soft reset host_%d, rc=%d\n",
+			printk("[%s] failed to soft reset host_%d, rc=%d\n",
 					dsi_display->name, i, rc);
 			break;
 		}
@@ -1021,8 +1056,9 @@
 	enum dsi_pixel_format format = DSI_PIXEL_FORMAT_MAX;
 	struct dsi_display *dsi_display = (struct dsi_display *)display;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!dsi_display || !dsi_display->panel) {
-		DSI_ERR("Invalid params(s) dsi_display %pK, panel %pK\n",
+		printk("Invalid params(s) dsi_display %pK, panel %pK\n",
 			dsi_display,
 			((dsi_display) ? dsi_display->panel : NULL));
 		return format;
@@ -1036,6 +1072,7 @@
 {
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		dsi_ctrl_setup_misr(display->ctrl[i].ctrl,
 				display->misr_enable,
@@ -1049,8 +1086,9 @@
 	struct dsi_display *display = disp;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->panel) {
-		DSI_ERR("invalid display/panel\n");
+		printk("invalid display/panel\n");
 		return -EINVAL;
 	}
 
@@ -1072,7 +1110,7 @@
 	}
 
 	SDE_EVT32(display->panel->power_mode, power_mode, rc);
-	DSI_DEBUG("Power mode transition from %d to %d %s",
+	printk("Power mode transition from %d to %d %s",
 			display->panel->power_mode, power_mode,
 			rc ? "failed" : "successful");
 	if (!rc)
@@ -1086,8 +1124,9 @@
 {
 	u32 status_mode = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display->panel) {
-		DSI_ERR("Invalid panel data\n");
+		printk("Invalid panel data\n");
 		return false;
 	}
 
@@ -1109,6 +1148,7 @@
 	u32 len = 0;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1164,6 +1204,7 @@
 	size_t len;
 	u32 enable, frame_count;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1195,7 +1236,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto unlock;
 	}
@@ -1205,7 +1246,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_OFF);
 	if (rc) {
-		DSI_ERR("[%s] failed to disable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to disable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto unlock;
 	}
@@ -1232,6 +1273,7 @@
 	u32 misr;
 	size_t max_len = min_t(size_t, user_len, MISR_BUFF_SIZE);
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1246,7 +1288,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -1265,7 +1307,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_OFF);
 	if (rc) {
-		DSI_ERR("[%s] failed to disable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to disable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -1295,6 +1337,7 @@
 	u32 esd_trigger;
 	size_t len;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1312,7 +1355,7 @@
 		return user_len;
 
 	if (!esd_config->esd_enabled) {
-		DSI_ERR("ESD feature is not enabled\n");
+		printk("ESD feature is not enabled\n");
 		return -EINVAL;
 	}
 
@@ -1344,7 +1387,7 @@
 		DSI_INFO("ESD attack triggered by user\n");
 		rc = dsi_panel_trigger_esd_attack(display->panel);
 		if (rc) {
-			DSI_ERR("Failed to trigger ESD attack\n");
+			printk("Failed to trigger ESD attack\n");
 			goto error;
 		}
 	}
@@ -1366,6 +1409,7 @@
 	int rc = 0;
 	size_t len;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1390,7 +1434,7 @@
 
 	esd_config = &display->panel->esd_config;
 	if (!esd_config) {
-		DSI_ERR("Invalid panel esd config\n");
+		printk("Invalid panel esd config\n");
 		rc = -EINVAL;
 		goto error;
 	}
@@ -1412,7 +1456,7 @@
 		DSI_INFO("ESD check is switched to reg read by user\n");
 		rc = dsi_panel_parse_esd_reg_read_configs(display->panel);
 		if (rc) {
-			DSI_ERR("failed to alter esd check mode,rc=%d\n",
+			printk("failed to alter esd check mode,rc=%d\n",
 						rc);
 			rc = user_len;
 			goto error;
@@ -1445,6 +1489,7 @@
 	int rc = 0;
 	size_t len;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display)
 		return -ENODEV;
 
@@ -1452,7 +1497,7 @@
 		return 0;
 
 	if (!display->panel) {
-		DSI_ERR("invalid panel data\n");
+		printk("invalid panel data\n");
 		return -EINVAL;
 	}
 
@@ -1462,7 +1507,7 @@
 
 	esd_config = &display->panel->esd_config;
 	if (!esd_config) {
-		DSI_ERR("Invalid panel esd config\n");
+		printk("Invalid panel esd config\n");
 		rc = -EINVAL;
 		goto error;
 	}
@@ -1538,10 +1583,11 @@
 	char name[MAX_NAME_SIZE];
 	int i;
 
+    printk("%s:%d, ACHEUL, display name: %s", __FUNCTION__, __LINE__);
 	dir = debugfs_create_dir(display->name, NULL);
 	if (IS_ERR_OR_NULL(dir)) {
 		rc = PTR_ERR(dir);
-		DSI_ERR("[%s] debugfs create dir failed, rc = %d\n",
+		printk("[%s] debugfs create dir failed, rc = %d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -1553,7 +1599,7 @@
 					&dump_info_fops);
 	if (IS_ERR_OR_NULL(dump_file)) {
 		rc = PTR_ERR(dump_file);
-		DSI_ERR("[%s] debugfs create dump info file failed, rc=%d\n",
+		printk("[%s] debugfs create dump info file failed, rc=%d\n",
 		       display->name, rc);
 		goto error_remove_dir;
 	}
@@ -1565,7 +1611,7 @@
 					&esd_trigger_fops);
 	if (IS_ERR_OR_NULL(dump_file)) {
 		rc = PTR_ERR(dump_file);
-		DSI_ERR("[%s] debugfs for esd trigger file failed, rc=%d\n",
+		printk("[%s] debugfs for esd trigger file failed, rc=%d\n",
 		       display->name, rc);
 		goto error_remove_dir;
 	}
@@ -1577,7 +1623,7 @@
 					&esd_check_mode_fops);
 	if (IS_ERR_OR_NULL(dump_file)) {
 		rc = PTR_ERR(dump_file);
-		DSI_ERR("[%s] debugfs for esd check mode failed, rc=%d\n",
+		printk("[%s] debugfs for esd check mode failed, rc=%d\n",
 		       display->name, rc);
 		goto error_remove_dir;
 	}
@@ -1589,7 +1635,7 @@
 					&misr_data_fops);
 	if (IS_ERR_OR_NULL(misr_data)) {
 		rc = PTR_ERR(misr_data);
-		DSI_ERR("[%s] debugfs create misr datafile failed, rc=%d\n",
+		printk("[%s] debugfs create misr datafile failed, rc=%d\n",
 		       display->name, rc);
 		goto error_remove_dir;
 	}
@@ -1606,7 +1652,7 @@
 				&phy->allow_phy_power_off);
 		if (IS_ERR_OR_NULL(dump_file)) {
 			rc = PTR_ERR(dump_file);
-			DSI_ERR("[%s] debugfs create %s failed, rc=%d\n",
+			printk("[%s] debugfs create %s failed, rc=%d\n",
 			       display->name, name, rc);
 			goto error_remove_dir;
 		}
@@ -1617,7 +1663,7 @@
 				&phy->regulator_min_datarate_bps);
 		if (IS_ERR_OR_NULL(dump_file)) {
 			rc = PTR_ERR(dump_file);
-			DSI_ERR("[%s] debugfs create %s failed, rc=%d\n",
+			printk("[%s] debugfs create %s failed, rc=%d\n",
 			       display->name, name, rc);
 			goto error_remove_dir;
 		}
@@ -1625,28 +1671,28 @@
 
 	if (!debugfs_create_bool("ulps_feature_enable", 0600, dir,
 			&display->panel->ulps_feature_enabled)) {
-		DSI_ERR("[%s] debugfs create ulps feature enable file failed\n",
+		printk("[%s] debugfs create ulps feature enable file failed\n",
 		       display->name);
 		goto error_remove_dir;
 	}
 
 	if (!debugfs_create_bool("ulps_suspend_feature_enable", 0600, dir,
 			&display->panel->ulps_suspend_enabled)) {
-		DSI_ERR("[%s] debugfs create ulps-suspend feature enable file failed\n",
+		printk("[%s] debugfs create ulps-suspend feature enable file failed\n",
 		       display->name);
 		goto error_remove_dir;
 	}
 
 	if (!debugfs_create_bool("ulps_status", 0400, dir,
 			&display->ulps_enabled)) {
-		DSI_ERR("[%s] debugfs create ulps status file failed\n",
+		printk("[%s] debugfs create ulps status file failed\n",
 		       display->name);
 		goto error_remove_dir;
 	}
 
 	if (!debugfs_create_u32("clk_gating_config", 0600, dir,
 			&display->clk_gating_config)) {
-		DSI_ERR("[%s] debugfs create clk gating config failed\n",
+		printk("[%s] debugfs create clk gating config failed\n",
 		       display->name);
 		goto error_remove_dir;
 	}
@@ -1707,30 +1753,30 @@
 {
 	/* TODO: make checks based on cont. splash */
 
-	DSI_DEBUG("checking ulps req validity\n");
+	printk("checking ulps req validity\n");
 
 	if (atomic_read(&display->panel->esd_recovery_pending)) {
-		DSI_DEBUG("%s: ESD recovery sequence underway\n", __func__);
+		printk("%s: ESD recovery sequence underway\n", __func__);
 		return false;
 	}
 
 	if (!dsi_panel_ulps_feature_enabled(display->panel) &&
 			!display->panel->ulps_suspend_enabled) {
-		DSI_DEBUG("%s: ULPS feature is not enabled\n", __func__);
+		printk("%s: ULPS feature is not enabled\n", __func__);
 		return false;
 	}
 
 	if (!dsi_panel_initialized(display->panel) &&
 			!display->panel->ulps_suspend_enabled) {
-		DSI_DEBUG("%s: panel not yet initialized\n", __func__);
+		printk("%s: panel not yet initialized\n", __func__);
 		return false;
 	}
 
 	if (enable && display->ulps_enabled) {
-		DSI_DEBUG("ULPS already enabled\n");
+		printk("ULPS already enabled\n");
 		return false;
 	} else if (!enable && !display->ulps_enabled) {
-		DSI_DEBUG("ULPS already disabled\n");
+		printk("ULPS already disabled\n");
 		return false;
 	}
 
@@ -1762,13 +1808,14 @@
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!dsi_display_is_ulps_req_valid(display, enable)) {
-		DSI_DEBUG("%s: skipping ULPS config, enable=%d\n",
+		printk("%s: skipping ULPS config, enable=%d\n",
 			__func__, enable);
 		return 0;
 	}
@@ -1787,7 +1834,7 @@
 			display->clamp_enabled);
 
 	if (rc == DSI_PHY_ULPS_ERROR) {
-		DSI_ERR("Ulps PHY state change(%d) failed\n", enable);
+		printk("Ulps PHY state change(%d) failed\n", enable);
 		return -EINVAL;
 	}
 
@@ -1800,7 +1847,7 @@
 			rc = dsi_phy_set_ulps(ctrl->phy, &display->config,
 					enable, display->clamp_enabled);
 			if (rc == DSI_PHY_ULPS_ERROR) {
-				DSI_ERR("Ulps PHY state change(%d) failed\n",
+				printk("Ulps PHY state change(%d) failed\n",
 						enable);
 				return -EINVAL;
 			}
@@ -1810,7 +1857,7 @@
 	else if (rc == DSI_PHY_ULPS_NOT_HANDLED) {
 		rc = dsi_ctrl_set_ulps(m_ctrl->ctrl, enable);
 		if (rc) {
-			DSI_ERR("Ulps controller state change(%d) failed\n",
+			printk("Ulps controller state change(%d) failed\n",
 					enable);
 			return rc;
 		}
@@ -1821,7 +1868,7 @@
 
 			rc = dsi_ctrl_set_ulps(ctrl->ctrl, enable);
 			if (rc) {
-				DSI_ERR("Ulps controller state change(%d) failed\n",
+				printk("Ulps controller state change(%d) failed\n",
 						enable);
 				return rc;
 			}
@@ -1847,8 +1894,9 @@
 	bool ulps_enabled = false;
 
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -1861,13 +1909,13 @@
 	 */
 	rc = dsi_ctrl_set_clamp_state(m_ctrl->ctrl, enable, ulps_enabled);
 	if (rc) {
-		DSI_ERR("DSI ctrl clamp state change(%d) failed\n", enable);
+		printk("DSI ctrl clamp state change(%d) failed\n", enable);
 		return rc;
 	}
 
 	rc = dsi_phy_set_clamp_state(m_ctrl->phy, enable);
 	if (rc) {
-		DSI_ERR("DSI phy clamp state change(%d) failed\n", enable);
+		printk("DSI phy clamp state change(%d) failed\n", enable);
 		return rc;
 	}
 
@@ -1878,18 +1926,18 @@
 
 		rc = dsi_ctrl_set_clamp_state(ctrl->ctrl, enable, ulps_enabled);
 		if (rc) {
-			DSI_ERR("DSI Clamp state change(%d) failed\n", enable);
+			printk("DSI Clamp state change(%d) failed\n", enable);
 			return rc;
 		}
 
 		rc = dsi_phy_set_clamp_state(ctrl->phy, enable);
 		if (rc) {
-			DSI_ERR("DSI phy clamp state change(%d) failed\n",
+			printk("DSI phy clamp state change(%d) failed\n",
 				enable);
 			return rc;
 		}
 
-		DSI_DEBUG("Clamps %s for ctrl%d\n",
+		printk("Clamps %s for ctrl%d\n",
 			enable ? "enabled" : "disabled", i);
 	}
 
@@ -1909,16 +1957,17 @@
 	int i = 0;
 	struct dsi_display_ctrl *ctrl, *m_ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 	rc = dsi_ctrl_setup(m_ctrl->ctrl);
 	if (rc) {
-		DSI_ERR("DSI controller setup failed\n");
+		printk("DSI controller setup failed\n");
 		return rc;
 	}
 
@@ -1929,7 +1978,7 @@
 
 		rc = dsi_ctrl_setup(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("DSI controller setup failed\n");
+			printk("DSI controller setup failed\n");
 			return rc;
 		}
 	}
@@ -1952,9 +2001,10 @@
 	int i = 0;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -1966,7 +2016,7 @@
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 	rc = dsi_phy_idle_ctrl(m_ctrl->phy, true);
 	if (rc) {
-		DSI_ERR("DSI controller setup failed\n");
+		printk("DSI controller setup failed\n");
 		return rc;
 	}
 
@@ -1977,7 +2027,7 @@
 
 		rc = dsi_phy_idle_ctrl(ctrl->phy, true);
 		if (rc) {
-			DSI_ERR("DSI controller setup failed\n");
+			printk("DSI controller setup failed\n");
 			return rc;
 		}
 	}
@@ -1998,10 +2048,11 @@
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		struct msm_dsi_phy *phy = display->ctrl[i].phy;
 
@@ -2009,7 +2060,7 @@
 			continue;
 
 		if (!phy->allow_phy_power_off) {
-			DSI_DEBUG("phy doesn't support this feature\n");
+			printk("phy doesn't support this feature\n");
 			return 0;
 		}
 	}
@@ -2018,7 +2069,7 @@
 
 	rc = dsi_phy_idle_ctrl(m_ctrl->phy, false);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+		printk("[%s] failed to enable cmd engine, rc=%d\n",
 		       display->name, rc);
 		return rc;
 	}
@@ -2030,7 +2081,7 @@
 
 		rc = dsi_phy_idle_ctrl(ctrl->phy, false);
 		if (rc) {
-			DSI_ERR("DSI controller setup failed\n");
+			printk("DSI controller setup failed\n");
 			return rc;
 		}
 	}
@@ -2046,8 +2097,9 @@
 	uint32_t irq_status_idx = DSI_STATUS_INTERRUPT_COUNT;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("invalid display\n");
+		printk("invalid display\n");
 		return;
 	}
 
@@ -2071,7 +2123,7 @@
 		break;
 	default:
 		/* nothing to do */
-		DSI_DEBUG("[%s] unhandled event %d\n", display->name, event_idx);
+		printk("[%s] unhandled event %d\n", display->name, event_idx);
 		return;
 	}
 
@@ -2100,6 +2152,7 @@
 	struct dsi_display_ctrl *ctrl;
 	enum dsi_engine_state host_state = DSI_CTRL_ENGINE_ON;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Sequence does not matter for split dsi usecases */
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -2109,6 +2162,7 @@
 		dsi_ctrl_update_host_engine_state_for_cont_splash(ctrl->ctrl,
 							host_state);
 	}
+    printk("%s:%d, ACHEUL, out", __FUNCTION__, __LINE__);
 }
 
 static int dsi_display_ctrl_power_on(struct dsi_display *display)
@@ -2117,6 +2171,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Sequence does not matter for split dsi usecases */
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -2126,7 +2181,7 @@
 		rc = dsi_ctrl_set_power_state(ctrl->ctrl,
 					      DSI_CTRL_POWER_VREG_ON);
 		if (rc) {
-			DSI_ERR("[%s] Failed to set power state, rc=%d\n",
+			printk("[%s] Failed to set power state, rc=%d\n",
 			       ctrl->ctrl->name, rc);
 			goto error;
 		}
@@ -2150,6 +2205,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Sequence does not matter for split dsi usecases */
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -2159,7 +2215,7 @@
 		rc = dsi_ctrl_set_power_state(ctrl->ctrl,
 			DSI_CTRL_POWER_VREG_OFF);
 		if (rc) {
-			DSI_ERR("[%s] Failed to power off, rc=%d\n",
+			printk("[%s] Failed to power off, rc=%d\n",
 			       ctrl->ctrl->name, rc);
 			goto error;
 		}
@@ -2177,8 +2233,9 @@
 	unsigned long cmdline_topology = NO_OVERRIDE;
 	unsigned long cmdline_timing = NO_OVERRIDE;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (display_type >= MAX_DSI_ACTIVE_DISPLAY) {
-		DSI_ERR("display_type=%d not supported\n", display_type);
+		printk("display_type=%d not supported\n", display_type);
 		goto end;
 	}
 
@@ -2187,6 +2244,8 @@
 	else
 		boot_str = dsi_display_secondary;
 
+    printk("%s:%d, ACHEUL, boot str: %s", __FUNCTION__, __LINE__, boot_str);
+
 	sw_te = strnstr(boot_str, ":swte", strlen(boot_str));
 	if (sw_te)
 		display->sw_te_using_wd = true;
@@ -2197,7 +2256,7 @@
 
 	if (kstrtol(str + strlen(":config"), INT_BASE_10,
 				(unsigned long *)&cmdline_topology)) {
-		DSI_ERR("invalid config index override: %s\n", boot_str);
+		printk("invalid config index override: %s\n", boot_str);
 		goto end;
 	}
 
@@ -2207,12 +2266,12 @@
 
 	if (kstrtol(str + strlen(":timing"), INT_BASE_10,
 				(unsigned long *)&cmdline_timing)) {
-		DSI_ERR("invalid timing index override: %s. resetting both timing and config\n",
+		printk("invalid timing index override: %s. resetting both timing and config\n",
 			boot_str);
 		cmdline_topology = NO_OVERRIDE;
 		goto end;
 	}
-	DSI_DEBUG("successfully parsed command line topology and timing\n");
+	printk("successfully parsed command line topology and timing\n");
 end:
 	display->cmdline_topology = cmdline_topology;
 	display->cmdline_timing = cmdline_timing;
@@ -2229,6 +2288,7 @@
 	char disp_buf[MAX_CMDLINE_PARAM_LEN] = {'\0'};
 	int i, j;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	for (i = 0; i < MAX_DSI_ACTIVE_DISPLAY; i++) {
 		strlcpy(disp_buf, boot_displays[i].boot_param,
 			MAX_CMDLINE_PARAM_LEN);
@@ -2237,7 +2297,7 @@
 
 		/* Use ':' as a delimiter to retrieve the display name */
 		if (!pos) {
-			DSI_DEBUG("display name[%s]is not valid\n", disp_buf);
+			printk("display name[%s]is not valid\n", disp_buf);
 			continue;
 		}
 
@@ -2258,6 +2318,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Sequence does not matter for split dsi usecases */
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -2266,7 +2327,7 @@
 
 		rc = dsi_phy_set_power_state(ctrl->phy, true);
 		if (rc) {
-			DSI_ERR("[%s] Failed to set power state, rc=%d\n",
+			printk("[%s] Failed to set power state, rc=%d\n",
 			       ctrl->phy->name, rc);
 			goto error;
 		}
@@ -2289,6 +2350,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Sequence does not matter for split dsi usecases */
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -2297,7 +2359,7 @@
 
 		rc = dsi_phy_set_power_state(ctrl->phy, false);
 		if (rc) {
-			DSI_ERR("[%s] Failed to power off, rc=%d\n",
+			printk("[%s] Failed to power off, rc=%d\n",
 			       ctrl->ctrl->name, rc);
 			goto error;
 		}
@@ -2312,6 +2374,7 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/*
 	 * For CPHY mode, the parent of mux_clks need to be set
 	 * to Cphy_clks to have correct dividers for byte and
@@ -2321,7 +2384,7 @@
 		rc = dsi_clk_update_parent(&display->clock_info.cphy_clks,
 			      &display->clock_info.mux_clks);
 		if (rc) {
-			DSI_ERR("failed update mux parent to shadow\n");
+			printk("failed update mux parent to shadow\n");
 			return rc;
 		}
 	}
@@ -2336,7 +2399,7 @@
 	rc = dsi_ctrl_set_clock_source(m_ctrl->ctrl,
 				&display->clock_info.mux_clks);
 	if (rc) {
-		DSI_ERR("[%s] failed to set source clocks for master, rc=%d\n",
+		printk("[%s] failed to set source clocks for master, rc=%d\n",
 			   display->name, rc);
 		return rc;
 	}
@@ -2350,7 +2413,7 @@
 		rc = dsi_ctrl_set_clock_source(ctrl->ctrl,
 					&display->clock_info.mux_clks);
 		if (rc) {
-			DSI_ERR("[%s] failed to set source clocks, rc=%d\n",
+			printk("[%s] failed to set source clocks, rc=%d\n",
 				   display->name, rc);
 			return rc;
 		}
@@ -2365,11 +2428,12 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_phy_reset_config(ctrl->ctrl, enable);
 		if (rc) {
-			DSI_ERR("[%s] failed to %s phy reset, rc=%d\n",
+			printk("[%s] failed to %s phy reset, rc=%d\n",
 			       display->name, enable ? "mask" : "unmask", rc);
 			return rc;
 		}
@@ -2385,6 +2449,7 @@
 	if (!display)
 		return;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		dsi_phy_toggle_resync_fifo(ctrl->phy);
@@ -2411,11 +2476,12 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_host_timing_update(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("[%s] failed to update host_%d, rc=%d\n",
+			printk("[%s] failed to update host_%d, rc=%d\n",
 				   display->name, i, rc);
 			goto error_host_deinit;
 		}
@@ -2437,6 +2503,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* when ULPS suspend feature is enabled, we will keep the lanes in
 	 * ULPS during suspend state and clamp DSI phy. Hence while resuming
 	 * we will programe DSI controller as part of core clock enable.
@@ -2450,7 +2517,7 @@
 			rc = dsi_ctrl_host_init(ctrl->ctrl,
 					display->is_cont_splash_enabled);
 			if (rc) {
-				DSI_ERR("[%s] failed to init host_%d, rc=%d\n",
+				printk("[%s] failed to init host_%d, rc=%d\n",
 				       display->name, i, rc);
 				goto error_host_deinit;
 			}
@@ -2462,7 +2529,7 @@
 							DSI_CTRL_OP_HOST_INIT,
 							true);
 			if (rc)
-				DSI_DEBUG("host init update failed rc=%d\n",
+				printk("host init update failed rc=%d\n",
 						rc);
 		}
 	}
@@ -2482,11 +2549,12 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_host_deinit(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("[%s] failed to deinit host_%d, rc=%d\n",
+			printk("[%s] failed to deinit host_%d, rc=%d\n",
 			       display->name, i, rc);
 		}
 	}
@@ -2500,11 +2568,12 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Host engine states are already taken care for
 	 * continuous splash case
 	 */
 	if (display->is_cont_splash_enabled) {
-		DSI_DEBUG("cont splash enabled, host enable not required\n");
+		printk("cont splash enabled, host enable not required\n");
 		return 0;
 	}
 
@@ -2512,7 +2581,7 @@
 
 	rc = dsi_ctrl_set_host_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable host engine, rc=%d\n",
+		printk("[%s] failed to enable host engine, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2525,7 +2594,7 @@
 		rc = dsi_ctrl_set_host_engine_state(ctrl->ctrl,
 						    DSI_CTRL_ENGINE_ON);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable sl host engine, rc=%d\n",
+			printk("[%s] failed to enable sl host engine, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_master;
 		}
@@ -2544,6 +2613,7 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->cmd_master_idx];
 	/*
 	 * For platforms where ULPS is controlled by DSI controller block,
@@ -2559,7 +2629,7 @@
 					DSI_CTRL_OP_HOST_ENGINE,
 					false);
 			if (rc)
-				DSI_DEBUG("host state update failed %d\n", rc);
+				printk("host state update failed %d\n", rc);
 		}
 		return rc;
 	}
@@ -2572,13 +2642,13 @@
 		rc = dsi_ctrl_set_host_engine_state(ctrl->ctrl,
 						    DSI_CTRL_ENGINE_OFF);
 		if (rc)
-			DSI_ERR("[%s] failed to disable host engine, rc=%d\n",
+			printk("[%s] failed to disable host engine, rc=%d\n",
 			       display->name, rc);
 	}
 
 	rc = dsi_ctrl_set_host_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_OFF);
 	if (rc) {
-		DSI_ERR("[%s] failed to disable host engine, rc=%d\n",
+		printk("[%s] failed to disable host engine, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2593,11 +2663,12 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->video_master_idx];
 
 	rc = dsi_ctrl_set_vid_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable vid engine, rc=%d\n",
+		printk("[%s] failed to enable vid engine, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2610,7 +2681,7 @@
 		rc = dsi_ctrl_set_vid_engine_state(ctrl->ctrl,
 						   DSI_CTRL_ENGINE_ON);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable vid engine, rc=%d\n",
+			printk("[%s] failed to enable vid engine, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_master;
 		}
@@ -2629,6 +2700,7 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->video_master_idx];
 
 	display_for_each_ctrl(i, display) {
@@ -2639,13 +2711,13 @@
 		rc = dsi_ctrl_set_vid_engine_state(ctrl->ctrl,
 						   DSI_CTRL_ENGINE_OFF);
 		if (rc)
-			DSI_ERR("[%s] failed to disable vid engine, rc=%d\n",
+			printk("[%s] failed to disable vid engine, rc=%d\n",
 			       display->name, rc);
 	}
 
 	rc = dsi_ctrl_set_vid_engine_state(m_ctrl->ctrl, DSI_CTRL_ENGINE_OFF);
 	if (rc)
-		DSI_ERR("[%s] failed to disable mvid engine, rc=%d\n",
+		printk("[%s] failed to disable mvid engine, rc=%d\n",
 		       display->name, rc);
 
 	return rc;
@@ -2658,6 +2730,7 @@
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 	enum dsi_phy_pll_source m_src = DSI_PLL_SOURCE_STANDALONE;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->clk_master_idx];
 	if (display->ctrl_count > 1)
 		m_src = DSI_PLL_SOURCE_NATIVE;
@@ -2668,7 +2741,7 @@
 			    true,
 			    display->is_cont_splash_enabled);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI PHY, rc=%d\n",
+		printk("[%s] failed to enable DSI PHY, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2684,7 +2757,7 @@
 				    true,
 				    display->is_cont_splash_enabled);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable DSI PHY, rc=%d\n",
+			printk("[%s] failed to enable DSI PHY, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_master;
 		}
@@ -2704,6 +2777,7 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->clk_master_idx];
 
 	display_for_each_ctrl(i, display) {
@@ -2713,13 +2787,13 @@
 
 		rc = dsi_phy_disable(ctrl->phy);
 		if (rc)
-			DSI_ERR("[%s] failed to disable DSI PHY, rc=%d\n",
+			printk("[%s] failed to disable DSI PHY, rc=%d\n",
 			       display->name, rc);
 	}
 
 	rc = dsi_phy_disable(m_ctrl->phy);
 	if (rc)
-		DSI_ERR("[%s] failed to disable DSI PHY, rc=%d\n",
+		printk("[%s] failed to disable DSI PHY, rc=%d\n",
 		       display->name, rc);
 
 	return rc;
@@ -2736,6 +2810,7 @@
 	struct dsi_display_ctrl *ctrl;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!(flags & DSI_CTRL_CMD_LAST_COMMAND))
 		return;
 
@@ -2755,6 +2830,7 @@
 	struct dsi_display_ctrl *ctrl, *m_ctrl;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_flags = (DSI_CTRL_CMD_BROADCAST | DSI_CTRL_CMD_BROADCAST_MASTER |
 		   DSI_CTRL_CMD_DEFER_TRIGGER | DSI_CTRL_CMD_FETCH_MEMORY);
 	flags = (DSI_CTRL_CMD_BROADCAST | DSI_CTRL_CMD_DEFER_TRIGGER |
@@ -2779,7 +2855,7 @@
 	dsi_display_mask_overflow(display, m_flags, true);
 	rc = dsi_ctrl_cmd_transfer(m_ctrl->ctrl, msg, &m_flags);
 	if (rc) {
-		DSI_ERR("[%s] cmd transfer failed on master,rc=%d\n",
+		printk("[%s] cmd transfer failed on master,rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2791,14 +2867,14 @@
 
 		rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, msg, &flags);
 		if (rc) {
-			DSI_ERR("[%s] cmd transfer failed, rc=%d\n",
+			printk("[%s] cmd transfer failed, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
 
 		rc = dsi_ctrl_cmd_tx_trigger(ctrl->ctrl, flags);
 		if (rc) {
-			DSI_ERR("[%s] cmd trigger failed, rc=%d\n",
+			printk("[%s] cmd trigger failed, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
@@ -2806,7 +2882,7 @@
 
 	rc = dsi_ctrl_cmd_tx_trigger(m_ctrl->ctrl, m_flags);
 	if (rc) {
-		DSI_ERR("[%s] cmd trigger failed for master, rc=%d\n",
+		printk("[%s] cmd trigger failed for master, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -2818,7 +2894,7 @@
 
 		rc = dsi_ctrl_clear_slave_dma_status(ctrl->ctrl, flags);
 		if (rc) {
-			DSI_ERR("[%s] clear interrupt status failed, rc=%d\n",
+			printk("[%s] clear interrupt status failed, rc=%d\n",
 				display->name, rc);
 			goto error;
 		}
@@ -2835,11 +2911,12 @@
 	int i;
 	struct dsi_display_ctrl *m_ctrl, *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* For continuous splash use case ctrl states are updated
 	 * separately and hence we do an early return
 	 */
 	if (display->is_cont_splash_enabled) {
-		DSI_DEBUG("cont splash enabled, phy sw reset not required\n");
+		printk("cont splash enabled, phy sw reset not required\n");
 		return 0;
 	}
 
@@ -2847,7 +2924,7 @@
 
 	rc = dsi_ctrl_phy_sw_reset(m_ctrl->ctrl);
 	if (rc) {
-		DSI_ERR("[%s] failed to reset phy, rc=%d\n", display->name, rc);
+		printk("[%s] failed to reset phy, rc=%d\n", display->name, rc);
 		goto error;
 	}
 
@@ -2858,7 +2935,7 @@
 
 		rc = dsi_ctrl_phy_sw_reset(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("[%s] failed to reset phy, rc=%d\n",
+			printk("[%s] failed to reset phy, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
@@ -2886,8 +2963,9 @@
 	struct dsi_display *display;
 	int rc = 0, ret = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!host || !msg) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return 0;
 	}
 
@@ -2895,28 +2973,28 @@
 
 	/* Avoid sending DCS commands when ESD recovery is pending */
 	if (atomic_read(&display->panel->esd_recovery_pending)) {
-		DSI_DEBUG("ESD recovery pending\n");
+		printk("ESD recovery pending\n");
 		return 0;
 	}
 
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable all DSI clocks, rc=%d\n",
+		printk("[%s] failed to enable all DSI clocks, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
 
 	rc = dsi_display_wake_up(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to wake up display, rc=%d\n",
+		printk("[%s] failed to wake up display, rc=%d\n",
 		       display->name, rc);
 		goto error_disable_clks;
 	}
 
 	rc = dsi_display_cmd_engine_enable(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable cmd engine, rc=%d\n",
+		printk("[%s] failed to enable cmd engine, rc=%d\n",
 		       display->name, rc);
 		goto error_disable_clks;
 	}
@@ -2924,7 +3002,7 @@
 	if (display->tx_cmd_buf == NULL) {
 		rc = dsi_host_alloc_cmd_tx_buffer(display);
 		if (rc) {
-			DSI_ERR("failed to allocate cmd tx buffer memory\n");
+			printk("failed to allocate cmd tx buffer memory\n");
 			goto error_disable_cmd_engine;
 		}
 	}
@@ -2932,7 +3010,7 @@
 	if (display->ctrl_count > 1 && !(msg->flags & MIPI_DSI_MSG_UNICAST)) {
 		rc = dsi_display_broadcast_cmd(display, msg);
 		if (rc) {
-			DSI_ERR("[%s] cmd broadcast failed, rc=%d\n",
+			printk("[%s] cmd broadcast failed, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_cmd_engine;
 		}
@@ -2948,7 +3026,7 @@
 		rc = dsi_ctrl_cmd_transfer(display->ctrl[ctrl_idx].ctrl, msg,
 				&cmd_flags);
 		if (rc) {
-			DSI_ERR("[%s] cmd transfer failed, rc=%d\n",
+			printk("[%s] cmd transfer failed, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_cmd_engine;
 		}
@@ -2957,14 +3035,14 @@
 error_disable_cmd_engine:
 	ret = dsi_display_cmd_engine_disable(display);
 	if (ret) {
-		DSI_ERR("[%s]failed to disable DSI cmd engine, rc=%d\n",
+		printk("[%s]failed to disable DSI cmd engine, rc=%d\n",
 				display->name, ret);
 	}
 error_disable_clks:
 	ret = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_OFF);
 	if (ret) {
-		DSI_ERR("[%s] failed to disable all DSI clocks, rc=%d\n",
+		printk("[%s] failed to disable all DSI clocks, rc=%d\n",
 		       display->name, ret);
 	}
 error:
@@ -2983,17 +3061,20 @@
 	int rc = 0;
 	struct mipi_dsi_host *host = &display->host;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	host->dev = &display->pdev->dev;
 	host->ops = &dsi_host_ops;
 
 	rc = mipi_dsi_host_register(host);
 	if (rc) {
-		DSI_ERR("[%s] failed to register mipi dsi host, rc=%d\n",
+		printk("[%s] failed to register mipi dsi host, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
 
 error:
+    printk("%s:%d, ACHEUL, ret: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 static int dsi_display_mipi_host_deinit(struct dsi_display *display)
@@ -3001,11 +3082,13 @@
 	int rc = 0;
 	struct mipi_dsi_host *host = &display->host;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	mipi_dsi_host_unregister(host);
 
 	host->dev = NULL;
 	host->ops = NULL;
 
+    printk("%s:%d, ACHEUL, ret: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -3016,6 +3099,7 @@
 	struct dsi_clk_link_set *mux = &display->clock_info.mux_clks;
 	struct dsi_clk_link_set *shadow = &display->clock_info.shadow_clks;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (src->byte_clk) {
 		devm_clk_put(&display->pdev->dev, src->byte_clk);
 		src->byte_clk = NULL;
@@ -3105,19 +3189,19 @@
 
 	num_clk = dsi_display_get_clocks_count(display, dsi_clock_name);
 
-	DSI_DEBUG("clk count=%d\n", num_clk);
+	printk("clk count=%d\n", num_clk);
 
 	for (i = 0; i < num_clk; i++) {
 		dsi_display_get_clock_name(display, dsi_clock_name, i,
 						&clk_name);
 
-		DSI_DEBUG("clock name:%s\n", clk_name);
+		printk("clock name:%s\n", clk_name);
 
 		dsi_clk = devm_clk_get(&display->pdev->dev, clk_name);
 		if (IS_ERR_OR_NULL(dsi_clk)) {
 			rc = PTR_ERR(dsi_clk);
 
-			DSI_ERR("failed to get %s, rc=%d\n", clk_name, rc);
+			printk("failed to get %s, rc=%d\n", clk_name, rc);
 
 			if (dsi_display_check_prefix(mux_byte, clk_name)) {
 				mux->byte_clk = NULL;
@@ -3229,7 +3313,7 @@
 	void *clk_handle = NULL;
 
 	if (!priv) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -3240,7 +3324,7 @@
 	} else if (clk_state_info.client == DSI_CLK_REQ_DSI_CLIENT) {
 		clk_handle = display->dsi_clk_handle;
 	} else {
-		DSI_ERR("invalid clk handle, return error\n");
+		printk("invalid clk handle, return error\n");
 		return -EINVAL;
 	}
 
@@ -3251,7 +3335,7 @@
 	rc = dsi_display_clk_ctrl(clk_handle,
 		clk_state_info.clk_type, clk_state_info.clk_state);
 	if (rc) {
-		DSI_ERR("[%s] failed to %d DSI %d clocks, rc=%d\n",
+		printk("[%s] failed to %d DSI %d clocks, rc=%d\n",
 		       display->name, clk_state_info.clk_state,
 		       clk_state_info.clk_type, rc);
 		return rc;
@@ -3320,7 +3404,7 @@
 			rc = dsi_display_set_ulps(display, true);
 		}
 		if (rc)
-			DSI_ERR("%s: failed enable ulps, rc = %d\n",
+			printk("%s: failed enable ulps, rc = %d\n",
 			       __func__, rc);
 	}
 
@@ -3334,7 +3418,7 @@
 		 */
 		rc = dsi_display_config_clk_gating(display, false);
 		if (rc)
-			DSI_ERR("[%s] failed to disable clk gating, rc=%d\n",
+			printk("[%s] failed to disable clk gating, rc=%d\n",
 					display->name, rc);
 	}
 
@@ -3348,12 +3432,12 @@
 			dsi_display_phy_idle_off(display);
 			rc = dsi_display_set_clamp(display, true);
 			if (rc)
-				DSI_ERR("%s: Failed to enable dsi clamps. rc=%d\n",
+				printk("%s: Failed to enable dsi clamps. rc=%d\n",
 					__func__, rc);
 
 			rc = dsi_display_phy_reset_config(display, false);
 			if (rc)
-				DSI_ERR("%s: Failed to reset phy, rc=%d\n",
+				printk("%s: Failed to reset phy, rc=%d\n",
 						__func__, rc);
 		} else {
 			/* Make sure that controller is not in ULPS state when
@@ -3361,7 +3445,7 @@
 			 */
 			rc = dsi_display_set_ulps(display, false);
 			if (rc)
-				DSI_ERR("%s: failed to disable ulps. rc=%d\n",
+				printk("%s: failed to disable ulps. rc=%d\n",
 					__func__, rc);
 		}
 		/* dsi will not be able to serve irqs from here on */
@@ -3423,7 +3507,7 @@
 			display->ulps_enabled = false;
 			rc = dsi_display_set_ulps(display, true);
 			if (rc) {
-				DSI_ERR("%s: Failed to enter ULPS. rc=%d\n",
+				printk("%s: Failed to enter ULPS. rc=%d\n",
 					__func__, rc);
 				goto error;
 			}
@@ -3431,14 +3515,14 @@
 
 		rc = dsi_display_phy_reset_config(display, true);
 		if (rc) {
-			DSI_ERR("%s: Failed to reset phy, rc=%d\n",
+			printk("%s: Failed to reset phy, rc=%d\n",
 						__func__, rc);
 			goto error;
 		}
 
 		rc = dsi_display_set_clamp(display, false);
 		if (rc) {
-			DSI_ERR("%s: Failed to disable dsi clamps. rc=%d\n",
+			printk("%s: Failed to disable dsi clamps. rc=%d\n",
 				__func__, rc);
 			goto error;
 		}
@@ -3457,7 +3541,7 @@
 		if (display->ulps_enabled) {
 			rc = dsi_display_set_ulps(display, false);
 			if (rc) {
-				DSI_ERR("%s: failed to disable ulps, rc= %d\n",
+				printk("%s: failed to disable ulps, rc= %d\n",
 				       __func__, rc);
 				goto error;
 			}
@@ -3468,7 +3552,7 @@
 
 		rc = dsi_display_config_clk_gating(display, true);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable clk gating %d\n",
+			printk("[%s] failed to enable clk gating %d\n",
 					display->name, rc);
 			goto error;
 		}
@@ -3491,7 +3575,7 @@
 	struct dsi_display *display = priv;
 
 	if (!display) {
-		DSI_ERR("%s: Invalid arg\n", __func__);
+		printk("%s: Invalid arg\n", __func__);
 		return -EINVAL;
 	}
 
@@ -3499,12 +3583,12 @@
 	    (curr_state == DSI_CLK_OFF)) {
 		rc = dsi_display_phy_power_off(display);
 		if (rc)
-			DSI_ERR("[%s] failed to power off PHY, rc=%d\n",
+			printk("[%s] failed to power off PHY, rc=%d\n",
 				   display->name, rc);
 
 		rc = dsi_display_ctrl_power_off(display);
 		if (rc)
-			DSI_ERR("[%s] failed to power DSI vregs, rc=%d\n",
+			printk("[%s] failed to power DSI vregs, rc=%d\n",
 				   display->name, rc);
 	}
 	return rc;
@@ -3519,7 +3603,7 @@
 	struct dsi_display *display = priv;
 
 	if (!display) {
-		DSI_ERR("%s: invalid input\n", __func__);
+		printk("%s: invalid input\n", __func__);
 		return -EINVAL;
 	}
 
@@ -3533,22 +3617,22 @@
 		 *     not be changed during static screen.
 		 */
 
-		DSI_DEBUG("updating power states for ctrl and phy\n");
+		printk("updating power states for ctrl and phy\n");
 		rc = dsi_display_ctrl_power_on(display);
 		if (rc) {
-			DSI_ERR("[%s] failed to power on dsi controllers, rc=%d\n",
+			printk("[%s] failed to power on dsi controllers, rc=%d\n",
 				   display->name, rc);
 			return rc;
 		}
 
 		rc = dsi_display_phy_power_on(display);
 		if (rc) {
-			DSI_ERR("[%s] failed to power on dsi phy, rc = %d\n",
+			printk("[%s] failed to power on dsi phy, rc = %d\n",
 				   display->name, rc);
 			return rc;
 		}
 
-		DSI_DEBUG("%s: Enable DSI core power\n", __func__);
+		printk("%s: Enable DSI core power\n", __func__);
 	}
 
 	return rc;
@@ -3571,12 +3655,17 @@
 	int rc = 0, i = 0;
 	const char *data;
 	u8 temp[DSI_LANE_MAX - 1];
+    const char* compatible = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("invalid params\n");
+		printk("invalid params\n");
 		return -EINVAL;
 	}
 
+    of_property_read_string(display->pdev->dev.of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
 	/* lane-map-v2 supersedes lane-map-v1 setting */
 	rc = of_property_read_u8_array(display->pdev->dev.of_node,
 		"qcom,lane-map-v2", temp, (DSI_LANE_MAX - 1));
@@ -3585,7 +3674,7 @@
 			display->lane_map.lane_map_v2[i] = BIT(temp[i]);
 		return 0;
 	} else if (rc != EINVAL) {
-		DSI_DEBUG("Incorrect mapping, configure default\n");
+		printk("Incorrect mapping, configure default\n");
 		goto set_default;
 	}
 
@@ -3649,6 +3738,7 @@
 			__func__, data);
 		goto set_default;
 	}
+
 	return 0;
 
 set_default:
@@ -3667,6 +3757,7 @@
 	u32 *val = NULL;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	val = kcalloc(count, sizeof(*val), GFP_KERNEL);
 	if (ZERO_OR_NULL_PTR(val)) {
 		rc = -ENOMEM;
@@ -3687,7 +3778,7 @@
 
 	rc = val[index];
 
-	DSI_DEBUG("%s index=%d\n", propname, rc);
+	printk("%s index=%d\n", propname, rc);
 end:
 	kfree(val);
 	return rc;
@@ -3711,6 +3802,7 @@
 	struct device_node *of_node = display->pdev->dev.of_node;
 	char *dsi_ctrl_name, *dsi_phy_name;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!strcmp(display->display_type, "primary")) {
 		dsi_ctrl_name = "qcom,dsi-ctrl-num";
 		dsi_phy_name = "qcom,dsi-phy-num";
@@ -3725,17 +3817,17 @@
 
 	phy_count = dsi_display_get_phandle_count(display, dsi_phy_name);
 
-	DSI_DEBUG("ctrl count=%d, phy count=%d\n",
+	printk("ctrl count=%d, phy count=%d\n",
 			display->ctrl_count, phy_count);
 
 	if (!phy_count || !display->ctrl_count) {
-		DSI_ERR("no ctrl/phys found\n");
+		printk("no ctrl/phys found\n");
 		rc = -ENODEV;
 		goto error;
 	}
 
 	if (phy_count != display->ctrl_count) {
-		DSI_ERR("different ctrl and phy counts\n");
+		printk("different ctrl and phy counts\n");
 		rc = -ENODEV;
 		goto error;
 	}
@@ -3769,7 +3861,7 @@
 			break;
 	}
 
-	DSI_DEBUG("success\n");
+	printk("success\n");
 error:
 	return rc;
 }
@@ -3780,12 +3872,13 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL in", __FUNCTION__, __LINE__);
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		ctrl->ctrl = dsi_ctrl_get(ctrl->ctrl_of_node);
 		if (IS_ERR_OR_NULL(ctrl->ctrl)) {
 			rc = PTR_ERR(ctrl->ctrl);
-			DSI_ERR("failed to get dsi controller, rc=%d\n", rc);
+			printk("%s: %d, failed to get dsi controller, rc=%d\n", __FUNCTION__, __LINE__, rc);
 			ctrl->ctrl = NULL;
 			goto error_ctrl_put;
 		}
@@ -3793,7 +3886,7 @@
 		ctrl->phy = dsi_phy_get(ctrl->phy_of_node);
 		if (IS_ERR_OR_NULL(ctrl->phy)) {
 			rc = PTR_ERR(ctrl->phy);
-			DSI_ERR("failed to get phy controller, rc=%d\n", rc);
+			printk("%s:%d, failed to get phy controller, rc=%d\n", __FUNCTION__, __LINE__, rc);
 			dsi_ctrl_put(ctrl->ctrl);
 			ctrl->phy = NULL;
 			goto error_ctrl_put;
@@ -3807,7 +3900,7 @@
 				display->cmdline_topology);
 	if (IS_ERR_OR_NULL(display->panel)) {
 		rc = PTR_ERR(display->panel);
-		DSI_ERR("failed to get panel, rc=%d\n", rc);
+		printk("failed to get panel, rc=%d\n", rc);
 		display->panel = NULL;
 		goto error_ctrl_put;
 	}
@@ -3823,16 +3916,17 @@
 
 	rc = dsi_display_parse_lane_map(display);
 	if (rc) {
-		DSI_ERR("Lane map not found, rc=%d\n", rc);
+		printk("Lane map not found, rc=%d\n", rc);
 		goto error_ctrl_put;
 	}
 
 	rc = dsi_display_clocks_init(display);
 	if (rc) {
-		DSI_ERR("Failed to parse clock data, rc=%d\n", rc);
+		printk("Failed to parse clock data, rc=%d\n", rc);
 		goto error_ctrl_put;
 	}
 
+    printk("%s:%d, ACHEUL ret: OK", __FUNCTION__, __LINE__);
 	return 0;
 error_ctrl_put:
 	for (i = i - 1; i >= 0; i--) {
@@ -3840,6 +3934,7 @@
 		dsi_ctrl_put(ctrl->ctrl);
 		dsi_phy_put(ctrl->phy);
 	}
+    printk("%s:%d, ACHEUL ret: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -3849,9 +3944,10 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	rc = dsi_display_clocks_deinit(display);
 	if (rc)
-		DSI_ERR("clocks deinit failed, rc=%d\n", rc);
+		printk("clocks deinit failed, rc=%d\n", rc);
 
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
@@ -3873,6 +3969,7 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/*
 	 * To set a mode:
 	 * 1. Controllers should be turned off.
@@ -3900,35 +3997,36 @@
 {
 	struct dsi_display_mode *cur;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !tgt || !display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return false;
 	}
 
 	cur = display->panel->cur_mode;
 
 	if (cur->timing.h_active != tgt->timing.h_active) {
-		DSI_DEBUG("timing.h_active differs %d %d\n",
+		printk("timing.h_active differs %d %d\n",
 				cur->timing.h_active, tgt->timing.h_active);
 		return false;
 	}
 
 	if (cur->timing.h_back_porch != tgt->timing.h_back_porch) {
-		DSI_DEBUG("timing.h_back_porch differs %d %d\n",
+		printk("timing.h_back_porch differs %d %d\n",
 				cur->timing.h_back_porch,
 				tgt->timing.h_back_porch);
 		return false;
 	}
 
 	if (cur->timing.h_sync_width != tgt->timing.h_sync_width) {
-		DSI_DEBUG("timing.h_sync_width differs %d %d\n",
+		printk("timing.h_sync_width differs %d %d\n",
 				cur->timing.h_sync_width,
 				tgt->timing.h_sync_width);
 		return false;
 	}
 
 	if (cur->timing.h_front_porch != tgt->timing.h_front_porch) {
-		DSI_DEBUG("timing.h_front_porch differs %d %d\n",
+		printk("timing.h_front_porch differs %d %d\n",
 				cur->timing.h_front_porch,
 				tgt->timing.h_front_porch);
 		if (dfps_type != DSI_DFPS_IMMEDIATE_HFP)
@@ -3936,7 +4034,7 @@
 	}
 
 	if (cur->timing.h_skew != tgt->timing.h_skew) {
-		DSI_DEBUG("timing.h_skew differs %d %d\n",
+		printk("timing.h_skew differs %d %d\n",
 				cur->timing.h_skew,
 				tgt->timing.h_skew);
 		return false;
@@ -3945,28 +4043,28 @@
 	/* skip polarity comparison */
 
 	if (cur->timing.v_active != tgt->timing.v_active) {
-		DSI_DEBUG("timing.v_active differs %d %d\n",
+		printk("timing.v_active differs %d %d\n",
 				cur->timing.v_active,
 				tgt->timing.v_active);
 		return false;
 	}
 
 	if (cur->timing.v_back_porch != tgt->timing.v_back_porch) {
-		DSI_DEBUG("timing.v_back_porch differs %d %d\n",
+		printk("timing.v_back_porch differs %d %d\n",
 				cur->timing.v_back_porch,
 				tgt->timing.v_back_porch);
 		return false;
 	}
 
 	if (cur->timing.v_sync_width != tgt->timing.v_sync_width) {
-		DSI_DEBUG("timing.v_sync_width differs %d %d\n",
+		printk("timing.v_sync_width differs %d %d\n",
 				cur->timing.v_sync_width,
 				tgt->timing.v_sync_width);
 		return false;
 	}
 
 	if (cur->timing.v_front_porch != tgt->timing.v_front_porch) {
-		DSI_DEBUG("timing.v_front_porch differs %d %d\n",
+		printk("timing.v_front_porch differs %d %d\n",
 				cur->timing.v_front_porch,
 				tgt->timing.v_front_porch);
 		if (dfps_type != DSI_DFPS_IMMEDIATE_VFP)
@@ -3976,16 +4074,16 @@
 	/* skip polarity comparison */
 
 	if (cur->timing.refresh_rate == tgt->timing.refresh_rate)
-		DSI_DEBUG("timing.refresh_rate identical %d %d\n",
+		printk("timing.refresh_rate identical %d %d\n",
 				cur->timing.refresh_rate,
 				tgt->timing.refresh_rate);
 
 	if (cur->pixel_clk_khz != tgt->pixel_clk_khz)
-		DSI_DEBUG("pixel_clk_khz differs %d %d\n",
+		printk("pixel_clk_khz differs %d %d\n",
 				cur->pixel_clk_khz, tgt->pixel_clk_khz);
 
 	if (cur->dsi_mode_flags != tgt->dsi_mode_flags)
-		DSI_DEBUG("flags differs %d %d\n",
+		printk("flags differs %d %d\n",
 				cur->dsi_mode_flags, tgt->dsi_mode_flags);
 
 	return true;
@@ -4013,14 +4111,14 @@
 	int rc = 0;
 	int i;
 
-	DSI_DEBUG("%s:bit rate:%d\n", __func__, bit_clk_rate);
+	printk("%s:bit rate:%d\n", __func__, bit_clk_rate);
 	if (!display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (bit_clk_rate == 0) {
-		DSI_ERR("Invalid bit clock rate\n");
+		printk("Invalid bit clock rate\n");
 		return -EINVAL;
 	}
 
@@ -4048,7 +4146,7 @@
 			num_of_lanes++;
 
 		if (num_of_lanes == 0) {
-			DSI_ERR("Invalid lane count\n");
+			printk("Invalid lane count\n");
 			rc = -EINVAL;
 			goto error;
 		}
@@ -4079,11 +4177,11 @@
 			byte_intf_clk_rate = byte_clk_rate;
 		}
 
-		DSI_DEBUG("bit_clk_rate = %llu, bit_clk_rate_per_lane = %llu\n",
+		printk("bit_clk_rate = %llu, bit_clk_rate_per_lane = %llu\n",
 			 bit_rate, bit_rate_per_lane);
-		DSI_DEBUG("byte_clk_rate = %llu, byte_intf_clk_rate = %llu\n",
+		printk("byte_clk_rate = %llu, byte_intf_clk_rate = %llu\n",
 			  byte_clk_rate, byte_intf_clk_rate);
-		DSI_DEBUG("pclk_rate = %llu\n", pclk_rate);
+		printk("pclk_rate = %llu\n", pclk_rate);
 		SDE_EVT32(i, bit_rate, byte_clk_rate, pclk_rate);
 
 		ctrl->clk_freq.byte_clk_rate = byte_clk_rate;
@@ -4092,7 +4190,7 @@
 		rc = dsi_clk_set_link_frequencies(display->dsi_clk_handle,
 			ctrl->clk_freq, ctrl->cell_index);
 		if (rc) {
-			DSI_ERR("Failed to update link frequencies\n");
+			printk("Failed to update link frequencies\n");
 			goto error;
 		}
 
@@ -4120,6 +4218,7 @@
 	struct dsi_phy_cfg *cfg;
 	int phy_ver;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	m_ctrl = &display->ctrl[display->clk_master_idx];
 	dsi_ctrl = m_ctrl->ctrl;
 
@@ -4202,7 +4301,7 @@
 	rc = dsi_clk_update_parent(parent_clk,
 				&display->clock_info.mux_clks);
 	if (rc) {
-		DSI_ERR("failed to update mux parent\n");
+		printk("failed to update mux parent\n");
 		goto exit;
 	}
 
@@ -4214,13 +4313,13 @@
 				ctrl->ctrl->clk_freq.byte_clk_rate,
 				ctrl->ctrl->clk_freq.byte_intf_clk_rate, i);
 		if (rc) {
-			DSI_ERR("failed to set byte rate for index:%d\n", i);
+			printk("failed to set byte rate for index:%d\n", i);
 			goto recover_byte_clk;
 		}
 		rc = dsi_clk_set_pixel_clk_rate(display->dsi_clk_handle,
 				   ctrl->ctrl->clk_freq.pix_clk_rate, i);
 		if (rc) {
-			DSI_ERR("failed to set pix rate for index:%d\n", i);
+			printk("failed to set pix rate for index:%d\n", i);
 			goto recover_pix_clk;
 		}
 	}
@@ -4238,7 +4337,7 @@
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_wait4dynamic_refresh_done(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("wait4dynamic refresh failed for dsi:%d\n", i);
+			printk("wait4dynamic refresh failed for dsi:%d\n", i);
 			goto recover_pix_clk;
 		} else {
 			DSI_INFO("dynamic refresh done on dsi: %s\n",
@@ -4255,7 +4354,7 @@
 				&display->clock_info.mux_clks);
 
 	if (rc)
-		DSI_ERR("could not switch back to src clks %d\n", rc);
+		printk("could not switch back to src clks %d\n", rc);
 
 	dsi_clk_disable_unprepare(enable_clk);
 
@@ -4319,7 +4418,7 @@
 
 	rc = dsi_display_update_dsi_bitrate(display, mode->timing.clk_rate_hz);
 	if (rc) {
-		DSI_ERR("failed set link frequencies %d\n", rc);
+		printk("failed set link frequencies %d\n", rc);
 		goto exit;
 	}
 
@@ -4361,8 +4460,9 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (clk_rate <= 0) {
-		DSI_ERR("%s: bitrate should be greater than 0\n", __func__);
+		printk("%s: bitrate should be greater than 0\n", __func__);
 		return -EINVAL;
 	}
 
@@ -4379,7 +4479,7 @@
 				__func__, clk_rate);
 		atomic_set(&display->clkrate_change_pending, 1);
 	} else {
-		DSI_ERR("%s: Failed to prepare to configure '%d'. rc = %d\n",
+		printk("%s: Failed to prepare to configure '%d'. rc = %d\n",
 				__func__, clk_rate, rc);
 		/* Caching clock failed, so don't go on doing so. */
 		atomic_set(&display->clkrate_change_pending, 0);
@@ -4400,8 +4500,9 @@
 	int i = 0;
 	struct dsi_dyn_clk_caps *dyn_clk_caps;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !dsi_mode || !display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 	timing = &dsi_mode->timing;
@@ -4409,24 +4510,24 @@
 	dsi_panel_get_dfps_caps(display->panel, &dfps_caps);
 	dyn_clk_caps = &(display->panel->dyn_clk_caps);
 	if (!dfps_caps.dfps_support && !dyn_clk_caps->maintain_const_fps) {
-		DSI_ERR("dfps or constant fps not supported\n");
+		printk("dfps or constant fps not supported\n");
 		return -ENOTSUPP;
 	}
 
 	if (dfps_caps.type == DSI_DFPS_IMMEDIATE_CLK) {
-		DSI_ERR("dfps clock method not supported\n");
+		printk("dfps clock method not supported\n");
 		return -ENOTSUPP;
 	}
 
 	/* For split DSI, update the clock master first */
 
-	DSI_DEBUG("configuring seamless dynamic fps\n\n");
+	printk("configuring seamless dynamic fps\n\n");
 	SDE_EVT32(SDE_EVTLOG_FUNC_ENTRY);
 
 	m_ctrl = &display->ctrl[display->clk_master_idx];
 	rc = dsi_ctrl_async_timing_update(m_ctrl->ctrl, timing);
 	if (rc) {
-		DSI_ERR("[%s] failed to dfps update host_%d, rc=%d\n",
+		printk("[%s] failed to dfps update host_%d, rc=%d\n",
 				display->name, i, rc);
 		goto error;
 	}
@@ -4439,7 +4540,7 @@
 
 		rc = dsi_ctrl_async_timing_update(ctrl->ctrl, timing);
 		if (rc) {
-			DSI_ERR("[%s] failed to dfps update host_%d, rc=%d\n",
+			printk("[%s] failed to dfps update host_%d, rc=%d\n",
 					display->name, i, rc);
 			goto error;
 		}
@@ -4472,12 +4573,12 @@
 	int add_porches, diff;
 
 	if (!b_fp_out) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!a_total || !new_fps) {
-		DSI_ERR("Invalid pixel total or new fps in mode request\n");
+		printk("Invalid pixel total or new fps in mode request\n");
 		return -EINVAL;
 	}
 
@@ -4495,11 +4596,11 @@
 	else
 		b_fp_new = b_fp - add_porches;
 
-	DSI_DEBUG("fps %u a %u b %u b_fp %u new_fp %d\n",
+	printk("fps %u a %u b %u b_fp %u new_fp %d\n",
 			new_fps, a_total, b_total, b_fp, b_fp_new);
 
 	if (b_fp_new < 0) {
-		DSI_ERR("Invalid new_hfp calcluated%d\n", b_fp_new);
+		printk("Invalid new_hfp calcluated%d\n", b_fp_new);
 		return -EINVAL;
 	}
 
@@ -4535,14 +4636,14 @@
 	int rc = 0;
 
 	if (!display || !adj_mode) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 	m_ctrl = display->ctrl[display->clk_master_idx].ctrl;
 
 	dsi_panel_get_dfps_caps(display->panel, &dfps_caps);
 	if (!dfps_caps.dfps_support) {
-		DSI_ERR("dfps not supported by panel\n");
+		printk("dfps not supported by panel\n");
 		return -EINVAL;
 	}
 
@@ -4552,14 +4653,14 @@
 	if (!curr_refresh_rate) {
 		if (!dsi_display_is_seamless_dfps_possible(display,
 				&per_ctrl_mode, dfps_caps.type)) {
-			DSI_ERR("seamless dynamic fps not supported for mode\n");
+			printk("seamless dynamic fps not supported for mode\n");
 			return -EINVAL;
 		}
 		if (display->panel->cur_mode) {
 			curr_refresh_rate =
 				display->panel->cur_mode->timing.refresh_rate;
 		} else {
-			DSI_ERR("cur_mode is not initialized\n");
+			printk("cur_mode is not initialized\n");
 			return -EINVAL;
 		}
 	}
@@ -4596,7 +4697,7 @@
 		break;
 
 	default:
-		DSI_ERR("Unsupported DFPS mode %d\n", dfps_caps.type);
+		printk("Unsupported DFPS mode %d\n", dfps_caps.type);
 		rc = -ENOTSUPP;
 	}
 
@@ -4609,16 +4710,16 @@
 	int rc = 0;
 
 	if (!display || !adj_mode) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return false;
 	}
 
 	/* Currently the only seamless transition is dynamic fps */
 	rc = dsi_display_get_dfps_timing(display, adj_mode, 0);
 	if (rc) {
-		DSI_DEBUG("Dynamic FPS not supported for seamless\n");
+		printk("Dynamic FPS not supported for seamless\n");
 	} else {
-		DSI_DEBUG("Mode switch is seamless Dynamic FPS\n");
+		printk("Mode switch is seamless Dynamic FPS\n");
 		adj_mode->dsi_mode_flags |= DSI_MODE_FLAG_DFPS |
 				DSI_MODE_FLAG_VBLANK_PRE_MODESET;
 	}
@@ -4643,7 +4744,7 @@
 	if ((cur_h_active == to_h_active) && (cur_v_active == to_v_active) &&
 			(cur_fps != to_fps)) {
 		to_mode->dsi_mode_flags |= DSI_MODE_FLAG_DMS_FPS;
-		DSI_DEBUG("DMS Modeset with FPS change\n");
+		printk("DMS Modeset with FPS change\n");
 	} else {
 		to_mode->dsi_mode_flags &= ~DSI_MODE_FLAG_DMS_FPS;
 	}
@@ -4662,7 +4763,7 @@
 
 	priv_info = mode->priv_info;
 	if (!priv_info) {
-		DSI_ERR("[%s] failed to get private info of the display mode\n",
+		printk("[%s] failed to get private info of the display mode\n",
 			display->name);
 		return -EINVAL;
 	}
@@ -4676,7 +4777,7 @@
 					     mode,
 					     &display->config);
 	if (rc) {
-		DSI_ERR("[%s] failed to get host config for mode, rc=%d\n",
+		printk("[%s] failed to get host config for mode, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -4688,7 +4789,7 @@
 			(DSI_MODE_FLAG_DFPS | DSI_MODE_FLAG_VRR)) {
 		rc = dsi_display_dfps_update(display, mode);
 		if (rc) {
-			DSI_ERR("[%s]DSI dfps update failed, rc=%d\n",
+			printk("[%s]DSI dfps update failed, rc=%d\n",
 					display->name, rc);
 			goto error;
 		}
@@ -4698,7 +4799,7 @@
 				&display->config, mode, mode->dsi_mode_flags,
 					display->dsi_clk_handle);
 			if (rc) {
-				DSI_ERR("failed to update ctrl config\n");
+				printk("failed to update ctrl config\n");
 				goto error;
 			}
 		}
@@ -4710,7 +4811,7 @@
 						priv_info->phy_timing_len,
 						commit_phy_timing);
 				if (rc)
-					DSI_ERR("Fail to add timing params\n");
+					printk("Fail to add timing params\n");
 			}
 		}
 		if (!(mode->dsi_mode_flags & DSI_MODE_FLAG_DYN_CLK))
@@ -4721,7 +4822,7 @@
 		if (display->panel->panel_mode == DSI_OP_VIDEO_MODE) {
 			rc = dsi_display_dynamic_clk_switch_vid(display, mode);
 			if (rc)
-				DSI_ERR("dynamic clk change failed %d\n", rc);
+				printk("dynamic clk change failed %d\n", rc);
 			/*
 			 * skip rest of the opearations since
 			 * dsi_display_dynamic_clk_switch_vid() already takes
@@ -4733,7 +4834,7 @@
 			rc = dsi_display_dynamic_clk_configure_cmd(display,
 					clk_rate);
 			if (rc) {
-				DSI_ERR("Failed to configure dynamic clk\n");
+				printk("Failed to configure dynamic clk\n");
 				return rc;
 			}
 		}
@@ -4745,7 +4846,7 @@
 				mode, mode->dsi_mode_flags,
 				display->dsi_clk_handle);
 		if (rc) {
-			DSI_ERR("[%s] failed to update ctrl config, rc=%d\n",
+			printk("[%s] failed to update ctrl config, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
@@ -4772,7 +4873,7 @@
 				priv_info->phy_timing_len,
 				commit_phy_timing);
 			if (rc)
-				DSI_ERR("failed to add DSI PHY timing params\n");
+				printk("failed to add DSI PHY timing params\n");
 		}
 	}
 error:
@@ -4790,8 +4891,11 @@
 {
 	int rc = 0;
 
+    const char* compatible = NULL;
+
+    printk("%s:%d, ACHEUL, display name: %s", __FUNCTION__, __LINE__, display->name);
 	if (!display) {
-		DSI_ERR("invalid display\n");
+		printk("invalid display\n");
 		return -EINVAL;
 	}
 
@@ -4800,6 +4904,9 @@
 
 	mutex_lock(&display->display_lock);
 
+    of_property_read_string(display->pdev->dev.of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
 	display->parser = dsi_parser_get(&display->pdev->dev);
 	if (display->fw && display->parser)
 		display->parser_node = dsi_parser_get_head_node(
@@ -4808,13 +4915,13 @@
 
 	rc = dsi_display_parse_dt(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to parse dt, rc=%d\n", display->name, rc);
+		printk("[%s] failed to parse dt, rc=%d\n", display->name, rc);
 		goto error;
 	}
 
 	rc = dsi_display_res_init(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to initialize resources, rc=%d\n",
+		printk("[%s] failed to initialize resources, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -4833,8 +4940,9 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("invalid display\n");
+		printk("invalid display\n");
 		return -EINVAL;
 	}
 
@@ -4842,7 +4950,7 @@
 
 	rc = dsi_display_res_deinit(display);
 	if (rc)
-		DSI_ERR("[%s] failed to deinitialize resource, rc=%d\n",
+		printk("[%s] failed to deinitialize resource, rc=%d\n",
 		       display->name, rc);
 
 	mutex_unlock(&display->display_lock);
@@ -4860,15 +4968,16 @@
 	struct dsi_display *display = dsi_display;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* Vote for gdsc required to read register address space */
 	if (!display) {
-		DSI_ERR("invalid input display param\n");
+		printk("invalid input display param\n");
 		return -EINVAL;
 	}
 
 	rc = pm_runtime_get_sync(display->drm_dev->dev);
 	if (rc < 0) {
-		DSI_ERR("failed to vote gdsc for continuous splash, rc=%d\n",
+		printk("failed to vote gdsc for continuous splash, rc=%d\n",
 							rc);
 		return rc;
 	}
@@ -4891,7 +5000,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI link clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI link clocks, rc=%d\n",
 		       display->name, rc);
 		goto clk_manager_update;
 	}
@@ -4899,9 +5008,11 @@
 	/* Vote on panel regulator will be removed during suspend path */
 	rc = dsi_pwr_enable_regulator(&display->panel->power_info, true);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable vregs, rc=%d\n",
-				display->panel->name, rc);
-		goto clks_disabled;
+		printk("%s:%d, ACHEUL [%s] failed to enable vregs, rc=%d...WILL CONTINUE, FIXME!",
+				__FUNCTION__, __LINE__, display->panel->name, rc);
+		//ACHEUL FIXME
+        //goto clks_disabled;
+        rc = 0;
 	}
 
 	dsi_config_host_engine_state_for_cont_splash(display);
@@ -4910,9 +5021,11 @@
 	/* Set the current brightness level */
 	dsi_panel_bl_handoff(display->panel);
 
+    printk("%s:%d, ACHEUL is_cont_splash_enabled: %d, rc: %d", __FUNCTION__, __LINE__, display->is_cont_splash_enabled, rc);
 	return rc;
 
-clks_disabled:
+// FIXME! ACHEUL
+// clks_disabled:
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_OFF);
 
@@ -4936,13 +5049,14 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display->is_cont_splash_enabled)
 		return 0;
 
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_OFF);
 	if (rc)
-		DSI_ERR("[%s] failed to disable DSI link clocks, rc=%d\n",
+		printk("[%s] failed to disable DSI link clocks, rc=%d\n",
 		       display->name, rc);
 
 	pm_runtime_put_sync(display->drm_dev->dev);
@@ -4968,7 +5082,7 @@
 
 		atomic_set(&display->clkrate_change_pending, 0);
 	} else {
-		DSI_ERR("Failed to configure dsi bit clock '%d'. rc = %d\n",
+		printk("Failed to configure dsi bit clock '%d'. rc = %d\n",
 			display->cached_clk_rate, rc);
 	}
 
@@ -4985,7 +5099,7 @@
 		return 0;
 
 	if (display->panel->panel_mode == DSI_OP_CMD_MODE) {
-		DSI_ERR("[%s] split link is not supported in command mode\n",
+		printk("[%s] split link is not supported in command mode\n",
 			display->name);
 		rc = -ENOTSUPP;
 		goto error;
@@ -4994,7 +5108,7 @@
 	display_for_each_ctrl(i, display) {
 		ctrl = &display->ctrl[i];
 		if (!ctrl->ctrl->split_link_supported) {
-			DSI_ERR("[%s] split link is not supported by hw\n",
+			printk("[%s] split link is not supported by hw\n",
 				display->name);
 			rc = -ENOTSUPP;
 			goto error;
@@ -5003,7 +5117,7 @@
 		set_bit(DSI_PHY_SPLIT_LINK, ctrl->phy->hw.feature_map);
 	}
 
-	DSI_DEBUG("Split link is enabled\n");
+	printk("Split link is enabled\n");
 	return 0;
 
 error:
@@ -5033,8 +5147,9 @@
 	char *client2 = "mdp_event_client";
 	int i, rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!dev || !pdev || !master) {
-		DSI_ERR("invalid param(s), dev %pK, pdev %pK, master %pK\n",
+		printk("invalid param(s), dev %pK, pdev %pK, master %pK\n",
 				dev, pdev, master);
 		return -EINVAL;
 	}
@@ -5042,22 +5157,27 @@
 	drm = dev_get_drvdata(master);
 	display = platform_get_drvdata(pdev);
 	if (!drm || !display) {
-		DSI_ERR("invalid param(s), drm %pK, display %pK\n",
+		printk("invalid param(s), drm %pK, display %pK\n",
 				drm, display);
 		return -EINVAL;
 	}
-	if (!display->panel_node)
+	if (!display->panel_node) {
+        printk("%s:%d, ACHEUL, no panel node", __FUNCTION__, __LINE__);
 		return 0;
+    }
 
-	if (!display->fw)
+	if (!display->fw){
 		display->name = display->panel_node->name;
+    }
+
+    printk("%s:%d, ACHEUL, display name: %s", __FUNCTION__, __LINE__, display->name);
 
 	/* defer bind if ext bridge driver is not loaded */
 	if (display->panel && display->panel->host_config.ext_bridge_mode) {
 		for (i = 0; i < display->ext_bridge_cnt; i++) {
 			if (!of_drm_find_bridge(
 					display->ext_bridge[i].node_of)) {
-				DSI_DEBUG("defer for bridge[%d] %s\n", i,
+				printk("defer for bridge[%d] %s\n", i,
 				  display->ext_bridge[i].node_of->full_name);
 				return -EPROBE_DEFER;
 			}
@@ -5068,14 +5188,14 @@
 
 	rc = dsi_display_validate_split_link(display);
 	if (rc) {
-		DSI_ERR("[%s] split link validation failed, rc=%d\n",
+		printk("[%s] split link validation failed, rc=%d\n",
 						 display->name, rc);
 		goto error;
 	}
 
 	rc = dsi_display_debugfs_init(display);
 	if (rc) {
-		DSI_ERR("[%s] debugfs init failed, rc=%d\n", display->name, rc);
+		printk("[%s] debugfs init failed, rc=%d\n", display->name, rc);
 		goto error;
 	}
 
@@ -5088,7 +5208,7 @@
 		display_ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_drv_init(display_ctrl->ctrl, display->root);
 		if (rc) {
-			DSI_ERR("[%s] failed to initialize ctrl[%d], rc=%d\n",
+			printk("[%s] failed to initialize ctrl[%d], rc=%d\n",
 			       display->name, i, rc);
 			goto error_ctrl_deinit;
 		}
@@ -5096,7 +5216,7 @@
 
 		rc = dsi_phy_drv_init(display_ctrl->phy);
 		if (rc) {
-			DSI_ERR("[%s] Failed to initialize phy[%d], rc=%d\n",
+			printk("[%s] Failed to initialize phy[%d], rc=%d\n",
 				display->name, i, rc);
 			(void)dsi_ctrl_drv_deinit(display_ctrl->ctrl);
 			goto error_ctrl_deinit;
@@ -5133,14 +5253,14 @@
 	if (IS_ERR_OR_NULL(display->clk_mngr)) {
 		rc = PTR_ERR(display->clk_mngr);
 		display->clk_mngr = NULL;
-		DSI_ERR("dsi clock registration failed, rc = %d\n", rc);
+		printk("dsi clock registration failed, rc = %d\n", rc);
 		goto error_ctrl_deinit;
 	}
 
 	handle = dsi_register_clk_handle(display->clk_mngr, client1);
 	if (IS_ERR_OR_NULL(handle)) {
 		rc = PTR_ERR(handle);
-		DSI_ERR("failed to register %s client, rc = %d\n",
+		printk("failed to register %s client, rc = %d\n",
 		       client1, rc);
 		goto error_clk_deinit;
 	} else {
@@ -5150,7 +5270,7 @@
 	handle = dsi_register_clk_handle(display->clk_mngr, client2);
 	if (IS_ERR_OR_NULL(handle)) {
 		rc = PTR_ERR(handle);
-		DSI_ERR("failed to register %s client, rc = %d\n",
+		printk("failed to register %s client, rc = %d\n",
 		       client2, rc);
 		goto error_clk_client_deinit;
 	} else {
@@ -5165,14 +5285,14 @@
 
 		rc = dsi_ctrl_clk_cb_register(display_ctrl->ctrl, &clk_cb);
 		if (rc) {
-			DSI_ERR("[%s] failed to register ctrl clk_cb[%d], rc=%d\n",
+			printk("[%s] failed to register ctrl clk_cb[%d], rc=%d\n",
 			       display->name, i, rc);
 			goto error_ctrl_deinit;
 		}
 
 		rc = dsi_phy_clk_cb_register(display_ctrl->phy, &clk_cb);
 		if (rc) {
-			DSI_ERR("[%s] failed to register phy clk_cb[%d], rc=%d\n",
+			printk("[%s] failed to register phy clk_cb[%d], rc=%d\n",
 			       display->name, i, rc);
 			goto error_ctrl_deinit;
 		}
@@ -5181,7 +5301,7 @@
 	dsi_display_update_byte_intf_div(display);
 	rc = dsi_display_mipi_host_init(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to initialize mipi host, rc=%d\n",
+		printk("[%s] failed to initialize mipi host, rc=%d\n",
 		       display->name, rc);
 		goto error_ctrl_deinit;
 	}
@@ -5189,7 +5309,7 @@
 	rc = dsi_panel_drv_init(display->panel, &display->host);
 	if (rc) {
 		if (rc != -EPROBE_DEFER)
-			DSI_ERR("[%s] failed to initialize panel driver, rc=%d\n",
+			printk("[%s] failed to initialize panel driver, rc=%d\n",
 			       display->name, rc);
 		goto error_host_deinit;
 	}
@@ -5208,7 +5328,7 @@
 		rc = dsi_phy_set_clk_freq(display_ctrl->phy,
 				&display_ctrl->ctrl->clk_freq);
 		if (rc) {
-			DSI_ERR("[%s] failed to set phy clk freq, rc=%d\n",
+			printk("[%s] failed to set phy clk freq, rc=%d\n",
 					display->name, rc);
 			goto error;
 		}
@@ -5217,6 +5337,7 @@
 	/* register te irq handler */
 	dsi_display_register_te_irq(display);
 
+
 	goto error;
 
 error_host_deinit:
@@ -5234,6 +5355,7 @@
 	(void)dsi_display_debugfs_deinit(display);
 error:
 	mutex_unlock(&display->display_lock);
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -5251,14 +5373,15 @@
 	struct platform_device *pdev = to_platform_device(dev);
 	int i, rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!dev || !pdev) {
-		DSI_ERR("invalid param(s)\n");
+		printk("invalid param(s)\n");
 		return;
 	}
 
 	display = platform_get_drvdata(pdev);
 	if (!display) {
-		DSI_ERR("invalid display\n");
+		printk("invalid display\n");
 		return;
 	}
 
@@ -5266,12 +5389,12 @@
 
 	rc = dsi_panel_drv_deinit(display->panel);
 	if (rc)
-		DSI_ERR("[%s] failed to deinit panel driver, rc=%d\n",
+		printk("[%s] failed to deinit panel driver, rc=%d\n",
 		       display->name, rc);
 
 	rc = dsi_display_mipi_host_deinit(display);
 	if (rc)
-		DSI_ERR("[%s] failed to deinit mipi hosts, rc=%d\n",
+		printk("[%s] failed to deinit mipi hosts, rc=%d\n",
 		       display->name,
 		       rc);
 
@@ -5280,13 +5403,13 @@
 
 		rc = dsi_phy_drv_deinit(display_ctrl->phy);
 		if (rc)
-			DSI_ERR("[%s] failed to deinit phy%d driver, rc=%d\n",
+			printk("[%s] failed to deinit phy%d driver, rc=%d\n",
 			       display->name, i, rc);
 
 		display->ctrl->ctrl->dma_cmd_workq = NULL;
 		rc = dsi_ctrl_drv_deinit(display_ctrl->ctrl);
 		if (rc)
-			DSI_ERR("[%s] failed to deinit ctrl%d driver, rc=%d\n",
+			printk("[%s] failed to deinit ctrl%d driver, rc=%d\n",
 			       display->name, i, rc);
 	}
 
@@ -5315,21 +5438,32 @@
 {
 	int rc = 0;
 	struct platform_device *pdev = display->pdev;
+    const char* compatible    = NULL;
+    const char* acheul_tag    = NULL;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+    of_property_read_string(pdev->dev.of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible  : %s", __FUNCTION__, __LINE__, compatible);
+
+    of_property_read_string(pdev->dev.of_node, "acheul-tag", &acheul_tag);
+    printk("%s:%d, ACHEUL, acheul-tag: %s", __FUNCTION__, __LINE__, acheul_tag);
 
 	mutex_init(&display->display_lock);
 
 	rc = _dsi_display_dev_init(display);
 	if (rc) {
-		DSI_ERR("device init failed, rc=%d\n", rc);
+		printk("device init failed, rc=%d\n", rc);
 		goto end;
 	}
 
 	rc = component_add(&pdev->dev, &dsi_display_comp_ops);
 	if (rc)
-		DSI_ERR("component add failed, rc=%d\n", rc);
+		printk("component add failed, rc=%d\n", rc);
 
-	DSI_DEBUG("component add success: %s\n", display->name);
+	printk("component add success: %s\n", display->name);
 end:
+    printk("%s:%d, ACHEUL, out: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -5338,8 +5472,10 @@
 {
 	struct dsi_display *display = context;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	mutex_init(&display->display_lock);
 	if (fw) {
-		DSI_DEBUG("reading data from firmware, size=%zd\n",
+		printk("reading data from firmware, size=%zd\n",
 			fw->size);
 
 		display->fw = fw;
@@ -5349,19 +5485,31 @@
 	if (dsi_display_init(display))
 		return;
 
-	DSI_DEBUG("success\n");
+	printk("success\n");
 }
 
 int dsi_display_dev_probe(struct platform_device *pdev)
 {
 	struct dsi_display *display = NULL;
 	struct device_node *node = NULL, *panel_node = NULL, *mdp_node = NULL;
+
+    struct device_node* skyworth_panel_node = NULL;
+
 	int rc = 0, index = DSI_PRIMARY;
 	bool firm_req = false;
 	struct dsi_display_boot_param *boot_disp;
 
+    const char* compatible    = NULL;
+    const char* panel_name    = NULL;
+    const char* skyworth_panel_name = NULL;
+
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
+    of_property_read_string(pdev->dev.of_node, "compatible", &compatible);
+    printk("%s:%d, ACHEUL, compatible: %s", __FUNCTION__, __LINE__, compatible);
+
 	if (!pdev || !pdev->dev.of_node) {
-		DSI_ERR("pdev not found\n");
+		printk("pdev not found\n");
 		rc = -ENODEV;
 		goto end;
 	}
@@ -5375,43 +5523,83 @@
 	display->dma_cmd_workq = create_singlethread_workqueue(
 			"dsi_dma_cmd_workq");
 	if (!display->dma_cmd_workq)  {
-		DSI_ERR("failed to create work queue\n");
+		printk("failed to create work queue\n");
 		rc =  -EINVAL;
 		goto end;
 	}
 
 	display->display_type = of_get_property(pdev->dev.of_node,
 				"label", NULL);
-	if (!display->display_type)
+	if (!display->display_type){
+        printk("%s:%d, ACHEUL, primary found", __FUNCTION__, __LINE__);
 		display->display_type = "primary";
+    }
 
-	if (!strcmp(display->display_type, "secondary"))
+	if (!strcmp(display->display_type, "secondary")){
+        printk("%s:%d, ACHEUL, secondary found", __FUNCTION__, __LINE__);
 		index = DSI_SECONDARY;
+    }
 
 	if (of_get_property(pdev->dev.of_node, "boot-panel-param", NULL)) {
 		boot_displays[index].boot_disp_en = false;
-		DSI_DEBUG("boot_displays[%d].boot_disp_en false!\n", index);
+		printk("boot_displays[%d].boot_disp_en false!\n", index);
 	}
 
 	boot_disp = &boot_displays[index];
 	node = pdev->dev.of_node;
+
+    printk("%s:%d, ACHEUL boot display index: %d, name: %s, param: %s, config DSI parser: %d", __FUNCTION__, __LINE__, index, boot_disp->name, boot_disp->boot_param, IS_ENABLED(CONFIG_DSI_PARSER));
+
+    printk("%s:%d, ACHEUL, PARSING panel node", __FUNCTION__, __LINE__);
+    skyworth_panel_node = of_parse_phandle(node,
+            "qcom,dsi-default-panel", 0);
+    if (!skyworth_panel_node){
+        printk("%s:%d, ACHEUL, skyworth panel node not found", __FUNCTION__, __LINE__);
+        DSI_WARN("default panel not found\n");
+    }
+    else {
+        printk("%s:%d, ACHEUL, skyworth_panel_node found", __FUNCTION__, __LINE__);
+
+        of_property_read_string(skyworth_panel_node, "qcom,mdss-dsi-panel-name", &skyworth_panel_name);
+        printk("%s:%d, ACHEUL, dskyworth_panel_node skyworth panel name: %s", __FUNCTION__, __LINE__, skyworth_panel_name);
+    }
+
+    /* ACHEUL POOP */
 	if (boot_disp->boot_disp_en) {
 		mdp_node = of_parse_phandle(node, "qcom,mdp", 0);
 		if (!mdp_node) {
-			DSI_ERR("mdp_node not found\n");
+			printk("mdp_node not found\n");
 			rc = -ENODEV;
 			goto end;
 		}
 
 		/* The panel name should be same as UEFI name index */
 		panel_node = of_find_node_by_name(mdp_node, boot_disp->name);
-		if (!panel_node)
+		if (!panel_node){
+            printk("%s:%d, ACHEUL, panel node not found", __FUNCTION__, __LINE__);
 			DSI_WARN("panel_node %s not found\n", boot_disp->name);
+        }
+        else {
+            printk("%s:%d, ACHEUL, panel node found", __FUNCTION__, __LINE__);
+
+            of_property_read_string(panel_node, "qcom,mdss-dsi-panel-name", &panel_name);
+            printk("%s:%d, ACHEUL, panel name: %s", __FUNCTION__, __LINE__, panel_name);
+        }
 	} else {
+
+        printk("%s:%d, ACHEUL, PARSING panel node", __FUNCTION__, __LINE__);
 		panel_node = of_parse_phandle(node,
 				"qcom,dsi-default-panel", 0);
-		if (!panel_node)
+		if (!panel_node){
+            printk("%s:%d, ACHEUL, panel node not found", __FUNCTION__, __LINE__);
 			DSI_WARN("default panel not found\n");
+        }
+        else {
+            printk("%s:%d, ACHEUL, panel node found", __FUNCTION__, __LINE__);
+
+            of_property_read_string(panel_node, "qcom,mdss-dsi-panel-name", &panel_name);
+            printk("%s:%d, ACHEUL, default_panel: %s", __FUNCTION__, __LINE__, panel_name);
+        }
 
 		if (IS_ENABLED(CONFIG_DSI_PARSER))
 			firm_req = !request_firmware_nowait(
@@ -5434,15 +5622,20 @@
 	/* initialize display in firmware callback */
 	if (!firm_req) {
 		rc = dsi_display_init(display);
-		if (rc)
+		if (rc){
+            printk("%s:%d, ACHEUL, display init failed", __FUNCTION__, __LINE__);
 			goto end;
+        }
 	}
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return 0;
 end:
 	if (display)
 		devm_kfree(&pdev->dev, display);
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
+	mutex_init(&display->display_lock);
 	return rc;
 }
 
@@ -5452,8 +5645,9 @@
 	struct dsi_display *display;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!pdev) {
-		DSI_ERR("Invalid device\n");
+		printk("Invalid device\n");
 		return -EINVAL;
 	}
 
@@ -5485,6 +5679,7 @@
 {
 	int i, count = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	for (i = 0; i < MAX_DSI_ACTIVE_DISPLAY; i++) {
 		struct dsi_display *display = boot_displays[i].disp;
 
@@ -5492,6 +5687,7 @@
 			count++;
 	}
 
+    printk("%s:%d, ACHEUL, count: %d", __FUNCTION__, __LINE__, count);
 	return count;
 }
 
@@ -5499,8 +5695,9 @@
 {
 	int index = 0, count = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display_array || !max_display_count) {
-		DSI_ERR("invalid params\n");
+		printk("invalid params\n");
 		return 0;
 	}
 
@@ -5521,8 +5718,9 @@
 	struct dsi_bridge *bridge;
 	struct msm_drm_private *priv = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->drm_dev || !enc) {
-		DSI_ERR("invalid param(s)\n");
+		printk("invalid param(s)\n");
 		return -EINVAL;
 	}
 
@@ -5530,20 +5728,20 @@
 	priv = display->drm_dev->dev_private;
 
 	if (!priv) {
-		DSI_ERR("Private data is not present\n");
+		printk("Private data is not present\n");
 		rc = -EINVAL;
 		goto error;
 	}
 
 	if (display->bridge) {
-		DSI_ERR("display is already initialize\n");
+		printk("display is already initialize\n");
 		goto error;
 	}
 
 	bridge = dsi_drm_bridge_init(display, display->drm_dev, enc);
 	if (IS_ERR_OR_NULL(bridge)) {
 		rc = PTR_ERR(bridge);
-		DSI_ERR("[%s] brige init failed, %d\n", display->name, rc);
+		printk("[%s] brige init failed, %d\n", display->name, rc);
 		goto error;
 	}
 
@@ -5559,8 +5757,9 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -5594,6 +5793,7 @@
 	struct drm_display_mode *pmode, *pt;
 	int count;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* if there are modes defined in panel, ignore external modes */
 	if (display->panel->num_timing_nodes)
 		return dsi_connector_get_modes(connector, disp, avail_res);
@@ -5619,6 +5819,7 @@
 	struct dsi_display *display = disp;
 	enum drm_mode_status status;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* always do internal mode_valid check */
 	status = dsi_conn_mode_valid(connector, mode, disp, avail_res);
 	if (status != MODE_OK)
@@ -5644,14 +5845,15 @@
 	struct dsi_display *display;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!info || !disp) {
-		DSI_ERR("invalid params\n");
+		printk("invalid params\n");
 		return -EINVAL;
 	}
 
 	display = disp;
 	if (!display->panel) {
-		DSI_ERR("invalid display panel\n");
+		printk("invalid display panel\n");
 		return -EINVAL;
 	}
 
@@ -5690,6 +5892,7 @@
 	struct msm_display_topology *topology;
 	struct dsi_display *ext_display = (struct dsi_display *)display;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!drm_mode || !mode_info ||
 			!avail_res || !avail_res->max_mixer_width)
 		return -EINVAL;
@@ -5724,7 +5927,7 @@
 		}
 	}
 
-	DSI_DEBUG("%dx%d@%d : %d %d %d\n",
+	printk("%dx%d@%d : %d %d %d\n",
 		drm_mode->hdisplay, drm_mode->vdisplay, drm_mode->vrefresh,
 		topology->num_lm, topology->num_enc, topology->num_intf);
 
@@ -5742,6 +5945,7 @@
 	struct dsi_display *display;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!bridge || !bridge->encoder) {
 		SDE_ERROR("invalid argument\n");
 		return NULL;
@@ -5784,6 +5988,7 @@
 	struct dsi_display_ext_bridge *ext_bridge;
 	struct drm_display_mode tmp;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	ext_bridge = dsi_display_ext_get_bridge(bridge);
 	if (!ext_bridge)
 		return MODE_ERROR;
@@ -5818,6 +6023,7 @@
 	struct dsi_display_ext_bridge *ext_bridge;
 	struct drm_display_mode tmp;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	ext_bridge = dsi_display_ext_get_bridge(bridge);
 	if (!ext_bridge)
 		return;
@@ -5834,11 +6040,12 @@
 	struct dsi_panel *panel;
 
 	if (!host || !dsi || !display->panel) {
-		DSI_ERR("Invalid param\n");
+		printk("Invalid param\n");
 		return -EINVAL;
 	}
 
-	DSI_DEBUG("DSI[%s]: channel=%d, lanes=%d, format=%d, mode_flags=%lx\n",
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+	printk("DSI[%s]: channel=%d, lanes=%d, format=%d, mode_flags=%lx\n",
 		dsi->name, dsi->channel, dsi->lanes,
 		dsi->format, dsi->mode_flags);
 
@@ -5896,7 +6103,7 @@
 			dsi->mode_flags & MIPI_DSI_MODE_VIDEO_EOF_BLLP;
 	} else {
 		panel->panel_mode = DSI_OP_CMD_MODE;
-		DSI_ERR("command mode not supported by ext bridge\n");
+		printk("command mode not supported by ext bridge\n");
 		return -ENOTSUPP;
 	}
 
@@ -5932,6 +6139,7 @@
 	struct drm_bridge *prev_bridge;
 	int rc = 0, i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !encoder || !connector)
 		return -EINVAL;
 
@@ -5940,24 +6148,32 @@
 	sde_conn = to_sde_connector(connector);
 	prev_bridge = bridge;
 
-	if (display->panel && !display->panel->host_config.ext_bridge_mode)
+	if (display->panel && !display->panel->host_config.ext_bridge_mode){
+        printk("%s:%d, ACHEUL panel and no ext bridge mode", __FUNCTION__, __LINE__);
 		return 0;
+    }
 
 	for (i = 0; i < display->ext_bridge_cnt; i++) {
 		struct dsi_display_ext_bridge *ext_bridge_info =
 				&display->ext_bridge[i];
 
+        printk("%s:%d, ACHEUL bridge %d/%d", __FUNCTION__, __LINE__, i, display->ext_bridge_cnt);
+
 		/* return if ext bridge is already initialized */
-		if (ext_bridge_info->bridge)
+		if (ext_bridge_info->bridge){
+            printk("%s:%d, ACHEUL bridge aleady initialized", __FUNCTION__, __LINE__);
 			return 0;
+        }
 
 		ext_bridge = of_drm_find_bridge(ext_bridge_info->node_of);
 		if (IS_ERR_OR_NULL(ext_bridge)) {
 			rc = PTR_ERR(ext_bridge);
-			DSI_ERR("failed to find ext bridge\n");
+			printk("failed to find ext bridge\n");
 			goto error;
 		}
 
+        printk("%s:%d, ACHEUL found bridge", __FUNCTION__, __LINE__);
+
 		/* override functions for mode adjustment */
 		if (display->ext_bridge_cnt > 1) {
 			ext_bridge_info->bridge_funcs = *ext_bridge->funcs;
@@ -5976,10 +6192,11 @@
 
 		rc = drm_bridge_attach(encoder, ext_bridge, prev_bridge);
 		if (rc) {
-			DSI_ERR("[%s] ext brige attach failed, %d\n",
+			printk("[%s] ext brige attach failed, %d\n",
 				display->name, rc);
 			goto error;
 		}
+        printk("%s:%d, ACHEUL bridge attached", __FUNCTION__, __LINE__);
 
 		ext_bridge_info->display = display;
 		ext_bridge_info->bridge = ext_bridge;
@@ -6005,6 +6222,7 @@
 		    !display->ext_conn->funcs ||
 		    !display->ext_conn->helper_private ||
 		    display->ext_bridge_cnt > 1) {
+            printk("%s:%d, ACHEUL no connector created", __FUNCTION__, __LINE__);
 			display->ext_conn = NULL;
 			continue;
 		}
@@ -6032,10 +6250,13 @@
 
 		/* add support to attach/detach */
 		display->host.ops = &dsi_host_ext_ops;
+        printk("%s:%d, ACHEUL bridge hook up", __FUNCTION__, __LINE__);
 	}
 
+    printk("%s:%d, ACHEUL return OK", __FUNCTION__, __LINE__);
 	return 0;
 error:
+    printk("%s:%d, ACHEUL ret: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -6048,20 +6269,22 @@
 	int i, rc;
 
 	if (!info || !disp) {
-		DSI_ERR("invalid params\n");
+		printk("invalid params\n");
 		return -EINVAL;
 	}
 
 	display = disp;
 	if (!display->panel) {
-		DSI_ERR("invalid display panel\n");
+		printk("invalid display panel\n");
 		return -EINVAL;
 	}
 
+    printk("%s:%d, ACHEUL, display name: %s", __FUNCTION__, __LINE__, display->name);
+
 	mutex_lock(&display->display_lock);
 	rc = dsi_panel_get_phy_props(display->panel, &phy_props);
 	if (rc) {
-		DSI_ERR("[%s] failed to get panel phy props, rc=%d\n",
+		printk("[%s] failed to get panel phy props, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -6074,10 +6297,14 @@
 
 	info->is_connected = true;
 
-	if (!strcmp(display->display_type, "primary"))
+	if (!strcmp(display->display_type, "primary")){
+        printk("%s:%d, ACHEUL primary", __FUNCTION__, __LINE__);
 		info->display_type = SDE_CONNECTOR_PRIMARY;
-	else if (!strcmp(display->display_type, "secondary"))
+    }
+	else if (!strcmp(display->display_type, "secondary")){
+        printk("%s:%d, ACHEUL secondary", __FUNCTION__, __LINE__);
 		info->display_type = SDE_CONNECTOR_SECONDARY;
+    }
 
 	info->width_mm = phy_props.panel_width_mm;
 	info->height_mm = phy_props.panel_height_mm;
@@ -6086,14 +6313,18 @@
 	info->qsync_min_fps =
 		display->panel->qsync_min_fps;
 
+    printk("%s:%d, ACHEUL mode: fps: %d", __FUNCTION__, __LINE__, display->panel->qsync_min_fps);
+
 	switch (display->panel->panel_mode) {
 	case DSI_OP_VIDEO_MODE:
+        printk("%s:%d, ACHEUL mode: DSI_OP_VIDEO_MODE", __FUNCTION__, __LINE__);
 		info->curr_panel_mode = MSM_DISPLAY_VIDEO_MODE;
 		info->capabilities |= MSM_DISPLAY_CAP_VID_MODE;
 		if (display->panel->panel_mode_switch_enabled)
 			info->capabilities |= MSM_DISPLAY_CAP_CMD_MODE;
 		break;
 	case DSI_OP_CMD_MODE:
+        printk("%s:%d, ACHEUL mode: DSI_OP_CMD_MODE", __FUNCTION__, __LINE__);
 		info->curr_panel_mode = MSM_DISPLAY_CMD_MODE;
 		info->capabilities |= MSM_DISPLAY_CAP_CMD_MODE;
 		if (display->panel->panel_mode_switch_enabled)
@@ -6103,13 +6334,15 @@
 			display->sw_te_using_wd;
 		break;
 	default:
-		DSI_ERR("unknwown dsi panel mode %d\n",
+		printk("unknwown dsi panel mode %d\n",
 				display->panel->panel_mode);
 		break;
 	}
 
-	if (display->panel->esd_config.esd_enabled)
+	if (display->panel->esd_config.esd_enabled){
+        printk("%s:%d, ACHEUL ESD enabled", __FUNCTION__, __LINE__);
 		info->capabilities |= MSM_DISPLAY_ESD_ENABLED;
+    }
 
 	info->te_source = display->te_source;
 
@@ -6125,11 +6358,12 @@
 			u32 *count)
 {
 	if (!display || !display->panel) {
-		DSI_ERR("invalid display:%d panel:%d\n", display != NULL,
+		printk("invalid display:%d panel:%d\n", display != NULL,
 			display ? display->panel != NULL : 0);
 		return -EINVAL;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	mutex_lock(&display->display_lock);
 	*count = display->panel->num_display_modes;
 	mutex_unlock(&display->display_lock);
@@ -6205,6 +6439,7 @@
 	struct dsi_host_common_cfg *cfg;
 	int i, j, total_modes, bpp, lanes = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !mode_idx)
 		return;
 
@@ -6253,7 +6488,7 @@
 			dst = &display->modes[*mode_idx];
 
 			if (!src || !dst) {
-				DSI_ERR("invalid mode index\n");
+				printk("invalid mode index\n");
 				return;
 			}
 			memcpy(dst, src, sizeof(struct dsi_display_mode));
@@ -6289,8 +6524,9 @@
 	struct dsi_dyn_clk_caps *dyn_clk_caps;
 	int i, start, end, rc = -EINVAL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !out_modes) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -6313,7 +6549,7 @@
 
 	rc = dsi_panel_get_dfps_caps(display->panel, &dfps_caps);
 	if (rc) {
-		DSI_ERR("[%s] failed to get dfps caps from panel\n",
+		printk("[%s] failed to get dfps caps from panel\n",
 				display->name);
 		goto error;
 	}
@@ -6338,7 +6574,7 @@
 						&display_mode,
 						topology_override);
 		if (rc) {
-			DSI_ERR("[%s] failed to get mode idx %d from panel\n",
+			printk("[%s] failed to get mode idx %d from panel\n",
 				   display->name, mode_idx);
 			goto error;
 		}
@@ -6387,7 +6623,7 @@
 			u32 curr_refresh_rate;
 
 			if (!sub_mode) {
-				DSI_ERR("invalid mode data\n");
+				printk("invalid mode data\n");
 				rc = -EFAULT;
 				goto error;
 			}
@@ -6421,6 +6657,7 @@
 		kfree(display->modes);
 
 	mutex_unlock(&display->display_lock);
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -6433,6 +6670,7 @@
 	struct dsi_display *display = (struct dsi_display *)dsi_display;
 	struct dsi_host_common_cfg *host;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->panel)
 		return -EINVAL;
 
@@ -6441,7 +6679,7 @@
 	count = display->panel->num_display_modes;
 	if (!count && display->ext_conn) {
 		mutex_unlock(&display->display_lock);
-		DSI_DEBUG("external bridge did not have timing node\n");
+		printk("external bridge did not have timing node\n");
 		return -EPERM;
 	}
 
@@ -6454,7 +6692,7 @@
 
 	if (!refresh_rate) {
 		mutex_unlock(&display->display_lock);
-		DSI_ERR("Null Refresh Rate\n");
+		printk("Null Refresh Rate\n");
 		return -EINVAL;
 	}
 
@@ -6487,6 +6725,7 @@
 
 	*num_lm = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	mutex_lock(&display->display_lock);
 	count = display->panel->num_display_modes;
 	mutex_unlock(&display->display_lock);
@@ -6517,6 +6756,7 @@
 	u32 count, i;
 	int rc;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !out_mode)
 		return -EINVAL;
 
@@ -6551,7 +6791,7 @@
 	mutex_unlock(&display->display_lock);
 
 	if (!*out_mode) {
-		DSI_ERR("[%s] failed to find mode for v_active %u h_active %u fps %u pclk %u\n",
+		printk("[%s] failed to find mode for v_active %u h_active %u fps %u pclk %u\n",
 				display->name, cmp->timing.v_active,
 				cmp->timing.h_active, cmp->timing.refresh_rate,
 				cmp->pixel_clk_khz);
@@ -6596,12 +6836,12 @@
 	struct dsi_dyn_clk_caps *dyn_clk_caps;
 
 	if (!display || !adj_mode) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!display->panel || !display->panel->cur_mode) {
-		DSI_DEBUG("Current panel mode not set\n");
+		printk("Current panel mode not set\n");
 		return rc;
 	}
 
@@ -6615,7 +6855,7 @@
 			dsi_panel_get_dfps_caps(display->panel, &dfps_caps);
 			if (dfps_caps.dfps_support ||
 				dyn_clk_caps->maintain_const_fps) {
-				DSI_DEBUG("Mode switch is seamless variable refresh\n");
+				printk("Mode switch is seamless variable refresh\n");
 				adj_mode->dsi_mode_flags |= DSI_MODE_FLAG_VRR;
 				SDE_EVT32(SDE_EVTLOG_FUNC_CASE1,
 					cur_mode->timing.refresh_rate,
@@ -6630,11 +6870,11 @@
 		/* dynamic clk change use case */
 		if (cur_mode->pixel_clk_khz != adj_mode->pixel_clk_khz) {
 			if (dyn_clk_caps->dyn_clk_support) {
-				DSI_DEBUG("dynamic clk change detected\n");
+				printk("dynamic clk change detected\n");
 				if ((adj_mode->dsi_mode_flags &
 					DSI_MODE_FLAG_VRR) &&
 					(!dyn_clk_caps->maintain_const_fps)) {
-					DSI_ERR("dfps and dyn clk not supported in same commit\n");
+					printk("dfps and dyn clk not supported in same commit\n");
 					rc = -ENOTSUPP;
 					goto error;
 				}
@@ -6662,8 +6902,9 @@
 	struct dsi_display_ctrl *ctrl;
 	struct dsi_display_mode adj_mode;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !mode) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -6674,7 +6915,7 @@
 
 	rc = dsi_panel_validate_mode(display->panel, &adj_mode);
 	if (rc) {
-		DSI_ERR("[%s] panel mode validation failed, rc=%d\n",
+		printk("[%s] panel mode validation failed, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
@@ -6683,14 +6924,14 @@
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_validate_timing(ctrl->ctrl, &adj_mode.timing);
 		if (rc) {
-			DSI_ERR("[%s] ctrl mode validation failed, rc=%d\n",
+			printk("[%s] ctrl mode validation failed, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
 
 		rc = dsi_phy_validate_mode(ctrl->phy, &adj_mode.timing);
 		if (rc) {
-			DSI_ERR("[%s] phy mode validation failed, rc=%d\n",
+			printk("[%s] phy mode validation failed, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
@@ -6700,7 +6941,7 @@
 			(mode->dsi_mode_flags & DSI_MODE_FLAG_SEAMLESS)) {
 		rc = dsi_display_validate_mode_seamless(display, mode);
 		if (rc) {
-			DSI_ERR("[%s] seamless not possible rc=%d\n",
+			printk("[%s] seamless not possible rc=%d\n",
 				display->name, rc);
 			goto error;
 		}
@@ -6719,8 +6960,9 @@
 	struct dsi_display_mode adj_mode;
 	struct dsi_mode_info timing;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !mode || !display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -6745,13 +6987,13 @@
 
 	rc = dsi_display_validate_mode_set(display, &adj_mode, flags);
 	if (rc) {
-		DSI_ERR("[%s] mode cannot be set\n", display->name);
+		printk("[%s] mode cannot be set\n", display->name);
 		goto error;
 	}
 
 	rc = dsi_display_set_mode_sub(display, &adj_mode, flags);
 	if (rc) {
-		DSI_ERR("[%s] failed to set mode\n", display->name);
+		printk("[%s] failed to set mode\n", display->name);
 		goto error;
 	}
 
@@ -6773,8 +7015,9 @@
 	int i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -6782,7 +7025,7 @@
 		ctrl = &display->ctrl[i];
 		rc = dsi_ctrl_set_tpg_state(ctrl->ctrl, enable);
 		if (rc) {
-			DSI_ERR("[%s] failed to set tpg state for host_%d\n",
+			printk("[%s] failed to set tpg state for host_%d\n",
 			       display->name, i);
 			goto error;
 		}
@@ -6797,24 +7040,25 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto error;
 	}
 
 	rc = dsi_display_ctrl_update(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to update DSI controller, rc=%d\n",
+		printk("[%s] failed to update DSI controller, rc=%d\n",
 			   display->name, rc);
 		goto error_ctrl_clk_off;
 	}
 
 	rc = dsi_display_set_clk_src(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to set DSI link clock source, rc=%d\n",
+		printk("[%s] failed to set DSI link clock source, rc=%d\n",
 			display->name, rc);
 		goto error_ctrl_deinit;
 	}
@@ -6822,7 +7066,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_LINK_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI link clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI link clocks, rc=%d\n",
 			   display->name, rc);
 		goto error_ctrl_deinit;
 	}
@@ -6861,7 +7105,7 @@
 	display = container_of(work, struct dsi_display, fifo_underflow_work);
 	if (!display || !display->panel ||
 	    atomic_read(&display->panel->esd_recovery_pending)) {
-		DSI_DEBUG("Invalid recovery use case\n");
+		printk("Invalid recovery use case\n");
 		return;
 	}
 
@@ -6872,7 +7116,7 @@
 		return;
 	}
 
-	DSI_DEBUG("handle DSI FIFO underflow error\n");
+	printk("handle DSI FIFO underflow error\n");
 
 	dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_ON);
@@ -6900,7 +7144,7 @@
 	if (!display || !display->panel ||
 	    (display->panel->panel_mode != DSI_OP_VIDEO_MODE) ||
 	    atomic_read(&display->panel->esd_recovery_pending)) {
-		DSI_DEBUG("Invalid recovery use case\n");
+		printk("Invalid recovery use case\n");
 		return;
 	}
 
@@ -6911,7 +7155,7 @@
 		return;
 	}
 
-	DSI_DEBUG("handle DSI FIFO overflow error\n");
+	printk("handle DSI FIFO overflow error\n");
 	dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_ON);
 
@@ -6939,7 +7183,7 @@
 		rc = cb_func(data, SDE_CONN_EVENT_VID_FIFO_OVERFLOW,
 				display->clk_master_idx, 0, 0, 0, 0);
 		if (rc < 0) {
-			DSI_DEBUG("sde callback failed\n");
+			printk("sde callback failed\n");
 			goto end;
 		}
 	}
@@ -6977,7 +7221,7 @@
 	if (!display || !display->panel ||
 	    (display->panel->panel_mode != DSI_OP_VIDEO_MODE) ||
 	    atomic_read(&display->panel->esd_recovery_pending)) {
-		DSI_DEBUG("Invalid recovery use case\n");
+		printk("Invalid recovery use case\n");
 		return;
 	}
 
@@ -6988,7 +7232,7 @@
 		return;
 	}
 
-	DSI_DEBUG("handle DSI LP RX Timeout error\n");
+	printk("handle DSI LP RX Timeout error\n");
 
 	dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_ON);
@@ -7016,7 +7260,7 @@
 		rc = cb_func(data, SDE_CONN_EVENT_VID_FIFO_OVERFLOW,
 				display->clk_master_idx, 0, 0, 0, 0);
 		if (rc < 0) {
-			DSI_DEBUG("Target is in suspend/shutdown\n");
+			printk("Target is in suspend/shutdown\n");
 			goto end;
 		}
 	}
@@ -7077,7 +7321,7 @@
 
 	display->err_workq = create_singlethread_workqueue("dsi_err_workq");
 	if (!display->err_workq) {
-		DSI_ERR("failed to create dsi workq!\n");
+		printk("failed to create dsi workq!\n");
 		return;
 	}
 
@@ -7124,13 +7368,14 @@
 	int rc = 0;
 	struct dsi_display_mode *mode;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!display->panel->cur_mode) {
-		DSI_ERR("no valid mode set for the display\n");
+		printk("no valid mode set for the display\n");
 		return -EINVAL;
 	}
 
@@ -7147,7 +7392,7 @@
 	if (mode->dsi_mode_flags & DSI_MODE_FLAG_DMS) {
 		if (display->is_cont_splash_enabled &&
 		    display->config.panel_mode == DSI_OP_VIDEO_MODE) {
-			DSI_ERR("DMS not supported on first frame\n");
+			printk("DMS not supported on first frame\n");
 			rc = -EINVAL;
 			goto error;
 		}
@@ -7156,7 +7401,7 @@
 			/* update dsi ctrl for new mode */
 			rc = dsi_display_pre_switch(display);
 			if (rc)
-				DSI_ERR("[%s] panel pre-switch failed, rc=%d\n",
+				printk("[%s] panel pre-switch failed, rc=%d\n",
 					display->name, rc);
 			goto error;
 		}
@@ -7171,7 +7416,7 @@
 		 */
 		rc = dsi_panel_pre_prepare(display->panel);
 		if (rc) {
-			DSI_ERR("[%s] panel pre-prepare failed, rc=%d\n",
+			printk("[%s] panel pre-prepare failed, rc=%d\n",
 					display->name, rc);
 			goto error;
 		}
@@ -7180,7 +7425,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI core clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI core clocks, rc=%d\n",
 		       display->name, rc);
 		goto error_panel_post_unprep;
 	}
@@ -7195,14 +7440,14 @@
 	if (!display->panel->ulps_suspend_enabled || !display->ulps_enabled) {
 		rc = dsi_display_phy_sw_reset(display);
 		if (rc) {
-			DSI_ERR("[%s] failed to reset phy, rc=%d\n",
+			printk("[%s] failed to reset phy, rc=%d\n",
 				display->name, rc);
 			goto error_ctrl_clk_off;
 		}
 
 		rc = dsi_display_phy_enable(display);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable DSI PHY, rc=%d\n",
+			printk("[%s] failed to enable DSI PHY, rc=%d\n",
 			       display->name, rc);
 			goto error_ctrl_clk_off;
 		}
@@ -7210,14 +7455,14 @@
 
 	rc = dsi_display_set_clk_src(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to set DSI link clock source, rc=%d\n",
+		printk("[%s] failed to set DSI link clock source, rc=%d\n",
 			display->name, rc);
 		goto error_phy_disable;
 	}
 
 	rc = dsi_display_ctrl_init(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to setup DSI controller, rc=%d\n",
+		printk("[%s] failed to setup DSI controller, rc=%d\n",
 		       display->name, rc);
 		goto error_phy_disable;
 	}
@@ -7226,7 +7471,7 @@
 
 	rc = dsi_display_ctrl_host_enable(display);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI host, rc=%d\n",
+		printk("[%s] failed to enable DSI host, rc=%d\n",
 		       display->name, rc);
 		goto error_ctrl_deinit;
 	}
@@ -7234,7 +7479,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_LINK_CLK, DSI_CLK_ON);
 	if (rc) {
-		DSI_ERR("[%s] failed to enable DSI link clocks, rc=%d\n",
+		printk("[%s] failed to enable DSI link clocks, rc=%d\n",
 		       display->name, rc);
 		goto error_host_engine_off;
 	}
@@ -7247,7 +7492,7 @@
 		 */
 		rc = dsi_display_soft_reset(display);
 		if (rc) {
-			DSI_ERR("[%s] failed soft reset, rc=%d\n",
+			printk("[%s] failed soft reset, rc=%d\n",
 					display->name, rc);
 			goto error_ctrl_link_off;
 		}
@@ -7255,7 +7500,7 @@
 		if (!(mode->dsi_mode_flags & DSI_MODE_FLAG_POMS)) {
 			rc = dsi_panel_prepare(display->panel);
 			if (rc) {
-				DSI_ERR("[%s] panel prepare failed, rc=%d\n",
+				printk("[%s] panel prepare failed, rc=%d\n",
 						display->name, rc);
 				goto error_ctrl_link_off;
 			}
@@ -7280,6 +7525,7 @@
 error:
 	mutex_unlock(&display->display_lock);
 	SDE_EVT32(SDE_EVTLOG_FUNC_EXIT);
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -7294,13 +7540,14 @@
 	struct dsi_rect req_roi = { 0 };
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	cur_mode = display->panel->cur_mode;
 	if (!cur_mode)
 		return 0;
 
 	roi_caps = &cur_mode->priv_info->roi_caps;
 	if (req_rois->num_rects > roi_caps->num_roi) {
-		DSI_ERR("request for %d rois greater than max %d\n",
+		printk("request for %d rois greater than max %d\n",
 				req_rois->num_rects,
 				roi_caps->num_roi);
 		rc = -EINVAL;
@@ -7327,7 +7574,7 @@
 	/* adjust the ctrl origin to be top left within the ctrl */
 	out_roi->x = out_roi->x - bounds->x;
 
-	DSI_DEBUG("ctrl%d:%d: req (%d,%d,%d,%d) bnd (%d,%d,%d,%d) out (%d,%d,%d,%d)\n",
+	printk("ctrl%d:%d: req (%d,%d,%d,%d) bnd (%d,%d,%d,%d) out (%d,%d,%d,%d)\n",
 			ctrl->dsi_ctrl_idx, ctrl->ctrl->cell_index,
 			req_roi.x, req_roi.y, req_roi.w, req_roi.h,
 			bounds->x, bounds->y, bounds->w, bounds->h,
@@ -7342,10 +7589,11 @@
 	int rc = 0;
 
 	if (!display->panel->qsync_min_fps) {
-		DSI_ERR("%s:ERROR: qsync set, but no fps\n", __func__);
+		printk("%s:ERROR: qsync set, but no fps\n", __func__);
 		return 0;
 	}
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	mutex_lock(&display->display_lock);
 
 	display_for_each_ctrl(i, display) {
@@ -7353,14 +7601,14 @@
 			/* send the commands to enable qsync */
 			rc = dsi_panel_send_qsync_on_dcs(display->panel, i);
 			if (rc) {
-				DSI_ERR("fail qsync ON cmds rc:%d\n", rc);
+				printk("fail qsync ON cmds rc:%d\n", rc);
 				goto exit;
 			}
 		} else {
 			/* send the commands to enable qsync */
 			rc = dsi_panel_send_qsync_off_dcs(display->panel, i);
 			if (rc) {
-				DSI_ERR("fail qsync OFF cmds rc:%d\n", rc);
+				printk("fail qsync OFF cmds rc:%d\n", rc);
 				goto exit;
 			}
 		}
@@ -7382,6 +7630,7 @@
 	int rc = 0;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !rois || !display->panel)
 		return -EINVAL;
 
@@ -7400,13 +7649,13 @@
 
 		rc = dsi_display_calc_ctrl_roi(display, ctrl, rois, &ctrl_roi);
 		if (rc) {
-			DSI_ERR("dsi_display_calc_ctrl_roi failed rc %d\n", rc);
+			printk("dsi_display_calc_ctrl_roi failed rc %d\n", rc);
 			return rc;
 		}
 
 		rc = dsi_ctrl_set_roi(ctrl->ctrl, &ctrl_roi, &changed);
 		if (rc) {
-			DSI_ERR("dsi_ctrl_set_roi failed rc %d\n", rc);
+			printk("dsi_ctrl_set_roi failed rc %d\n", rc);
 			return rc;
 		}
 
@@ -7416,14 +7665,14 @@
 		/* send the new roi to the panel via dcs commands */
 		rc = dsi_panel_send_roi_dcs(display->panel, i, &ctrl_roi);
 		if (rc) {
-			DSI_ERR("dsi_panel_set_roi failed rc %d\n", rc);
+			printk("dsi_panel_set_roi failed rc %d\n", rc);
 			return rc;
 		}
 
 		/* re-program the ctrl with the timing based on the new roi */
 		rc = dsi_ctrl_timing_setup(ctrl->ctrl);
 		if (rc) {
-			DSI_ERR("dsi_ctrl_setup failed rc %d\n", rc);
+			printk("dsi_ctrl_setup failed rc %d\n", rc);
 			return rc;
 		}
 	}
@@ -7438,6 +7687,7 @@
 	int rc = 0;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	/* check and setup MISR */
 	if (display->misr_enable)
 		_dsi_display_setup_misr(display);
@@ -7486,13 +7736,14 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!display->panel->cur_mode) {
-		DSI_ERR("no valid mode set for the display\n");
+		printk("no valid mode set for the display\n");
 		return -EINVAL;
 	}
 
@@ -7502,19 +7753,19 @@
 	if (display->config.panel_mode == DSI_OP_VIDEO_MODE) {
 		rc = dsi_display_vid_engine_enable(display);
 		if (rc) {
-			DSI_ERR("[%s]failed to enable DSI video engine, rc=%d\n",
+			printk("[%s]failed to enable DSI video engine, rc=%d\n",
 			       display->name, rc);
 			goto error_out;
 		}
 	} else if (display->config.panel_mode == DSI_OP_CMD_MODE) {
 		rc = dsi_display_cmd_engine_enable(display);
 		if (rc) {
-			DSI_ERR("[%s]failed to enable DSI cmd engine, rc=%d\n",
+			printk("[%s]failed to enable DSI cmd engine, rc=%d\n",
 			       display->name, rc);
 			goto error_out;
 		}
 	} else {
-		DSI_ERR("[%s] Invalid configuration\n", display->name);
+		printk("[%s] Invalid configuration\n", display->name);
 		rc = -EINVAL;
 	}
 
@@ -7550,13 +7801,14 @@
 	int rc = 0;
 	struct dsi_display_mode *mode;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display || !display->panel) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
 	if (!display->panel->cur_mode) {
-		DSI_ERR("no valid mode set for the display\n");
+		printk("no valid mode set for the display\n");
 		return -EINVAL;
 	}
 	SDE_EVT32(SDE_EVTLOG_FUNC_ENTRY);
@@ -7570,13 +7822,13 @@
 
 		rc = dsi_display_splash_res_cleanup(display);
 		if (rc) {
-			DSI_ERR("Continuous splash res cleanup failed, rc=%d\n",
+			printk("Continuous splash res cleanup failed, rc=%d\n",
 				rc);
 			return -EINVAL;
 		}
 
 		display->panel->panel_initialized = true;
-		DSI_DEBUG("cont splash enabled, display enable not required\n");
+		printk("cont splash enabled, display enable not required\n");
 		return 0;
 	}
 
@@ -7587,7 +7839,7 @@
 	if (mode->dsi_mode_flags & DSI_MODE_FLAG_DMS) {
 		rc = dsi_panel_post_switch(display->panel);
 		if (rc) {
-			DSI_ERR("[%s] failed to switch DSI panel mode, rc=%d\n",
+			printk("[%s] failed to switch DSI panel mode, rc=%d\n",
 				   display->name, rc);
 			goto error;
 		}
@@ -7595,7 +7847,7 @@
 			DSI_MODE_FLAG_POMS)){
 		rc = dsi_panel_enable(display->panel);
 		if (rc) {
-			DSI_ERR("[%s] failed to enable DSI panel, rc=%d\n",
+			printk("[%s] failed to enable DSI panel, rc=%d\n",
 			       display->name, rc);
 			goto error;
 		}
@@ -7607,7 +7859,7 @@
 		mode->priv_info->dsc.pic_width *= display->ctrl_count;
 		rc = dsi_panel_update_pps(display->panel);
 		if (rc) {
-			DSI_ERR("[%s] panel pps cmd update failed, rc=%d\n",
+			printk("[%s] panel pps cmd update failed, rc=%d\n",
 				display->name, rc);
 			goto error;
 		}
@@ -7616,30 +7868,30 @@
 	if (mode->dsi_mode_flags & DSI_MODE_FLAG_DMS) {
 		rc = dsi_panel_switch(display->panel);
 		if (rc)
-			DSI_ERR("[%s] failed to switch DSI panel mode, rc=%d\n",
+			printk("[%s] failed to switch DSI panel mode, rc=%d\n",
 				   display->name, rc);
 
 		goto error;
 	}
 
 	if (display->config.panel_mode == DSI_OP_VIDEO_MODE) {
-		DSI_DEBUG("%s:enable video timing eng\n", __func__);
+		printk("%s:enable video timing eng\n", __func__);
 		rc = dsi_display_vid_engine_enable(display);
 		if (rc) {
-			DSI_ERR("[%s]failed to enable DSI video engine, rc=%d\n",
+			printk("[%s]failed to enable DSI video engine, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_panel;
 		}
 	} else if (display->config.panel_mode == DSI_OP_CMD_MODE) {
-		DSI_DEBUG("%s:enable command timing eng\n", __func__);
+		printk("%s:enable command timing eng\n", __func__);
 		rc = dsi_display_cmd_engine_enable(display);
 		if (rc) {
-			DSI_ERR("[%s]failed to enable DSI cmd engine, rc=%d\n",
+			printk("[%s]failed to enable DSI cmd engine, rc=%d\n",
 			       display->name, rc);
 			goto error_disable_panel;
 		}
 	} else {
-		DSI_ERR("[%s] Invalid configuration\n", display->name);
+		printk("[%s] Invalid configuration\n", display->name);
 		rc = -EINVAL;
 		goto error_disable_panel;
 	}
@@ -7651,6 +7903,7 @@
 error:
 	mutex_unlock(&display->display_lock);
 	SDE_EVT32(SDE_EVTLOG_FUNC_EXIT);
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	return rc;
 }
 
@@ -7658,8 +7911,10 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -7674,7 +7929,7 @@
 	} else {
 		rc = dsi_panel_post_enable(display->panel);
 		if (rc)
-			DSI_ERR("[%s] panel post-enable failed, rc=%d\n",
+			printk("[%s] panel post-enable failed, rc=%d\n",
 				display->name, rc);
 	}
 
@@ -7691,8 +7946,9 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -7714,14 +7970,14 @@
 			rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 					DSI_ALL_CLKS, DSI_CLK_ON);
 			if (rc) {
-				DSI_ERR("[%s]failed to enable all clocks,rc=%d",
+				printk("[%s]failed to enable all clocks,rc=%d",
 						display->name, rc);
 				goto exit;
 			}
 
 			rc = dsi_display_cmd_engine_enable(display);
 			if (rc) {
-				DSI_ERR("[%s]failed to enable cmd engine,rc=%d",
+				printk("[%s]failed to enable cmd engine,rc=%d",
 						display->name, rc);
 				goto error_disable_clks;
 			}
@@ -7731,7 +7987,7 @@
 	} else {
 		rc = dsi_panel_pre_disable(display->panel);
 		if (rc)
-			DSI_ERR("[%s] panel pre-disable failed, rc=%d\n",
+			printk("[%s] panel pre-disable failed, rc=%d\n",
 				display->name, rc);
 	}
 	goto exit;
@@ -7740,7 +7996,7 @@
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_ALL_CLKS, DSI_CLK_OFF);
 	if (rc)
-		DSI_ERR("[%s] failed to disable all DSI clocks, rc=%d\n",
+		printk("[%s] failed to disable all DSI clocks, rc=%d\n",
 		       display->name, rc);
 
 exit:
@@ -7752,8 +8008,9 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -7762,28 +8019,28 @@
 
 	rc = dsi_display_wake_up(display);
 	if (rc)
-		DSI_ERR("[%s] display wake up failed, rc=%d\n",
+		printk("[%s] display wake up failed, rc=%d\n",
 		       display->name, rc);
 
 	if (display->config.panel_mode == DSI_OP_VIDEO_MODE) {
 		rc = dsi_display_vid_engine_disable(display);
 		if (rc)
-			DSI_ERR("[%s]failed to disable DSI vid engine, rc=%d\n",
+			printk("[%s]failed to disable DSI vid engine, rc=%d\n",
 			       display->name, rc);
 	} else if (display->config.panel_mode == DSI_OP_CMD_MODE) {
 		rc = dsi_display_cmd_engine_disable(display);
 		if (rc)
-			DSI_ERR("[%s]failed to disable DSI cmd engine, rc=%d\n",
+			printk("[%s]failed to disable DSI cmd engine, rc=%d\n",
 			       display->name, rc);
 	} else {
-		DSI_ERR("[%s] Invalid configuration\n", display->name);
+		printk("[%s] Invalid configuration\n", display->name);
 		rc = -EINVAL;
 	}
 
 	if (!display->poms_pending) {
 		rc = dsi_panel_disable(display->panel);
 		if (rc)
-			DSI_ERR("[%s] failed to disable DSI panel, rc=%d\n",
+			printk("[%s] failed to disable DSI panel, rc=%d\n",
 				display->name, rc);
 	}
 	mutex_unlock(&display->display_lock);
@@ -7796,7 +8053,7 @@
 	struct dsi_display *display;
 
 	if (pps_cmd == NULL || disp == NULL) {
-		DSI_ERR("Invalid parameter\n");
+		printk("Invalid parameter\n");
 		return -EINVAL;
 	}
 
@@ -7813,8 +8070,9 @@
 	int rc = 0, i;
 	struct dsi_display_ctrl *ctrl;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!display) {
-		DSI_ERR("Invalid params\n");
+		printk("Invalid params\n");
 		return -EINVAL;
 	}
 
@@ -7823,12 +8081,12 @@
 
 	rc = dsi_display_wake_up(display);
 	if (rc)
-		DSI_ERR("[%s] display wake up failed, rc=%d\n",
+		printk("[%s] display wake up failed, rc=%d\n",
 		       display->name, rc);
 	if (!display->poms_pending) {
 		rc = dsi_panel_unprepare(display->panel);
 		if (rc)
-			DSI_ERR("[%s] panel unprepare failed, rc=%d\n",
+			printk("[%s] panel unprepare failed, rc=%d\n",
 			       display->name, rc);
 	}
 
@@ -7851,31 +8109,31 @@
 
 	rc = dsi_display_ctrl_host_disable(display);
 	if (rc)
-		DSI_ERR("[%s] failed to disable DSI host, rc=%d\n",
+		printk("[%s] failed to disable DSI host, rc=%d\n",
 		       display->name, rc);
 
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_LINK_CLK, DSI_CLK_OFF);
 	if (rc)
-		DSI_ERR("[%s] failed to disable Link clocks, rc=%d\n",
+		printk("[%s] failed to disable Link clocks, rc=%d\n",
 		       display->name, rc);
 
 	rc = dsi_display_ctrl_deinit(display);
 	if (rc)
-		DSI_ERR("[%s] failed to deinit controller, rc=%d\n",
+		printk("[%s] failed to deinit controller, rc=%d\n",
 		       display->name, rc);
 
 	if (!display->panel->ulps_suspend_enabled) {
 		rc = dsi_display_phy_disable(display);
 		if (rc)
-			DSI_ERR("[%s] failed to disable DSI PHY, rc=%d\n",
+			printk("[%s] failed to disable DSI PHY, rc=%d\n",
 			       display->name, rc);
 	}
 
 	rc = dsi_display_clk_ctrl(display->dsi_clk_handle,
 			DSI_CORE_CLK, DSI_CLK_OFF);
 	if (rc)
-		DSI_ERR("[%s] failed to disable DSI clocks, rc=%d\n",
+		printk("[%s] failed to disable DSI clocks, rc=%d\n",
 		       display->name, rc);
 
 	/* destrory dsi isr set up */
@@ -7884,7 +8142,7 @@
 	if (!display->poms_pending) {
 		rc = dsi_panel_post_unprepare(display->panel);
 		if (rc)
-			DSI_ERR("[%s] panel post-unprepare failed, rc=%d\n",
+			printk("[%s] panel post-unprepare failed, rc=%d\n",
 			       display->name, rc);
 	}
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_display.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_display_test.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_display_test.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_drm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_drm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_hw.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_panel.c kernel/msm-4.19/techpack/display/msm/dsi/dsi_panel.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_panel.c	2024-05-28 21:11:35.867595196 -0400
+++ kernel/msm-4.19/techpack/display/msm/dsi/dsi_panel.c	2024-05-29 22:10:12.777804456 -0400
@@ -215,24 +215,26 @@
 	int i;
 	struct regulator *vreg = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	for (i = 0; i < panel->power_info.count; i++) {
-		vreg = devm_regulator_get(panel->parent,
-					  panel->power_info.vregs[i].vreg_name);
+		vreg = devm_regulator_get(panel->parent, panel->power_info.vregs[i].vreg_name);
 		rc = PTR_RET(vreg);
 		if (rc) {
-			DSI_ERR("failed to get %s regulator\n",
-			       panel->power_info.vregs[i].vreg_name);
+			printk("%s:%d, ACHEUL, error: failed to get %s regulator, rc: %d", __FUNCTION__, __LINE__, panel->power_info.vregs[i].vreg_name, rc);
 			goto error_put;
 		}
 		panel->power_info.vregs[i].vreg = vreg;
 	}
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 error_put:
 	for (i = i - 1; i >= 0; i--) {
 		devm_regulator_put(panel->power_info.vregs[i].vreg);
 		panel->power_info.vregs[i].vreg = NULL;
 	}
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -861,6 +863,8 @@
 	struct dsi_display_mode *display_mode;
 	struct dsi_display_mode_priv_info *priv_info;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	display_mode = container_of(mode, struct dsi_display_mode, timing);
 
 	priv_info = display_mode->priv_info;
@@ -887,6 +891,9 @@
 	rc = utils->read_u32(utils->data,
 				"qcom,mdss-dsi-panel-framerate",
 				&mode->refresh_rate);
+
+    printk("%s:%d, ACHEUL, frame rate: %d", __FUNCTION__, __LINE__, mode->refresh_rate);
+
 	if (rc) {
 		DSI_ERR("failed to read qcom,mdss-dsi-panel-framerate, rc=%d\n",
 		       rc);
@@ -895,6 +902,9 @@
 
 	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-panel-width",
 				  &mode->h_active);
+
+    printk("%s:%d, ACHEUL, h_active: %d", __FUNCTION__, __LINE__, mode->h_active);
+
 	if (rc) {
 		DSI_ERR("failed to read qcom,mdss-dsi-panel-width, rc=%d\n",
 				rc);
@@ -940,6 +950,8 @@
 
 	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-panel-height",
 				  &mode->v_active);
+    printk("%s:%d, ACHEUL, v_active: %d", __FUNCTION__, __LINE__, mode->v_active);
+
 	if (rc) {
 		DSI_ERR("failed to read qcom,mdss-dsi-panel-height, rc=%d\n",
 		       rc);
@@ -1064,6 +1076,8 @@
 
 	host->num_data_lanes = num_of_lanes;
 
+    printk("%s:%d, ACHEUL, num lanes: %d", __FUNCTION__, __LINE__, num_of_lanes);
+
 	if (host->data_lanes == 0) {
 		DSI_ERR("[%s] No data lanes are enabled, rc=%d\n", name, rc);
 		rc = -EINVAL;
@@ -1116,6 +1130,8 @@
 	const char *trig;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	trig = utils->get_property(utils->data,
 			"qcom,mdss-dsi-mdp-trigger", NULL);
 	if (trig) {
@@ -1171,6 +1187,7 @@
 		rc = 0;
 	}
 
+    printk("%s:%d, ACHEUL, ret: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -2115,6 +2132,8 @@
 	int rc = 0;
 	char *supply_name;
 
+    printk("%s: %d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (panel->host_config.ext_bridge_mode)
 		return 0;
 
@@ -2123,6 +2142,8 @@
 	else
 		supply_name = "qcom,panel-sec-supply-entries";
 
+    printk("%s: %d, ACHEUL supply name: %s, panel type: %s", __FUNCTION__, __LINE__, supply_name, panel->type);
+
 	rc = dsi_pwr_of_get_vreg_data(&panel->utils,
 			&panel->power_info, supply_name);
 	if (rc) {
@@ -2131,6 +2152,7 @@
 	}
 
 error:
+    printk("%s: %d, ACHEUL ret: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -3059,6 +3081,8 @@
 	struct property *data;
 	struct dsi_parser_utils *utils = &panel->utils;
 
+    printk("%s:%d, ACHEUL in", __FUNCTION__, __LINE__);
+
 	if (!panel) {
 		DSI_ERR("Invalid Params\n");
 		return -EINVAL;
@@ -3155,6 +3179,7 @@
 				esd_config->groups * status_len);
 	}
 
+    printk("%s:%d, ACHEUL OK", __FUNCTION__, __LINE__);
 	return 0;
 
 error4:
@@ -3167,6 +3192,7 @@
 error1:
 	kfree(esd_config->status_cmd.cmds);
 error:
+    printk("%s:%d, ACHEUL error: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -3266,6 +3292,8 @@
 	const char *panel_physical_type;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	panel = kzalloc(sizeof(*panel), GFP_KERNEL);
 	if (!panel)
 		return ERR_PTR(-ENOMEM);
@@ -3378,8 +3406,10 @@
 
 	mutex_init(&panel->panel_lock);
 
+    printk("%s:%d, ACHEUL ret: OK", __FUNCTION__, __LINE__);
 	return panel;
 error:
+    printk("%s:%d, ACHEUL ret: %d", __FUNCTION__, __LINE__, rc);
 	kfree(panel);
 	return ERR_PTR(rc);
 }
@@ -3400,6 +3430,8 @@
 	int rc = 0;
 	struct mipi_dsi_device *dev;
 
+    printk("%s:%d, ACHEUL, panel name: %s", __FUNCTION__, __LINE__, panel->name);
+
 	if (!panel || !host) {
 		DSI_ERR("invalid params\n");
 		return -EINVAL;
@@ -3458,6 +3490,8 @@
 	(void)dsi_panel_vreg_put(panel);
 exit:
 	mutex_unlock(&panel->panel_lock);
+
+    printk("%s:%d, ACHEUL, panel name: %s, ret: %d", __FUNCTION__, __LINE__, panel->name, rc);
 	return rc;
 }
 
@@ -3514,6 +3548,8 @@
 	int count, rc = 0;
 	void *utils_data = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!panel) {
 		DSI_ERR("invalid params\n");
 		return -EINVAL;
@@ -3550,15 +3586,24 @@
 	panel->num_timing_nodes = count;
 	dsi_for_each_child_node(timings_np, child_np) {
 		utils_data = child_np;
-		if (utils->read_bool(utils->data, "qcom,mdss-dsi-video-mode"))
-			num_video_modes++;
-		else if (utils->read_bool(utils->data,
-					"qcom,mdss-dsi-cmd-mode"))
+		if (utils->read_bool(utils->data, "qcom,mdss-dsi-video-mode")){
+
+        }
+		else if (utils->read_bool(utils->data, "qcom,mdss-dsi-cmd-mode")){
+            printk("%s:%d, ACHEUL num_cmd_modes", __FUNCTION__, __LINE__);
 			num_cmd_modes++;
-		else if (panel->panel_mode == DSI_OP_VIDEO_MODE)
+        }
+		else if (panel->panel_mode == DSI_OP_VIDEO_MODE){
+            printk("%s:%d, ACHEUL DSI_OP_VIDEO_MODE", __FUNCTION__, __LINE__);
 			num_video_modes++;
-		else if (panel->panel_mode == DSI_OP_CMD_MODE)
+        }
+		else if (panel->panel_mode == DSI_OP_CMD_MODE){
+            printk("%s:%d, ACHEUL DSI_OP_CMD_MODE", __FUNCTION__, __LINE__);
 			num_cmd_modes++;
+        }
+        else {
+            printk("%s:%d, ACHEUL, no mode", __FUNCTION__, __LINE__);
+        }
 	}
 
 	num_dfps_rates = !panel->dfps_caps.dfps_support ? 1 :
@@ -3572,6 +3617,7 @@
 			(num_video_modes * num_bit_clks * num_dfps_rates);
 
 error:
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -3844,6 +3890,8 @@
 	int rc = 0;
 	struct dsi_dyn_clk_caps *dyn_clk_caps = &panel->dyn_clk_caps;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!panel || !mode || !config) {
 		DSI_ERR("invalid params\n");
 		return -EINVAL;
@@ -3877,6 +3925,7 @@
 
 	config->esc_clk_rate_hz = 19200000;
 	mutex_unlock(&panel->panel_lock);
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_panel.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_parser.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_parser.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_hw.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_hw_v2_0.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_hw_v3_0.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_hw_v4_0.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_timing_calc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_timing_calc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_timing_v2_0.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_timing_v3_0.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_phy_timing_v4_0.c
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_pwr.c kernel/msm-4.19/techpack/display/msm/dsi/dsi_pwr.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi/dsi_pwr.c	2024-05-28 21:11:35.871595239 -0400
+++ kernel/msm-4.19/techpack/display/msm/dsi/dsi_pwr.c	2024-05-29 22:10:12.789804561 -0400
@@ -129,6 +129,8 @@
 	u32 pre_on_ms, post_on_ms;
 	u32 pre_off_ms, post_off_ms;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (enable) {
 		for (i = 0; i < regs->count; i++) {
 			vreg = &regs->vregs[i];
@@ -152,8 +154,8 @@
 							   vreg->min_voltage,
 							   vreg->max_voltage);
 				if (rc) {
-					DSI_ERR("Set voltage(%s) fail, rc=%d\n",
-						 vreg->vreg_name, rc);
+					DSI_ERR("Set voltage(%s) fail, rc=%d, min: %d, max, %d\n",
+						 vreg->vreg_name, rc, vreg->min_voltage,  vreg->max_voltage);
 					goto error_disable_opt_mode;
 				}
 			}
@@ -228,6 +230,7 @@
 					(post_off_ms * 1000) + 10);
 	}
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -251,6 +254,8 @@
 		return -EINVAL;
 	}
 
+    printk("%s:%d, ACHEUL supply name: %s", __FUNCTION__, __LINE__, supply_name);
+
 	regs->count = 0;
 	supply_root_node = utils->get_child_by_name(utils->data, supply_name);
 	if (!supply_root_node) {
@@ -259,6 +264,7 @@
 		if (!supply_root_node) {
 			DSI_DEBUG("No supply entry present for %s\n",
 					supply_name);
+            printk("%s:%d, ACHEUL error, no supply root node", __FUNCTION__, __LINE__);
 			return -EINVAL;
 		}
 	}
@@ -266,12 +272,14 @@
 	regs->count = utils->get_available_child_count(supply_root_node);
 	if (regs->count == 0) {
 		DSI_ERR("No vregs defined for %s\n", supply_name);
+        printk("%s:%d, ACHEUL error, no vregs defined", __FUNCTION__, __LINE__);
 		return -EINVAL;
 	}
 
 	regs->vregs = kcalloc(regs->count, sizeof(*regs->vregs), GFP_KERNEL);
 	if (!regs->vregs) {
 		regs->count = 0;
+        printk("%s:%d, ACHEUL error, mem alloc", __FUNCTION__, __LINE__);
 		return -ENOMEM;
 	}
 
@@ -285,6 +293,7 @@
 		regs->count = 0;
 	}
 
+    printk("%s:%d, ACHEUL ret: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -364,37 +373,43 @@
 {
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (regs->count == 0) {
-		DSI_DEBUG("No valid regulators to enable\n");
+        printk("%s:%d, ACHEUL, error: No valid regulators to enable", __FUNCTION__, __LINE__);
 		return 0;
 	}
 
 	if (!regs->vregs) {
-		DSI_ERR("Invalid params\n");
+        printk("%s:%d, ACHEUL, error: invalid name", __FUNCTION__, __LINE__);
 		return -EINVAL;
 	}
 
+    printk("%s:%d, ACHEUL, vreg name", __FUNCTION__, __LINE__, regs->vregs->vreg_name);
+
 	if (enable) {
 		if (regs->refcount == 0) {
 			rc = dsi_pwr_enable_vregs(regs, true);
-			if (rc)
-				DSI_ERR("failed to enable regulators\n");
+			if (rc){
+                printk("%s:%d, ACHEUL error, failed to enable regulator", __FUNCTION__, __LINE__);
+            }
 		}
 		regs->refcount++;
 	} else {
 		if (regs->refcount == 0) {
-			DSI_ERR("Unbalanced regulator off:%s\n",
-					regs->vregs->vreg_name);
+            printk("%s:%d, ACHEUL errro: Unbalanced regulator off", __FUNCTION__, __LINE__);
 		} else {
 			regs->refcount--;
 			if (regs->refcount == 0) {
 				rc = dsi_pwr_enable_vregs(regs, false);
-				if (rc)
-					DSI_ERR("failed to disable vregs\n");
+				if (rc){
+                    printk("%s:%d, ACHEUL error, failed to disable regulator", __FUNCTION__, __LINE__);
+                }
 			}
 		}
 	}
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/dsi: dsi_pwr.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: Makefile
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_atomic.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_drv.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_drv.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_fb.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_gem.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_gem.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_gem_prime.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_gem_vma.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_iommu.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_kms.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_mmu.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_notifier.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_prop.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_prop.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: msm_smmu.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_ad4.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_color_processing.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_color_processing.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_connector.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_connector.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_core_irq.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_core_irq.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_core_perf.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_core_perf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_crtc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_crtc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder_phys_cmd.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder_phys.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder_phys_vid.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_encoder_phys_wb.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_fence.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_fence.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_formats.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_formats.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_ad4.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_blk.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_blk.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_catalog.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_catalog_format.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_catalog.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_cdm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_cdm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_proc_common_v4.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_processing.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_processing_v1_7.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_processing_v1_7.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_proc_v4.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_color_proc_v4.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_ctl.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_ctl.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_ds.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_dsc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_dsc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_ds.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_dspp.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_dspp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_interrupts.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_interrupts.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_intf.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_intf.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hwio.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_lm.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_lm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_mdss.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_pingpong.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_pingpong.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_qdss.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_qdss.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_reg_dma_v1.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_reg_dma_v1_color_proc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_reg_dma_v1_color_proc.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_reg_dma_v1.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_sspp.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_sspp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_top.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_top.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_uidle.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_uidle.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_util.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_util.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_vbif.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_vbif.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_wb.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_hw_wb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_irq.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_irq.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde/sde_kms.c kernel/msm-4.19/techpack/display/msm/sde/sde_kms.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde/sde_kms.c	2024-05-28 21:11:35.883595370 -0400
+++ kernel/msm-4.19/techpack/display/msm/sde/sde_kms.c	2024-05-29 22:10:12.757804280 -0400
@@ -132,6 +132,7 @@
 	int rc;
 	void *debugfs_root;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	p = sde_hw_util_get_log_mask_ptr();
 
 	if (!sde_kms || !p)
@@ -157,6 +158,7 @@
 		debugfs_create_u32("qdss", 0600, debugfs_root,
 				(u32 *)&sde_kms->qdss_enabled);
 
+    printk("%s:%d, ACHEUL, OK", __FUNCTION__, __LINE__);
 	return 0;
 }
 
@@ -1428,6 +1430,8 @@
 	int i, max_encoders;
 	int rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!dev || !priv || !sde_kms) {
 		SDE_ERROR("invalid argument(s)\n");
 		return -EINVAL;
@@ -1436,14 +1440,26 @@
 	max_encoders = sde_kms->dsi_display_count + sde_kms->wb_display_count +
 				sde_kms->dp_display_count +
 				sde_kms->dp_stream_count;
+
+    printk("%s:%d, ACHEUL, max: %d, DSI display count: %d, wb display count: %d, dp display count: %d, dp stream count: %d ",
+            __FUNCTION__, __LINE__,
+            max_encoders,
+            sde_kms->dsi_display_count,
+            sde_kms->wb_display_count,
+            sde_kms->dp_display_count,
+            sde_kms->dp_stream_count);
+
 	if (max_encoders > ARRAY_SIZE(priv->encoders)) {
 		max_encoders = ARRAY_SIZE(priv->encoders);
 		SDE_ERROR("capping number of displays to %d", max_encoders);
 	}
 
 	/* dsi */
-	for (i = 0; i < sde_kms->dsi_display_count &&
-		priv->num_encoders < max_encoders; ++i) {
+	for (i = 0; i < sde_kms->dsi_display_count && priv->num_encoders < max_encoders; ++i) {
+
+
+        printk("%s:%d, ACHEUL DSI %d/%d", __FUNCTION__, __LINE__, i, sde_kms->dsi_display_count);
+
 		display = sde_kms->dsi_displays[i];
 		encoder = NULL;
 
@@ -1453,19 +1469,29 @@
 			SDE_ERROR("dsi get_info %d failed\n", i);
 			continue;
 		}
+        else {
+            printk("%s:%d, ACHEUL got DSI info", __FUNCTION__, __LINE__);
+        }
 
 		encoder = sde_encoder_init(dev, &info);
 		if (IS_ERR_OR_NULL(encoder)) {
 			SDE_ERROR("encoder init failed for dsi %d\n", i);
 			continue;
 		}
+        else {
+            printk("%s:%d, ACHEUL got SDE encoder init", __FUNCTION__, __LINE__);
+        }
 
 		rc = dsi_display_drm_bridge_init(display, encoder);
 		if (rc) {
+            printk("%s:%d, ACHEUL no DRM bridge init", __FUNCTION__, __LINE__);
 			SDE_ERROR("dsi bridge %d init failed, %d\n", i, rc);
 			sde_encoder_destroy(encoder);
 			continue;
 		}
+        else {
+            printk("%s:%d, ACHEUL got DRM bridge init", __FUNCTION__, __LINE__);
+        }
 
 		connector = sde_connector_init(dev,
 					encoder,
@@ -1474,10 +1500,13 @@
 					&dsi_ops,
 					DRM_CONNECTOR_POLL_HPD,
 					DRM_MODE_CONNECTOR_DSI);
+
 		if (connector) {
+            printk("%s:%d, ACHEUL got connector", __FUNCTION__, __LINE__);
 			priv->encoders[priv->num_encoders++] = encoder;
 			priv->connectors[priv->num_connectors++] = connector;
 		} else {
+            printk("%s:%d, ACHEUL no connector", __FUNCTION__, __LINE__);
 			SDE_ERROR("dsi %d connector init failed\n", i);
 			dsi_display_drm_bridge_deinit(display);
 			sde_encoder_destroy(encoder);
@@ -1487,20 +1516,25 @@
 		rc = dsi_display_drm_ext_bridge_init(display,
 					encoder, connector);
 		if (rc) {
+            printk("%s:%d, ACHEUL no DRM external bridge", __FUNCTION__, __LINE__);
 			SDE_ERROR("dsi %d ext bridge init failed\n", rc);
 			dsi_display_drm_bridge_deinit(display);
 			sde_connector_destroy(connector);
 			sde_encoder_destroy(encoder);
 		}
-	}
+        else {
+            printk("%s:%d, ACHEUL got DRM external bridge", __FUNCTION__, __LINE__);
+        }
 
+	}
 
 	/* wb */
-	for (i = 0; i < sde_kms->wb_display_count &&
-		priv->num_encoders < max_encoders; ++i) {
+	for (i = 0; i < sde_kms->wb_display_count && priv->num_encoders < max_encoders; ++i) {
 		display = sde_kms->wb_displays[i];
 		encoder = NULL;
 
+        printk("%s:%d, ACHEUL WB %d/%d", __FUNCTION__, __LINE__, i, sde_kms->wb_display_count);
+
 		memset(&info, 0x0, sizeof(info));
 		rc = sde_wb_get_info(NULL, &info, display);
 		if (rc) {
@@ -1538,13 +1572,14 @@
 		}
 	}
 	/* dp */
-	for (i = 0; i < sde_kms->dp_display_count &&
-			priv->num_encoders < max_encoders; ++i) {
+	for (i = 0; i < sde_kms->dp_display_count && priv->num_encoders < max_encoders; ++i) {
 		int idx;
 
 		display = sde_kms->dp_displays[i];
 		encoder = NULL;
 
+        printk("%s:%d, ACHEUL DP %d/%d", __FUNCTION__, __LINE__, i, sde_kms->dp_display_count);
+
 		memset(&info, 0x0, sizeof(info));
 		rc = dp_connector_get_info(NULL, &info, display);
 		if (rc) {
@@ -1602,6 +1637,7 @@
 		}
 	}
 
+    printk("%s:%d, ACHEUL, out", __FUNCTION__, __LINE__);
 	return 0;
 }
 
@@ -2489,24 +2525,29 @@
 	struct sde_connector *sde_conn = NULL;
 	struct sde_splash_display *splash_display;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!kms) {
-		SDE_ERROR("invalid kms\n");
+		printk("%s:%d, ACHEUL, invalid kms", __FUNCTION__, __LINE__);
 		return -EINVAL;
 	}
 
 	sde_kms = to_sde_kms(kms);
 	dev = sde_kms->dev;
 	if (!dev) {
+		printk("%s:%d, ACHEUL, invalid device", __FUNCTION__, __LINE__);
 		SDE_ERROR("invalid device\n");
 		return -EINVAL;
 	}
 
 	if (!sde_kms->splash_data.num_splash_regions ||
 			!sde_kms->splash_data.num_splash_displays) {
+		printk("%s:%d, ACHEUL, cont_splash feature not enabled", __FUNCTION__, __LINE__);
 		DRM_INFO("cont_splash feature not enabled\n");
 		return rc;
 	}
 
+	printk("%s:%d, ACHEUL, cont_splash enabled in %d of %d display(s)", __FUNCTION__, __LINE__, sde_kms->splash_data.num_splash_displays, sde_kms->dsi_display_count);
 	DRM_INFO("cont_splash enabled in %d of %d display(s)\n",
 				sde_kms->splash_data.num_splash_displays,
 				sde_kms->dsi_display_count);
@@ -2517,31 +2558,33 @@
 		dsi_display = (struct dsi_display *)display;
 		splash_display = &sde_kms->splash_data.splash_display[i];
 
+
+        printk("%s:%d, ACHEUL, display name[%d]: %s", __FUNCTION__, __LINE__, i, dsi_display->name);
+
 		if (!splash_display->cont_splash_enabled) {
-			SDE_DEBUG("display->name = %s splash not enabled\n",
-					dsi_display->name);
+			printk("%s:%d, ACHEUL, display->name = %s splash not enabled\n",  __FUNCTION__, __LINE__, dsi_display->name);
 			continue;
 		}
 
-		SDE_DEBUG("display->name = %s\n", dsi_display->name);
+		printk("display->name = %s\n", dsi_display->name);
 
 		if (dsi_display->bridge->base.encoder) {
 			encoder = dsi_display->bridge->base.encoder;
-			SDE_DEBUG("encoder name = %s\n", encoder->name);
+			printk("encoder name = %s\n", encoder->name);
 		}
 		memset(&info, 0x0, sizeof(info));
 		rc = dsi_display_get_info(NULL, &info, display);
 		if (rc) {
-			SDE_ERROR("dsi get_info %d failed\n", i);
+			printk("dsi get_info %d failed\n", i);
 			encoder = NULL;
 			continue;
 		}
-		SDE_DEBUG("info.is_connected = %s, info.display_type = %d\n",
+		printk("info.is_connected = %s, info.display_type = %d\n",
 			((info.is_connected) ? "true" : "false"),
 			info.display_type);
 
 		if (!encoder) {
-			SDE_ERROR("encoder not initialized\n");
+			printk("encoder not initialized\n");
 			return -EINVAL;
 		}
 
@@ -2550,7 +2593,7 @@
 		crtc = encoder->crtc;
 		splash_display->encoder =  encoder;
 
-		SDE_DEBUG("for dsi-display:%d crtc id = %d enc id =%d\n",
+		printk("for dsi-display:%d crtc id = %d enc id =%d\n",
 				i, crtc->base.id, encoder->base.id);
 
 		mutex_lock(&dev->mode_config.mutex);
@@ -2569,7 +2612,7 @@
 		drm_connector_list_iter_end(&conn_iter);
 
 		if (!connector) {
-			SDE_ERROR("connector not initialized\n");
+			printk("connector not initialized\n");
 			mutex_unlock(&dev->mode_config.mutex);
 			return -EINVAL;
 		}
@@ -2579,7 +2622,7 @@
 					dev->mode_config.max_width,
 					dev->mode_config.max_height);
 		} else {
-			SDE_ERROR("fill_modes api not defined\n");
+			printk("fill_modes api not defined\n");
 			mutex_unlock(&dev->mode_config.mutex);
 			return -EINVAL;
 		}
@@ -2590,7 +2633,7 @@
 		/* currently consider modes[0] as the preferred mode */
 		drm_mode = list_first_entry(&connector->modes,
 				struct drm_display_mode, head);
-		SDE_DEBUG("drm_mode->name = %s, id=%d, type=0x%x, flags=0x%x\n",
+		printk("drm_mode->name = %s, id=%d, type=0x%x, flags=0x%x\n",
 				drm_mode->name, drm_mode->base.id,
 				drm_mode->type, drm_mode->flags);
 
@@ -2598,7 +2641,7 @@
 		crtc->state->active = true;
 		rc = drm_atomic_set_mode_for_crtc(crtc->state, drm_mode);
 		if (rc) {
-			SDE_ERROR("Failed: set mode for crtc. rc = %d\n", rc);
+			printk("Failed: set mode for crtc. rc = %d\n", rc);
 			return rc;
 		}
 		drm_mode_copy(&crtc->state->adjusted_mode, drm_mode);
@@ -2617,11 +2660,12 @@
 		rc = _sde_kms_update_planes_for_cont_splash(sde_kms,
 				splash_display, crtc);
 		if (rc) {
-			SDE_ERROR("Failed: updating plane status rc=%d\n", rc);
+			printk("Failed: updating plane status rc=%d\n", rc);
 			return rc;
 		}
 	}
 
+    printk("%s:%d, ACHEUL, rc: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_kms.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_kms_utils.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_plane.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_plane.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_reg_dma.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_reg_dma.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde/sde_rm.c kernel/msm-4.19/techpack/display/msm/sde/sde_rm.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde/sde_rm.c	2024-05-28 21:11:35.887595414 -0400
+++ kernel/msm-4.19/techpack/display/msm/sde/sde_rm.c	2024-05-29 22:10:12.765804351 -0400
@@ -53,18 +53,25 @@
  * is SDE_CTL_CFG_VERSION_1_0_0
  */
 static const struct sde_rm_topology_def g_ctl_ver_1_top_table[] = {
-	{   SDE_RM_TOPOLOGY_NONE,                 0, 0, 0, 0, false },
-	{   SDE_RM_TOPOLOGY_SINGLEPIPE,           1, 0, 1, 1, false },
-	{   SDE_RM_TOPOLOGY_SINGLEPIPE_DSC,       1, 1, 1, 1, false },
-	{   SDE_RM_TOPOLOGY_DUALPIPE,             2, 0, 2, 1, false },
-	{   SDE_RM_TOPOLOGY_DUALPIPE_DSC,         2, 2, 2, 1, false },
-	{   SDE_RM_TOPOLOGY_DUALPIPE_3DMERGE,     2, 0, 1, 1, false },
-	{   SDE_RM_TOPOLOGY_DUALPIPE_3DMERGE_DSC, 2, 1, 1, 1, false },
-	{   SDE_RM_TOPOLOGY_DUALPIPE_DSCMERGE,    2, 2, 1, 1, false },
-	{   SDE_RM_TOPOLOGY_PPSPLIT,              1, 0, 2, 1, false },
+    {   SDE_RM_TOPOLOGY_NONE,                 0, 0, 0, 0, false },
+    {   SDE_RM_TOPOLOGY_SINGLEPIPE,           1, 0, 1, 1, false },
+    {   SDE_RM_TOPOLOGY_SINGLEPIPE_DSC,       1, 1, 1, 1, false },
+    {   SDE_RM_TOPOLOGY_DUALPIPE,             2, 0, 2, 1, false },
+    {   SDE_RM_TOPOLOGY_DUALPIPE_DSC,         2, 2, 2, 1, false },
+    {   SDE_RM_TOPOLOGY_DUALPIPE_3DMERGE,     2, 0, 1, 1, false },
+    {   SDE_RM_TOPOLOGY_DUALPIPE_3DMERGE_DSC, 2, 1, 1, 1, false },
+    {   SDE_RM_TOPOLOGY_DUALPIPE_DSCMERGE,    2, 2, 1, 1, false },
+    {   SDE_RM_TOPOLOGY_PPSPLIT,              1, 0, 2, 1, false }
+/*
+ACHEUL
+    {   SDE_RM_TOPOLOGY_QUADPIPE_3DMERGE,     4, 0, 2, 1, false },
+    {   SDE_RM_TOPOLOGY_QUADPIPE_3DMERGE_DSC, 4, 3, 2, 1, false },
+    {   SDE_RM_TOPOLOGY_QUADPIPE_DSCMERGE,    4, 4, 2, 1, false },
+    {   SDE_RM_TOPOLOGY_QUADPIPE_DSCMERGE_DUALCTL, 4, 4, 2, 2, false },
+    {   SDE_RM_TOPOLOGY_QUADPIPE_DSC4HSMERGE, 4, 4, 1, 1, false },
+*/
 };
 
-
 /**
  * struct sde_rm_requirements - Reservation requirements parameter bundle
  * @top_ctrl:  topology control preference from kernel client
@@ -1022,8 +1029,10 @@
 	int lm_count = 0;
 	int i, rc = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!reqs->topology->num_lm) {
-		SDE_DEBUG("invalid number of lm: %d\n", reqs->topology->num_lm);
+		printk("invalid number of lm: %d\n", reqs->topology->num_lm);
 		return 0;
 	}
 
@@ -1039,7 +1048,7 @@
 		lm_count = 0;
 		lm[lm_count] = iter_i.blk;
 
-		SDE_DEBUG("blk id = %d, _lm_ids[%d] = %d\n",
+		printk("blk id = %d, _lm_ids[%d] = %d\n",
 			iter_i.blk->id,
 			lm_count,
 			_lm_ids ? _lm_ids[lm_count] : -1);
@@ -1058,6 +1067,7 @@
 		/* Valid primary mixer found, find matching peers */
 		sde_rm_init_hw_iter(&iter_j, 0, SDE_HW_BLK_LM);
 
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 		while (lm_count != reqs->topology->num_lm &&
 				_sde_rm_get_hw_locked(rm, &iter_j)) {
 			if (iter_i.blk == iter_j.blk)
@@ -1070,7 +1080,7 @@
 				continue;
 
 			lm[lm_count] = iter_j.blk;
-			SDE_DEBUG("blk id = %d, _lm_ids[%d] = %d\n",
+			printk("blk id = %d, _lm_ids[%d] = %d\n",
 				iter_i.blk->id,
 				lm_count,
 				_lm_ids ? _lm_ids[lm_count] : -1);
@@ -1080,10 +1090,11 @@
 
 			++lm_count;
 		}
+        printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	}
 
 	if (lm_count != reqs->topology->num_lm) {
-		SDE_DEBUG("unable to find appropriate mixers\n");
+		printk("%s:%d, ACHEUL, unable to find appropriate mixers, found: %d, requested: %d", __FUNCTION__, __LINE__, lm_count, reqs->topology->num_lm);
 		return -ENAVAIL;
 	}
 
@@ -1106,24 +1117,35 @@
 
 	if (reqs->topology->top_name == SDE_RM_TOPOLOGY_PPSPLIT) {
 		/* reserve a free PINGPONG_SLAVE block */
+        printk("%s:%d, ACHEUL invalid avail", __FUNCTION__, __LINE__);
 		rc = -ENAVAIL;
 		sde_rm_init_hw_iter(&iter_i, 0, SDE_HW_BLK_PINGPONG);
 		while (_sde_rm_get_hw_locked(rm, &iter_i)) {
+
 			const struct sde_hw_pingpong *pp =
 					to_sde_hw_pingpong(iter_i.blk->hw);
 			const struct sde_pingpong_cfg *pp_cfg = pp->caps;
 
-			if (!(test_bit(SDE_PINGPONG_SLAVE, &pp_cfg->features)))
+            printk("%s:%d, ACHEUL testing", __FUNCTION__, __LINE__);
+
+			if (!(test_bit(SDE_PINGPONG_SLAVE, &pp_cfg->features))){
+                printk("%s:%d, ACHEUL not SDE_PINGPONG_SLAVE, skip", __FUNCTION__, __LINE__);
 				continue;
-			if (RESERVED_BY_OTHER(iter_i.blk, rsvp))
+            }
+
+			if (RESERVED_BY_OTHER(iter_i.blk, rsvp)){
+                printk("%s:%d, ACHEUL reserved by other, skip", __FUNCTION__, __LINE__);
 				continue;
+            }
 
 			iter_i.blk->rsvp_nxt = rsvp;
+            printk("%s:%d, ACHEUL found one", __FUNCTION__, __LINE__);
 			rc = 0;
 			break;
 		}
 	}
 
+    printk("%s:%d, ACHEUL, ret : %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -1484,15 +1506,17 @@
 	int ret, i;
 	u8 *hw_ids = NULL;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	/* Check if splash data provided lm_ids */
 	if (splash_display) {
 		hw_ids = splash_display->lm_ids;
 		for (i = 0; i < splash_display->lm_cnt; i++)
-			SDE_DEBUG("splash_display->lm_ids[%d] = %d\n",
+			printk("splash_display->lm_ids[%d] = %d\n",
 				i, splash_display->lm_ids[i]);
 
 		if (splash_display->lm_cnt != reqs->topology->num_lm)
-			SDE_DEBUG("Configured splash LMs != needed LM cnt\n");
+			printk("Configured splash LMs != needed LM cnt\n");
 	}
 
 	/*
@@ -1501,6 +1525,7 @@
 	 */
 	ret = _sde_rm_reserve_lms(rm, rsvp, reqs, hw_ids);
 
+    printk("%s:%d, ACHEUL, ret: %d", __FUNCTION__, __LINE__, ret);
 	return ret;
 }
 
@@ -1568,6 +1593,7 @@
 	struct sde_splash_data *splash_data;
 	int i, ret;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	priv = enc->dev->dev_private;
 	sde_kms = to_sde_kms(priv->kms);
 	splash_data = &sde_kms->splash_data;
@@ -1592,7 +1618,7 @@
 
 	ret = _sde_rm_make_lm_rsvp(rm, rsvp, reqs, splash_display);
 	if (ret) {
-		SDE_ERROR("unable to find appropriate mixers\n");
+		printk("%s:%d, ACHEUL, error: unable to find appropriate mixers", __FUNCTION__, __LINE__);
 		_sde_rm_print_rsvps_by_type(rm, SDE_HW_BLK_LM);
 		return ret;
 	}
@@ -1616,6 +1642,7 @@
 	if (ret)
 		return ret;
 
+    printk("%s:%d, ACHEUL, ret: %d", __FUNCTION__, __LINE__, ret);
 	return ret;
 }
 
@@ -1752,6 +1779,8 @@
 	const struct drm_display_mode *mode = &crtc_state->mode;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	memset(reqs, 0, sizeof(*reqs));
 
 	reqs->top_ctrl = sde_connector_get_property(conn_state,
@@ -1759,8 +1788,23 @@
 	sde_encoder_get_hw_resources(enc, &reqs->hw_res, conn_state);
 
 	for (i = 0; i < SDE_RM_TOPOLOGY_MAX; i++) {
+
+        printk("%s:%d, ACHEUL, current table[%d]: name: %d, num_lm: %d, num_comp_enc: %d, num_intf: %d",
+                __FUNCTION__, __LINE__, i,
+                rm->topology_tbl[i].top_name,
+                rm->topology_tbl[i].num_lm,
+                rm->topology_tbl[i].num_comp_enc,
+                rm->topology_tbl[i].num_intf);
+
+        printk("%s:%d, ACHEUL, display topology : num_lm: %d, num_comp_enc: %d, num_intf: %d",
+                __FUNCTION__, __LINE__, i,
+                reqs->hw_res.topology.num_lm,
+                reqs->hw_res.topology.num_enc,
+                reqs->hw_res.topology.num_intf);
+
 		if (RM_IS_TOPOLOGY_MATCH(rm->topology_tbl[i],
 					reqs->hw_res.topology)) {
+            printk("%s:%d, ACHEUL, topology found",  __FUNCTION__, __LINE__);
 			reqs->topology = &rm->topology_tbl[i];
 			break;
 		}
@@ -1805,9 +1849,9 @@
 				&rm->topology_tbl[SDE_RM_TOPOLOGY_SINGLEPIPE];
 	}
 
-	SDE_DEBUG("top_ctrl: 0x%llX num_h_tiles: %d\n", reqs->top_ctrl,
+	printk("top_ctrl: 0x%llX num_h_tiles: %d\n", reqs->top_ctrl,
 			reqs->hw_res.display_num_of_h_tiles);
-	SDE_DEBUG("num_lm: %d num_ctl: %d topology: %d split_display: %d\n",
+	printk("num_lm: %d num_ctl: %d topology: %d split_display: %d\n",
 			reqs->topology->num_lm, reqs->topology->num_ctl,
 			reqs->topology->top_name,
 			reqs->topology->needs_split_display);
@@ -1815,6 +1859,7 @@
 			reqs->top_ctrl, reqs->topology->top_name,
 			reqs->topology->num_ctl);
 
+    printk("%s:%d, ACHEUL, OK", __FUNCTION__, __LINE__);
 	return 0;
 }
 
@@ -2056,6 +2101,8 @@
 	struct sde_kms *sde_kms;
 	int ret;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!rm || !enc || !crtc_state || !conn_state) {
 		SDE_ERROR("invalid arguments\n");
 		return -EINVAL;
@@ -2072,6 +2119,7 @@
 	}
 	sde_kms = to_sde_kms(priv->kms);
 
+
 	/* Check if this is just a page-flip */
 	if (!_sde_rm_is_display_in_cont_splash(sde_kms, enc) &&
 			!drm_atomic_crtc_needs_modeset(crtc_state))
@@ -2179,6 +2227,7 @@
 	_sde_rm_print_rsvps(rm, SDE_RM_STAGE_FINAL);
 	mutex_unlock(&rm->rm_lock);
 
+    printk("%s:%d, ACHEUL, ret: %d", __FUNCTION__, __LINE__, ret);
 	return ret;
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_rm.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_trace.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_vbif.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_vbif.h
diff -ru --unidirectional-new-file /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde/sde_wb.c kernel/msm-4.19/techpack/display/msm/sde/sde_wb.c
--- /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde/sde_wb.c	2024-05-28 21:11:35.887595414 -0400
+++ kernel/msm-4.19/techpack/display/msm/sde/sde_wb.c	2024-05-29 22:10:12.761804315 -0400
@@ -35,6 +35,8 @@
 	const struct sde_format_extended *fmts = wb_dev->wb_cfg->format_list;
 	int i;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
+
 	if (!fmts)
 		return false;
 
@@ -53,7 +55,7 @@
 {
 	enum drm_connector_status rc = connector_status_unknown;
 
-	SDE_DEBUG("\n");
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (display)
 		rc = ((struct sde_wb_device *)display)->detect_status;
@@ -67,12 +69,13 @@
 	struct sde_wb_device *wb_dev;
 	int num_modes = 0;
 
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!connector || !display)
 		return 0;
 
 	wb_dev = display;
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 	if (wb_dev->count_modes && wb_dev->modes) {
@@ -110,6 +113,7 @@
 struct drm_framebuffer *
 sde_wb_connector_state_get_output_fb(struct drm_connector_state *state)
 {
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!state || !state->connector ||
 		(state->connector->connector_type !=
 				DRM_MODE_CONNECTOR_VIRTUAL)) {
@@ -117,7 +121,7 @@
 		return NULL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	return sde_connector_get_out_fb(state);
 }
@@ -125,6 +129,7 @@
 int sde_wb_connector_state_get_output_roi(struct drm_connector_state *state,
 		struct sde_rect *roi)
 {
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	if (!state || !roi || !state->connector ||
 		(state->connector->connector_type !=
 				DRM_MODE_CONNECTOR_VIRTUAL)) {
@@ -132,7 +137,7 @@
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	roi->x = sde_connector_get_property(state, CONNECTOR_PROP_DST_X);
 	roi->y = sde_connector_get_property(state, CONNECTOR_PROP_DST_Y);
@@ -158,6 +163,7 @@
 	struct drm_mode_modeinfo *modeinfo = NULL;
 	int ret = 0;
 	int i;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev || !wb_dev->connector ||
 			(wb_dev->connector->connector_type !=
@@ -166,10 +172,10 @@
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	if (connected) {
-		SDE_DEBUG("connect\n");
+		printk("connect\n");
 
 		if (!count_modes || !modes) {
 			SDE_ERROR("invalid count_modes :%u and modes :%d\n",
@@ -236,7 +242,7 @@
 		wb_dev->modes = modeinfo;
 		wb_dev->detect_status = connector_status_connected;
 	} else {
-		SDE_DEBUG("disconnect\n");
+		printk("disconnect\n");
 
 		if (wb_dev->modes) {
 			wb_dev->count_modes = 0;
@@ -261,8 +267,9 @@
 	struct sde_wb_device *wb_dev = display;
 	struct drm_framebuffer *out_fb;
 	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	if (state && (property_index == CONNECTOR_PROP_OUT_FB)) {
 		const struct sde_format *sde_format;
@@ -297,6 +304,7 @@
 		struct msm_display_info *info, void *display)
 {
 	struct sde_wb_device *wb_dev = display;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!info || !wb_dev) {
 		pr_err("invalid params\n");
@@ -329,6 +337,7 @@
 	struct sde_wb_device *wb_dev = display;
 	u16 hdisplay;
 	int i;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!drm_mode || !mode_info || !avail_res ||
 			!avail_res->max_mixer_width || !display) {
@@ -360,6 +369,7 @@
 {
 	struct sde_wb_device *wb_dev = display;
 	const struct sde_format_extended *format_list;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!connector || !info || !display || !wb_dev->wb_cfg) {
 		SDE_ERROR("invalid params\n");
@@ -406,6 +416,7 @@
 		{SDE_DRM_FB_NON_SEC, "non_sec"},
 		{SDE_DRM_FB_SEC, "sec"},
 	};
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!connector || !display || !wb_dev->wb_cfg) {
 		SDE_ERROR("invalid params\n");
@@ -442,13 +453,14 @@
 struct drm_framebuffer *sde_wb_get_output_fb(struct sde_wb_device *wb_dev)
 {
 	struct drm_framebuffer *fb;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev || !wb_dev->connector) {
 		SDE_ERROR("invalid params\n");
 		return NULL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 	fb = sde_wb_connector_state_get_output_fb(wb_dev->connector->state);
@@ -465,8 +477,9 @@
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 	rc = sde_wb_connector_state_get_output_roi(
@@ -481,7 +494,7 @@
 	u32 count = 0;
 	struct sde_wb_device *wb_dev;
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&sde_wb_list_lock);
 	list_for_each_entry(wb_dev, &sde_wb_list, wb_list) {
@@ -496,8 +509,9 @@
 {
 	struct sde_wb_device *curr;
 	int i = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	if (!display_array || !max_display_count) {
 		if (!display_array)
@@ -534,8 +548,9 @@
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	flags = config->flags;
 	connector_id = config->connector_id;
@@ -585,14 +600,16 @@
 static int _sde_wb_dev_init(struct sde_wb_device *wb_dev)
 {
 	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev) {
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
+    printk("%s:%d, ACHEUL, out: %d", __FUNCTION__, __LINE__, rc);
 	return rc;
 }
 
@@ -603,13 +620,14 @@
 static int _sde_wb_dev_deinit(struct sde_wb_device *wb_dev)
 {
 	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev) {
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	return rc;
 }
@@ -624,6 +642,7 @@
 static int sde_wb_bind(struct device *dev, struct device *master, void *data)
 {
 	struct sde_wb_device *wb_dev;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!dev || !master) {
 		SDE_ERROR("invalid params\n");
@@ -636,7 +655,7 @@
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 	wb_dev->drm_dev = dev_get_drvdata(master);
@@ -655,6 +674,7 @@
 		struct device *master, void *data)
 {
 	struct sde_wb_device *wb_dev;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!dev) {
 		SDE_ERROR("invalid params\n");
@@ -667,7 +687,7 @@
 		return;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 	wb_dev->drm_dev = NULL;
@@ -687,13 +707,14 @@
 int sde_wb_drm_init(struct sde_wb_device *wb_dev, struct drm_encoder *encoder)
 {
 	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev || !wb_dev->drm_dev || !encoder) {
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	mutex_lock(&wb_dev->wb_lock);
 
@@ -716,13 +737,14 @@
 int sde_wb_drm_deinit(struct sde_wb_device *wb_dev)
 {
 	int rc = 0;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	if (!wb_dev) {
 		SDE_ERROR("invalid params\n");
 		return -EINVAL;
 	}
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	return rc;
 }
@@ -735,23 +757,26 @@
 {
 	struct sde_wb_device *wb_dev;
 	int ret;
+    printk("%s:%d, ACHEUL, in", __FUNCTION__, __LINE__);
 
 	wb_dev = devm_kzalloc(&pdev->dev, sizeof(*wb_dev), GFP_KERNEL);
-	if (!wb_dev)
+	if (!wb_dev) {
+        printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 		return -ENOMEM;
+    }
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	ret = of_property_read_u32(pdev->dev.of_node, "cell-index",
 			&wb_dev->index);
 	if (ret) {
-		SDE_DEBUG("cell index not set, default to 0\n");
+		printk("cell index not set, default to 0\n");
 		wb_dev->index = 0;
 	}
 
 	wb_dev->name = of_get_property(pdev->dev.of_node, "label", NULL);
 	if (!wb_dev->name) {
-		SDE_DEBUG("label not set, default to unknown\n");
+		printk("label not set, default to unknown\n");
 		wb_dev->name = "unknown";
 	}
 
@@ -766,10 +791,13 @@
 
 	if (!_sde_wb_dev_init(wb_dev)) {
 		ret = component_add(&pdev->dev, &sde_wb_comp_ops);
-		if (ret)
+		if (ret) {
+            printk("%s:%d, ACHEUL, error", __FUNCTION__, __LINE__);
 			pr_err("component add failed\n");
+        }
 	}
 
+    printk("%s:%d, ACHEUL, out: %d", __FUNCTION__, __LINE__, ret);
 	return ret;
 }
 
@@ -781,12 +809,13 @@
 {
 	struct sde_wb_device *wb_dev;
 	struct sde_wb_device *curr, *next;
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 
 	wb_dev = platform_get_drvdata(pdev);
 	if (!wb_dev)
 		return 0;
 
-	SDE_DEBUG("\n");
+	printk("\n");
 
 	(void)_sde_wb_dev_deinit(wb_dev);
 
@@ -825,11 +854,13 @@
 
 static int __init sde_wb_register(void)
 {
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	return platform_driver_register(&sde_wb_driver);
 }
 
 static void __exit sde_wb_unregister(void)
 {
+    printk("%s:%d, ACHEUL", __FUNCTION__, __LINE__);
 	platform_driver_unregister(&sde_wb_driver);
 }
 
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm/sde: sde_wb.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_dbg.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_dbg_evtlog.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_dbg.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_edid_parser.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_edid_parser.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_hdcp_1x.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_hdcp_2x.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_hdcp_2x.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_hdcp.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_io_util.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_power_handle.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_power_handle.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_rsc.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_rsc_hw.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_rsc_hw.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_rsc_hw_v3.c
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display/msm: sde_rsc_priv.h
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display: NOTICE
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display: pll
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack/display: rotator
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack: .gitignore
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack: Kbuild
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack: stub
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19/techpack: video
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: tools
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: usr
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: verity_dev_keys.x509
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel/msm-4.19: virt
Only in /media/bruno/T7-DevKit/devkit-1.1-FC.virgin/LINUX/android/kernel: tests
